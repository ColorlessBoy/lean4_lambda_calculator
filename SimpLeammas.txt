def Prop := Sort(0)
def Eq : (s0 : Sort(u_1)) -> s0 -> s0 -> Prop
def True : Prop
def Eq.refl : (s0 : Sort(u_1)) -> (a : s0) -> Eq s0 a a
def Eq.rec : (s0 : Sort(u_1)) -> (a : s0) -> (f0 : (b : s0) -> Eq s0 a b -> Sort(u)) -> f0 a (Eq.refl s0 a) -> (c : s0) -> (d : Eq s0 a c) -> f0 c d
def True.intro : True
thm trivial : True
  True.intro
def rfl := (s0 : Sort(u)) => (a : s0) => Eq.refl s0 a
thm Eq.symm : (s0 : Sort(u)) -> (a : s0) -> (b : s0) -> Eq s0 a b -> Eq s0 b a
  (s0 : Sort(u)) => (a : s0) => (b : s0) => (c : Eq s0 a b) => Eq.rec s0 a ((d : s0) => Eq s0 a d => Eq s0 d a) (rfl s0 a) b c
thm of_eq_true : (a : Prop) -> Eq Prop a True -> a
  (a : Prop) => (b : Eq Prop a True) => Eq.rec Prop True ((c : Prop) => Eq Prop True c => c) trivial a (Eq.symm Prop a True b)
def False : Prop
def Not := (a : Prop) => (a -> False)
def False.rec : (f0 : (a : False) -> Sort(u)) -> (b : False) -> f0 b
def False.elim := (s0 : Sort(u)) => (a : False) => False.rec ((b : False) => s0) a
def Eq.mp := (s0 : Sort(u)) => (s1 : Sort(u)) => (a : Eq Sort(u) s0 s1) => (b : s0) => Eq.rec Sort(u) s0 ((s2 : Sort(u)) => Eq Sort(u) s0 s2 => s2) b s1 a
thm of_eq_false : (a : Prop) -> Eq Prop a False -> Not a
  (a : Prop) => (b : Eq Prop a False) => (c : a) => False.elim False (Eq.mp a False b c)
def Iff : Prop -> Prop -> Prop
def propext : (a : Prop) -> (b : Prop) -> Iff a b -> Eq Prop a b
def Iff.intro : (a : Prop) -> (b : Prop) -> (a -> b) -> (b -> a) -> Iff a b
thm eq_true : (a : Prop) -> a -> Eq Prop a True
  (a : Prop) => (b : a) => propext a True (Iff.intro a True (a => trivial) (True => b))
def absurd := (a : Prop) => (s0 : Sort(v)) => (b : a) => (c : Not a) => False.rec (False => s0) (c b)
thm eq_false : (a : Prop) -> Not a -> Eq Prop a False
  (a : Prop) => (b : Not a) => propext a False (Iff.intro a False ((c : a) => absurd a False c b) ((d : False) => False.elim a d))
thm eq_false' : (a : Prop) -> (a -> False) -> Eq Prop a False
  (a : Prop) => (f0 : a -> False) => eq_false a f0
def Decidable : Prop -> Sort(0 + 1)
def Bool : Sort(0 + 1)
def Decidable.isFalse : (a : Prop) -> Not a -> Decidable a
def Decidable.isTrue : (a : Prop) -> a -> Decidable a
def Decidable.rec : (a : Prop) -> (f0 : Decidable a -> Sort(u)) -> ((b : Not a) -> f0 (Decidable.isFalse a b)) -> ((c : a) -> f0 (Decidable.isTrue a c)) -> (d : Decidable a) -> f0 d
def Decidable.casesOn := (a : Prop) => (f0 : Decidable a -> Sort(u)) => (b : Decidable a) => (f1 : (c : Not a) -> f0 (Decidable.isFalse a c)) => (f2 : (d : a) -> f0 (Decidable.isTrue a d)) => Decidable.rec a f0 ((e : Not a) => f1 e) ((f : a) => f2 f) b
def Bool.false : Bool
def Bool.true : Bool
def Decidable.decide := (a : Prop) => (b : Decidable a) => Decidable.casesOn a (Decidable a => Bool) b (Not a => Bool.false) (a => Bool.true)
def of_decide_eq_true.match_1 := (a : Prop) => (f0 : Decidable a -> Prop) => (b : Decidable a) => (f1 : (c : a) -> f0 (Decidable.isTrue a c)) => (f2 : (d : Not a) -> f0 (Decidable.isFalse a d)) => Decidable.casesOn a ((e : Decidable a) => f0 e) b ((f : Not a) => f2 f) ((g : a) => f1 g)
def Bool.rec : (f0 : (a : Bool) -> Sort(u)) -> f0 Bool.false -> f0 Bool.true -> (b : Bool) -> f0 b
def Bool.casesOn := (f0 : (a : Bool) -> Sort(u)) => (b : Bool) => (c : f0 Bool.false) => (d : f0 Bool.true) => Bool.rec f0 c d b
def ne_true_of_eq_false.match_1 := (f0 : (a : Bool) -> (b : Eq Bool a Bool.false) -> Prop) => (c : Bool) => (d : Eq Bool c Bool.false) => (f1 : (e : Eq Bool Bool.true Bool.false) -> f0 Bool.true e) => (f2 : (f : Eq Bool Bool.false Bool.false) -> f0 Bool.false f) => Bool.casesOn ((g : Bool) => ((h : Eq Bool g Bool.false) -> f0 g h)) c ((i : Eq Bool Bool.false Bool.false) => f2 i) ((j : Eq Bool Bool.true Bool.false) => f1 j) d
def Eq.ndrec := (s0 : Sort(u2)) => (a : s0) => (f0 : s0 -> Sort(u1)) => (b : f0 a) => (c : s0) => (d : Eq s0 a c) => Eq.rec s0 a ((e : s0) => Eq s0 a e => f0 e) b c d
def Bool.noConfusionType := (s0 : Sort(u)) => (a : Bool) => (b : Bool) => Bool.casesOn ((c : Bool) => Sort(u)) a (Bool.casesOn ((d : Bool) => Sort(u)) b (s0 -> s0) s0) (Bool.casesOn ((e : Bool) => Sort(u)) b s0 (s0 -> s0))
def Bool.noConfusion := (s0 : Sort(u)) => (a : Bool) => (b : Bool) => (c : Eq Bool a b) => Eq.ndrec Bool a ((d : Bool) => (Eq Bool a d -> Bool.noConfusionType s0 a d)) (Eq Bool a a => Bool.casesOn ((e : Bool) => Bool.noConfusionType s0 e e) a ((f : s0) => f) ((g : s0) => g)) b c c
thm ne_true_of_eq_false : (a : Bool) -> Eq Bool a Bool.false -> Not (Eq Bool a Bool.true)
  (a : Bool) => (b : Eq Bool a Bool.false) => ne_true_of_eq_false.match_1 ((c : Bool) => (d : Eq Bool c Bool.false) => Not (Eq Bool c Bool.true)) a b ((e : Eq Bool Bool.true Bool.false) => Bool.noConfusion (Not (Eq Bool Bool.true Bool.true)) Bool.true Bool.false e) (Eq Bool Bool.false Bool.false => (f : Eq Bool Bool.false Bool.true) => Bool.noConfusion False Bool.false Bool.true f)
def decide_eq_false.match_1 := (a : Prop) => (f0 : Decidable a -> Not a -> Prop) => (b : Decidable a) => (c : Not a) => (f1 : (d : a) -> (e : Not a) -> f0 (Decidable.isTrue a d) e) => (f2 : (f : Not a) -> (g : Not a) -> f0 (Decidable.isFalse a f) g) => Decidable.casesOn a ((h : Decidable a) => f0 h c) b ((i : Not a) => f2 i c) ((j : a) => f1 j c)
thm decide_eq_false : (a : Prop) -> (b : Decidable a) -> Not a -> Eq Bool (Decidable.decide a b) Bool.false
  (a : Prop) => (b : Decidable a) => (c : Not a) => decide_eq_false.match_1 a ((d : Decidable a) => (e : Not a) => Eq Bool (Decidable.decide a d) Bool.false) b c ((f : a) => (g : Not a) => absurd a (Eq Bool (Decidable.decide a (Decidable.isTrue a f)) Bool.false) f g) ((h : Not a) => (i : Not a) => rfl Bool (Decidable.decide a (Decidable.isFalse a h)))
thm of_decide_eq_true : (a : Prop) -> (b : Decidable a) -> Eq Bool (Decidable.decide a b) Bool.true -> a
  (a : Prop) => (b : Decidable a) => (c : Eq Bool (Decidable.decide a b) Bool.true) => of_decide_eq_true.match_1 a (Decidable a => a) b ((d : a) => d) ((e : Not a) => absurd (Eq Bool (Decidable.decide a b) Bool.true) a c (ne_true_of_eq_false (Decidable.decide a b) (decide_eq_false a b e)))
thm eq_true_of_decide : (a : Prop) -> (b : Decidable a) -> Eq Bool (Decidable.decide a b) Bool.true -> Eq Prop a True
  (a : Prop) => (b : Decidable a) => (c : Eq Bool (Decidable.decide a b) Bool.true) => eq_true a (of_decide_eq_true a b c)
def ne_false_of_eq_true.match_1 := (f0 : (a : Bool) -> (b : Eq Bool a Bool.true) -> Prop) => (c : Bool) => (d : Eq Bool c Bool.true) => (f1 : (e : Eq Bool Bool.true Bool.true) -> f0 Bool.true e) => (f2 : (f : Eq Bool Bool.false Bool.true) -> f0 Bool.false f) => Bool.casesOn ((g : Bool) => ((h : Eq Bool g Bool.true) -> f0 g h)) c ((i : Eq Bool Bool.false Bool.true) => f2 i) ((j : Eq Bool Bool.true Bool.true) => f1 j) d
thm ne_false_of_eq_true : (a : Bool) -> Eq Bool a Bool.true -> Not (Eq Bool a Bool.false)
  (a : Bool) => (b : Eq Bool a Bool.true) => ne_false_of_eq_true.match_1 ((c : Bool) => (d : Eq Bool c Bool.true) => Not (Eq Bool c Bool.false)) a b (Eq Bool Bool.true Bool.true => (e : Eq Bool Bool.true Bool.false) => Bool.noConfusion False Bool.true Bool.false e) ((f : Eq Bool Bool.false Bool.true) => Bool.noConfusion (Not (Eq Bool Bool.false Bool.false)) Bool.false Bool.true f)
def decide_eq_true.match_1 := (a : Prop) => (f0 : Decidable a -> a -> Prop) => (b : Decidable a) => (c : a) => (f1 : (d : a) -> (e : a) -> f0 (Decidable.isTrue a d) e) => (f2 : (f : Not a) -> (g : a) -> f0 (Decidable.isFalse a f) g) => Decidable.casesOn a ((h : Decidable a) => f0 h c) b ((i : Not a) => f2 i c) ((j : a) => f1 j c)
thm decide_eq_true : (a : Prop) -> (b : Decidable a) -> a -> Eq Bool (Decidable.decide a b) Bool.true
  (a : Prop) => (b : Decidable a) => (c : a) => decide_eq_true.match_1 a ((d : Decidable a) => (e : a) => Eq Bool (Decidable.decide a d) Bool.true) b c ((f : a) => (g : a) => rfl Bool (Decidable.decide a (Decidable.isTrue a f))) ((h : Not a) => (i : a) => absurd a (Eq Bool (Decidable.decide a (Decidable.isFalse a h)) Bool.true) i h)
thm of_decide_eq_false : (a : Prop) -> (b : Decidable a) -> Eq Bool (Decidable.decide a b) Bool.false -> Not a
  (a : Prop) => (b : Decidable a) => (c : Eq Bool (Decidable.decide a b) Bool.false) => of_decide_eq_true.match_1 a (Decidable a => Not a) b ((d : a) => absurd (Eq Bool (Decidable.decide a b) Bool.false) (Not a) c (ne_false_of_eq_true (Decidable.decide a b) (decide_eq_true a b d))) ((e : Not a) => e)
thm eq_false_of_decide : (a : Prop) -> (b : Decidable a) -> Eq Bool (Decidable.decide a b) Bool.false -> Eq Prop a False
  (a : Prop) => (b : Decidable a) => (c : Eq Bool (Decidable.decide a b) Bool.false) => eq_false a (of_decide_eq_false a b c)
thm implies_congr : (s0 : Sort(u)) -> (s1 : Sort(u)) -> (s2 : Sort(v)) -> (s3 : Sort(v)) -> Eq Sort(u) s0 s1 -> Eq Sort(v) s2 s3 -> Eq Sort(IMax(u,v)) (s0 -> s2) (s1 -> s3)
  (s0 : Sort(u)) => (s1 : Sort(u)) => (s2 : Sort(v)) => (s3 : Sort(v)) => (a : Eq Sort(u) s0 s1) => (b : Eq Sort(v) s2 s3) => Eq.rec Sort(u) s0 ((s4 : Sort(u)) => Eq Sort(u) s0 s4 => Eq Sort(IMax(u,v)) (s0 -> s2) (s4 -> s3)) (Eq.rec Sort(v) s2 ((s5 : Sort(v)) => Eq Sort(v) s2 s5 => Eq Sort(IMax(u,v)) (s0 -> s2) (s0 -> s5)) (rfl Sort(IMax(u,v)) (s0 -> s2)) s3 b) s1 a
thm Iff.refl : (a : Prop) -> Iff a a
  (a : Prop) => Iff.intro a a ((b : a) => b) ((c : a) => c)
thm Iff.rfl : (a : Prop) -> Iff a a
  (a : Prop) => Iff.refl a
thm Iff.of_eq : (a : Prop) -> (b : Prop) -> Eq Prop a b -> Iff a b
  (a : Prop) => (b : Prop) => (c : Eq Prop a b) => Eq.rec Prop a ((d : Prop) => Eq Prop a d => Iff a d) (Iff.rfl a) b c
thm iff_congr : (a : Prop) -> (b : Prop) -> (c : Prop) -> (d : Prop) -> Iff a b -> Iff c d -> Iff (Iff a c) (Iff b d)
  (a : Prop) => (b : Prop) => (c : Prop) => (d : Prop) => (e : Iff a b) => (f : Iff c d) => Iff.of_eq (Iff a c) (Iff b d) (Eq.rec Prop a ((g : Prop) => Eq Prop a g => Eq Prop (Iff a c) (Iff g d)) (Eq.rec Prop c ((h : Prop) => Eq Prop c h => Eq Prop (Iff a c) (Iff a h)) (rfl Prop (Iff a c)) d (propext c d f)) b (propext a b e))
def Eq.mpr := (s0 : Sort(u)) => (s1 : Sort(u)) => (a : Eq Sort(u) s0 s1) => (b : s1) => Eq.rec Sort(u) s1 ((s2 : Sort(u)) => Eq Sort(u) s1 s2 => s2) b s0 (Eq.symm Sort(u) s0 s1 a)
thm implies_dep_congr_ctx : (a : Prop) -> (b : Prop) -> (c : Prop) -> Eq Prop a b -> (f0 : b -> Prop) -> ((d : b) -> Eq Prop c (f0 d)) -> Eq Prop (a -> c) ((e : b) -> f0 e)
  (a : Prop) => (b : Prop) => (c : Prop) => (d : Eq Prop a b) => (f0 : b -> Prop) => (f1 : (e : b) -> Eq Prop c (f0 e)) => propext ((f : a) -> c) ((g : b) -> f0 g) (Iff.intro ((h : a) -> c) ((i : b) -> f0 i) ((f2 : (j : a) -> c) => (k : b) => Eq.mp c (f0 k) (f1 k) (f2 (Eq.mpr a b d k))) ((f3 : (l : b) -> f0 l) => (m : a) => Eq.mpr c (f0 (Eq.mp a b d m)) (f1 (Eq.mp a b d m)) (f3 (Eq.mp a b d m))))
thm implies_congr_ctx : (a : Prop) -> (b : Prop) -> (c : Prop) -> (d : Prop) -> Eq Prop a b -> (b -> Eq Prop c d) -> Eq Prop (a -> c) (b -> d)
  (a : Prop) => (b : Prop) => (c : Prop) => (d : Prop) => (e : Eq Prop a b) => (f0 : b -> Eq Prop c d) => implies_dep_congr_ctx a b c e (b => d) f0
thm funext : (s0 : Sort(u)) -> (f0 : s0 -> Sort(v)) -> (f1 : (a : s0) -> f0 a) -> (f2 : (b : s0) -> f0 b) -> ((c : s0) -> Eq (f0 c) (f1 c) (f2 c)) -> Eq ((d : s0) -> f0 d) f1 f2
thm forall_congr : (s0 : Sort(u)) -> (f0 : s0 -> Prop) -> (f1 : s0 -> Prop) -> ((a : s0) -> Eq Prop (f0 a) (f1 a)) -> Eq Prop ((b : s0) -> f0 b) ((c : s0) -> f1 c)
  (s0 : Sort(u)) => (f0 : s0 -> Prop) => (f1 : s0 -> Prop) => (f2 : (a : s0) -> Eq Prop (f0 a) (f1 a)) => Eq.rec ((b : s0) -> Prop) f0 ((f3 : (c : s0) -> Prop) => Eq (s0 -> Prop) f0 f3 => Eq Prop ((d : s0) -> f0 d) ((e : s0) -> f3 e)) (rfl Prop ((f : s0) -> f0 f)) f1 (funext s0 ((g : s0) => Prop) f0 f1 f2)
thm Eq.substr : (s0 : Sort(u)) -> (f0 : s0 -> Prop) -> (a : s0) -> (b : s0) -> Eq s0 b a -> f0 a -> f0 b
  (s0 : Sort(u)) => (f0 : s0 -> Prop) => (a : s0) => (b : s0) => (c : Eq s0 b a) => (d : f0 a) => Eq.rec s0 a ((e : s0) => Eq s0 a e => f0 e) d b (Eq.symm s0 b a c)
thm Eq.trans : (s0 : Sort(u)) -> (a : s0) -> (b : s0) -> (c : s0) -> Eq s0 a b -> Eq s0 b c -> Eq s0 a c
  (s0 : Sort(u)) => (a : s0) => (b : s0) => (c : s0) => (d : Eq s0 a b) => (e : Eq s0 b c) => Eq.rec s0 b ((f : s0) => Eq s0 b f => Eq s0 a f) d c e
thm congrArg : (s0 : Sort(u)) -> (s1 : Sort(v)) -> (a : s0) -> (b : s0) -> (f0 : s0 -> s1) -> Eq s0 a b -> Eq s1 (f0 a) (f0 b)
  (s0 : Sort(u)) => (s1 : Sort(v)) => (a : s0) => (b : s0) => (f0 : s0 -> s1) => (c : Eq s0 a b) => Eq.rec s0 a ((d : s0) => Eq s0 a d => Eq s1 (f0 a) (f0 d)) (rfl s1 (f0 a)) b c
thm eq_self : (s0 : Sort(u_1)) -> (a : s0) -> Eq Prop (Eq s0 a a) True
  (s0 : Sort(u_1)) => (a : s0) => eq_true (Eq s0 a a) (rfl s0 a)
thm forall_prop_domain_congr : (a : Prop) -> (b : Prop) -> (f0 : a -> Prop) -> (f1 : b -> Prop) -> (c : Eq Prop a b) -> ((d : b) -> Eq Prop (f0 (Eq.substr Prop ((e : Prop) => e) b a c d)) (f1 d)) -> Eq Prop ((f : a) -> f0 f) ((g : b) -> f1 g)
  (a : Prop) => (b : Prop) => (f0 : a -> Prop) => (f1 : b -> Prop) => (c : Eq Prop a b) => (f2 : (d : b) -> Eq Prop (f0 (Eq.substr Prop ((e : Prop) => e) b a c d)) (f1 d)) => Eq.rec Prop a ((f : Prop) => (g : Eq Prop a f) => ((f3 : f -> Prop) -> ((h : f) -> Eq Prop (f0 (Eq.substr Prop ((i : Prop) => i) f a g h)) (f3 h)) -> Eq Prop ((j : a) -> f0 j) ((k : f) -> f3 k))) ((f4 : a -> Prop) => (f5 : (l : a) -> Eq Prop (f0 (Eq.substr Prop ((m : Prop) => m) a a (Eq.refl Prop a) l)) (f4 l)) => of_eq_true (Eq Prop ((n : a) -> f0 n) ((o : a) -> f4 o)) (Eq.trans Prop (Eq Prop ((p : a) -> f0 p) ((q : a) -> f4 q)) (Eq Prop ((r : a) -> f0 r) ((s : a) -> f0 (Eq.substr Prop ((t : Prop) => t) a a (Eq.refl Prop a) s))) True (congrArg Prop Prop ((u : a) -> f4 u) ((v : a) -> f0 (Eq.substr Prop ((w : Prop) => w) a a (Eq.refl Prop a) v)) (Eq Prop ((x : a) -> f0 x)) (forall_congr a f4 ((y : a) => f0 (Eq.substr Prop ((z : Prop) => z) a a (Eq.refl Prop a) y)) ((A : a) => ((B : a) => Eq.symm Prop (f0 (Eq.substr Prop ((C : Prop) => C) a a (Eq.refl Prop a) B)) (f4 B) (f5 B)) A))) (eq_self Prop ((D : a) -> f0 D)))) b c f1 f2
thm forall_prop_congr_dom : (a : Prop) -> (b : Prop) -> (c : Eq Prop a b) -> (f0 : (d : a) -> Prop) -> Eq Prop ((e : a) -> f0 e) ((f : b) -> f0 (Eq.substr Prop ((g : Prop) => g) b a c f))
  (a : Prop) => (b : Prop) => (c : Eq Prop a b) => (f0 : a -> Prop) => ((d : Eq Prop ((e : a) -> f0 e) ((f : a) -> f0 f)) => Eq.rec Prop a ((g : Prop) => (h : Eq Prop a g) => Eq Prop ((i : a) -> f0 i) ((j : g) -> f0 (Eq.substr Prop ((k : Prop) => k) g a h j))) d b c) (rfl Prop ((l : a) -> f0 l))
thm pi_congr : (s0 : Sort(u)) -> (f0 : s0 -> Sort(v)) -> (f1 : s0 -> Sort(v)) -> ((a : s0) -> Eq Sort(v) (f0 a) (f1 a)) -> Eq Sort(IMax(u,v)) ((b : s0) -> f0 b) ((c : s0) -> f1 c)
  (s0 : Sort(u)) => (f0 : s0 -> Sort(v)) => (f1 : s0 -> Sort(v)) => (f2 : (a : s0) -> Eq Sort(v) (f0 a) (f1 a)) => Eq.rec ((b : s0) -> Sort(v)) f0 ((f3 : (c : s0) -> Sort(v)) => Eq (s0 -> Sort(v)) f0 f3 => Eq Sort(IMax(u,v)) ((d : s0) -> f0 d) ((e : s0) -> f3 e)) (rfl Sort(IMax(u,v)) ((f : s0) -> f0 f)) f1 (funext s0 ((g : s0) => Sort(v)) f0 f1 f2)



def ite : (s0 : Sort(u)) -> (a : Prop) -> Decidable a -> s0 -> s0 -> s0
def Or : Prop -> Prop -> Prop
def Or.inl : (a : Prop) -> (b : Prop) -> a -> Or a b
def Or.inr : (a : Prop) -> (b : Prop) -> b -> Or a b
def Or.rec : (a : Prop) -> (b : Prop) -> (f0 : Or a b -> Prop) -> ((c : a) -> f0 (Or.inl a b c)) -> ((d : b) -> f0 (Or.inr a b d)) -> (e : Or a b) -> f0 e
def Or.casesOn := (a : Prop) => (b : Prop) => (f0 : Or a b -> Prop) => (c : Or a b) => (f1 : (d : a) -> f0 (Or.inl a b d)) => (f2 : (e : b) -> f0 (Or.inr a b e)) => Or.rec a b f0 ((f : a) => f1 f) ((g : b) => f2 g) c
def Decidable.byCases.match_1 := (a : Prop) => (f0 : Decidable a -> Sort(u_1)) => (b : Decidable a) => (f1 : (c : a) -> f0 (Decidable.isTrue a c)) => (f2 : (d : Not a) -> f0 (Decidable.isFalse a d)) => Decidable.casesOn a ((e : Decidable a) => f0 e) b ((f : Not a) => f2 f) ((g : a) => f1 g)
def Decidable.byCases := (a : Prop) => (s0 : Sort(u)) => (b : Decidable a) => (f0 : a -> s0) => (f1 : Not a -> s0) => Decidable.byCases.match_1 a (Decidable a => s0) b ((c : a) => f0 c) ((d : Not a) => f1 d)
thm Decidable.em : (a : Prop) -> Decidable a -> Or a (Not a)
  (a : Prop) => (b : Decidable a) => Decidable.byCases a (Or a (Not a)) b (Or.inl a (Not a)) (Or.inr a (Not a))
def id := (s0 : Sort(u)) => (a : s0) => a
def if_pos : (a : Prop) -> (b : Decidable a) -> (c : a) -> (s0 : Sort(u)) -> (d : s0) -> (e : s0) -> Eq s0 (ite s0 a b d e) d
def if_neg : (a : Prop) -> (b : Decidable a) -> Not a -> (s0 : Sort(u)) -> (c : s0) -> (d : s0) -> Eq s0 (ite s0 a b c d) d
thm ite_congr : (s0 : Sort(u_1)) -> (a : Prop) -> (b : Prop) -> (c : s0) -> (d : s0) -> (e : s0) -> (f : s0) -> (g : Decidable a) -> (h : Decidable b) -> Eq Prop a b -> (b -> Eq s0 c e) -> (Not b -> Eq s0 d f) -> Eq s0 (ite s0 a g c d) (ite s0 b h e f)
  (s0 : Sort(u_1)) => (a : Prop) => (b : Prop) => (c : s0) => (d : s0) => (e : s0) => (f : s0) => (g : Decidable a) => (h : Decidable b) => (i : Eq Prop a b) => (f0 : b -> Eq s0 c e) => (f1 : Not b -> Eq s0 d f) => Or.casesOn b (Not b) ((j : Or b (Not b)) => (Eq (Or b (Not b)) (Decidable.em b h) j -> Eq s0 (ite s0 a g c d) (ite s0 b h e f))) (Decidable.em b h) ((k : b) => Eq (Or b (Not b)) (Decidable.em b h) (Or.inl b (Not b) k) => Eq.mpr (Eq s0 (ite s0 a g c d) (ite s0 b h e f)) (Eq s0 (ite s0 a g c d) e) (id (Eq Prop (Eq s0 (ite s0 a g c d) (ite s0 b h e f)) (Eq s0 (ite s0 a g c d) e)) (congrArg s0 Prop (ite s0 b h e f) e ((l : s0) => Eq s0 (ite s0 a g c d) l) (if_pos b h k s0 e f))) (Eq.ndrec Prop b ((m : Prop) => ((n : Decidable m) -> Eq s0 (ite s0 m n c d) e)) ((o : Decidable b) => Eq.mpr (Eq s0 (ite s0 b o c d) e) (Eq s0 c e) (id (Eq Prop (Eq s0 (ite s0 b o c d) e) (Eq s0 c e)) (congrArg s0 Prop (ite s0 b o c d) c ((p : s0) => Eq s0 p e) (if_pos b o k s0 c d))) (f0 k)) a (Eq.symm Prop a b i) g)) ((q : Not b) => Eq (Or b (Not b)) (Decidable.em b h) (Or.inr b (Not b) q) => Eq.mpr (Eq s0 (ite s0 a g c d) (ite s0 b h e f)) (Eq s0 (ite s0 a g c d) f) (id (Eq Prop (Eq s0 (ite s0 a g c d) (ite s0 b h e f)) (Eq s0 (ite s0 a g c d) f)) (congrArg s0 Prop (ite s0 b h e f) f ((r : s0) => Eq s0 (ite s0 a g c d) r) (if_neg b h q s0 e f))) (Eq.ndrec Prop b ((s : Prop) => ((t : Decidable s) -> Eq s0 (ite s0 s t c d) f)) ((u : Decidable b) => Eq.mpr (Eq s0 (ite s0 b u c d) f) (Eq s0 d f) (id (Eq Prop (Eq s0 (ite s0 b u c d) f) (Eq s0 d f)) (congrArg s0 Prop (ite s0 b u c d) d ((v : s0) => Eq s0 v f) (if_neg b u q s0 c d))) (f1 q)) a (Eq.symm Prop a b i) g)) (Eq.refl (Or b (Not b)) (Decidable.em b h))
thm Eq.mpr_prop : (a : Prop) -> (b : Prop) -> Eq Prop a b -> b -> a
  (a : Prop) => (b : Prop) => (c : Eq Prop a b) => (d : b) => Eq.rec Prop b ((e : Prop) => Eq Prop b e => e) d a (Eq.symm Prop a b c)
thm Eq.mpr_not : (a : Prop) -> (b : Prop) -> Eq Prop a b -> Not b -> Not a
  (a : Prop) => (b : Prop) => (c : Eq Prop a b) => (d : Not b) => Eq.rec Prop b ((e : Prop) => Eq Prop b e => Not e) d a (Eq.symm Prop a b c)
def dite := (s0 : Sort(u)) => (a : Prop) => (b : Decidable a) => (f0 : a -> s0) => (f1 : Not a -> s0) => Decidable.casesOn a (Decidable a => s0) b f1 f0
def if_pos.match_1 := (a : Prop) => (f0 : Decidable a -> Prop) => (b : Decidable a) => (f1 : (c : a) -> f0 (Decidable.isTrue a c)) => (f2 : (d : Not a) -> f0 (Decidable.isFalse a d)) => Decidable.casesOn a ((e : Decidable a) => f0 e) b ((f : Not a) => f2 f) ((g : a) => f1 g)
thm dif_pos : (a : Prop) -> (b : Decidable a) -> (c : a) -> (s0 : Sort(u)) -> (f0 : a -> s0) -> (f1 : Not a -> s0) -> Eq s0 (dite s0 a b f0 f1) (f0 c)
  (a : Prop) => (b : Decidable a) => (c : a) => (s0 : Sort(u)) => (f0 : a -> s0) => (f1 : Not a -> s0) => if_pos.match_1 a ((d : Decidable a) => Eq s0 (dite s0 a d f0 f1) (f0 c)) b ((e : a) => rfl s0 (dite s0 a (Decidable.isTrue a e) f0 f1)) ((f : Not a) => absurd a (Eq s0 (dite s0 a (Decidable.isFalse a f) f0 f1) (f0 c)) c f)
thm dif_neg : (a : Prop) -> (b : Decidable a) -> (c : Not a) -> (s0 : Sort(u)) -> (f0 : a -> s0) -> (f1 : Not a -> s0) -> Eq s0 (dite s0 a b f0 f1) (f1 c)
  (a : Prop) => (b : Decidable a) => (c : Not a) => (s0 : Sort(u)) => (f0 : a -> s0) => (f1 : Not a -> s0) => if_pos.match_1 a ((d : Decidable a) => Eq s0 (dite s0 a d f0 f1) (f1 c)) b ((e : a) => absurd a (Eq s0 (dite s0 a (Decidable.isTrue a e) f0 f1) (f1 c)) e c) ((f : Not a) => rfl s0 (dite s0 a (Decidable.isFalse a f) f0 f1))
thm dite_congr : (a : Prop) -> (b : Prop) -> (s0 : Sort(u_1)) -> (c : Decidable a) -> (d : Decidable b) -> (f0 : a -> s0) -> (f1 : b -> s0) -> (f2 : Not a -> s0) -> (f3 : Not b -> s0) -> (e : Eq Prop a b) -> ((f : b) -> Eq s0 (f0 (Eq.mpr_prop a b e f)) (f1 f)) -> ((g : Not b) -> Eq s0 (f2 (Eq.mpr_not a b e g)) (f3 g)) -> Eq s0 (dite s0 a c f0 f2) (dite s0 b d f1 f3)
  (a : Prop) => (b : Prop) => (s0 : Sort(u_1)) => (c : Decidable a) => (d : Decidable b) => (f0 : a -> s0) => (f1 : b -> s0) => (f2 : Not a -> s0) => (f3 : Not b -> s0) => (e : Eq Prop a b) => (f4 : (f : b) -> Eq s0 (f0 (Eq.mpr_prop a b e f)) (f1 f)) => (f5 : (g : Not b) -> Eq s0 (f2 (Eq.mpr_not a b e g)) (f3 g)) => Or.casesOn b (Not b) ((h : Or b (Not b)) => (Eq (Or b (Not b)) (Decidable.em b d) h -> Eq s0 (dite s0 a c f0 f2) (dite s0 b d f1 f3))) (Decidable.em b d) ((i : b) => Eq (Or b (Not b)) (Decidable.em b d) (Or.inl b (Not b) i) => Eq.mpr (Eq s0 (dite s0 a c f0 f2) (dite s0 b d f1 f3)) (Eq s0 (dite s0 a c f0 f2) (f1 i)) (id (Eq Prop (Eq s0 (dite s0 a c f0 f2) (dite s0 b d f1 f3)) (Eq s0 (dite s0 a c f0 f2) (f1 i))) (congrArg s0 Prop (dite s0 b d f1 f3) (f1 i) ((j : s0) => Eq s0 (dite s0 a c f0 f2) j) (dif_pos b d i s0 f1 f3))) (Eq.rec Prop b ((k : Prop) => (l : Eq Prop b k) => ((m : Decidable k) -> (f6 : k -> s0) -> (f7 : Not k -> s0) -> ((n : b) -> Eq s0 (f6 (Eq.mpr_prop k b (Eq.symm Prop b k l) n)) (f1 n)) -> ((o : Not b) -> Eq s0 (f7 (Eq.mpr_not k b (Eq.symm Prop b k l) o)) (f3 o)) -> Eq s0 (dite s0 k m f6 f7) (f1 i))) ((p : Decidable b) => (f8 : b -> s0) => (f9 : Not b -> s0) => (f10 : (q : b) -> Eq s0 (f8 (Eq.mpr_prop b b (Eq.refl Prop b) q)) (f1 q)) => (f11 : (r : Not b) -> Eq s0 (f9 (Eq.mpr_not b b (Eq.refl Prop b) r)) (f3 r)) => Eq.mpr (Eq s0 (dite s0 b p f8 f9) (f1 i)) (Eq s0 (f8 i) (f1 i)) (id (Eq Prop (Eq s0 (dite s0 b p f8 f9) (f1 i)) (Eq s0 (f8 i) (f1 i))) (congrArg s0 Prop (dite s0 b p f8 f9) (f8 i) ((s : s0) => Eq s0 s (f1 i)) (dif_pos b p i s0 f8 f9))) (f10 i)) a (Eq.symm Prop a b e) c f0 f2 f4 f5)) ((t : Not b) => Eq (Or b (Not b)) (Decidable.em b d) (Or.inr b (Not b) t) => Eq.mpr (Eq s0 (dite s0 a c f0 f2) (dite s0 b d f1 f3)) (Eq s0 (dite s0 a c f0 f2) (f3 t)) (id (Eq Prop (Eq s0 (dite s0 a c f0 f2) (dite s0 b d f1 f3)) (Eq s0 (dite s0 a c f0 f2) (f3 t))) (congrArg s0 Prop (dite s0 b d f1 f3) (f3 t) ((u : s0) => Eq s0 (dite s0 a c f0 f2) u) (dif_neg b d t s0 f1 f3))) (Eq.rec Prop b ((v : Prop) => (w : Eq Prop b v) => ((x : Decidable v) -> (f12 : v -> s0) -> (f13 : Not v -> s0) -> ((y : b) -> Eq s0 (f12 (Eq.mpr_prop v b (Eq.symm Prop b v w) y)) (f1 y)) -> ((z : Not b) -> Eq s0 (f13 (Eq.mpr_not v b (Eq.symm Prop b v w) z)) (f3 z)) -> Eq s0 (dite s0 v x f12 f13) (f3 t))) ((A : Decidable b) => (f14 : b -> s0) => (f15 : Not b -> s0) => (f16 : (B : b) -> Eq s0 (f14 (Eq.mpr_prop b b (Eq.refl Prop b) B)) (f1 B)) => (f17 : (C : Not b) -> Eq s0 (f15 (Eq.mpr_not b b (Eq.refl Prop b) C)) (f3 C)) => Eq.mpr (Eq s0 (dite s0 b A f14 f15) (f3 t)) (Eq s0 (f15 t) (f3 t)) (id (Eq Prop (Eq s0 (dite s0 b A f14 f15) (f3 t)) (Eq s0 (f15 t) (f3 t))) (congrArg s0 Prop (dite s0 b A f14 f15) (f15 t) ((D : s0) => Eq s0 D (f3 t)) (dif_neg b A t s0 f14 f15))) (f17 t)) a (Eq.symm Prop a b e) c f0 f2 f4 f5)) (Eq.refl (Or b (Not b)) (Decidable.em b d))
def instDecidableTrue := Decidable.isTrue True trivial
thm ite_cond_eq_true : (s0 : Sort(u)) -> (a : Prop) -> (b : Decidable a) -> (c : s0) -> (d : s0) -> Eq Prop a True -> Eq s0 (ite s0 a b c d) c
  (s0 : Sort(u)) => (a : Prop) => (b : Decidable a) => (c : s0) => (d : s0) => (e : Eq Prop a True) => of_eq_true (Eq s0 (ite s0 a b c d) c) (Eq.trans Prop (Eq s0 (ite s0 a b c d) c) (Eq s0 (ite s0 True instDecidableTrue c d) c) True (congrArg s0 Prop (ite s0 a b c d) (ite s0 True instDecidableTrue c d) ((f : s0) => Eq s0 f c) (ite_congr s0 a True c d c d b instDecidableTrue e (True => Eq.refl s0 c) (Not True => Eq.refl s0 d))) (eq_self s0 c))
thm not_false : Not False
  id False
def instDecidableFalse := Decidable.isFalse False not_false
thm ite_cond_eq_false : (s0 : Sort(u)) -> (a : Prop) -> (b : Decidable a) -> (c : s0) -> (d : s0) -> Eq Prop a False -> Eq s0 (ite s0 a b c d) d
  (s0 : Sort(u)) => (a : Prop) => (b : Decidable a) => (c : s0) => (d : s0) => (e : Eq Prop a False) => of_eq_true (Eq s0 (ite s0 a b c d) d) (Eq.trans Prop (Eq s0 (ite s0 a b c d) d) (Eq s0 (ite s0 False instDecidableFalse c d) d) True (congrArg s0 Prop (ite s0 a b c d) (ite s0 False instDecidableFalse c d) ((f : s0) => Eq s0 f d) (ite_congr s0 a False c d c d b instDecidableFalse e (False => Eq.refl s0 c) (Not False => Eq.refl s0 d))) (eq_self s0 d))
thm dite_cond_eq_true : (s0 : Sort(u)) -> (a : Prop) -> (b : Decidable a) -> (f0 : a -> s0) -> (f1 : Not a -> s0) -> (c : Eq Prop a True) -> Eq s0 (dite s0 a b f0 f1) (f0 (of_eq_true a c))
  (s0 : Sort(u)) => (a : Prop) => (b : Decidable a) => (f0 : a -> s0) => (f1 : Not a -> s0) => (c : Eq Prop a True) => of_eq_true (Eq s0 (dite s0 a b f0 f1) (f0 (of_eq_true a c))) (Eq.trans Prop (Eq s0 (dite s0 a b f0 f1) (f0 (of_eq_true a c))) (Eq s0 (dite s0 True instDecidableTrue ((d : True) => f0 (Eq.mpr_prop a True c d)) ((e : Not True) => f1 (Eq.mpr_not a True c e))) (f0 (of_eq_true a c))) True (congrArg s0 Prop (dite s0 a b f0 f1) (dite s0 True instDecidableTrue ((f : True) => f0 (Eq.mpr_prop a True c f)) ((g : Not True) => f1 (Eq.mpr_not a True c g))) ((h : s0) => Eq s0 h (f0 (of_eq_true a c))) (dite_congr a True s0 b instDecidableTrue f0 ((i : True) => f0 (Eq.mpr_prop a True c i)) f1 ((j : Not True) => f1 (Eq.mpr_not a True c j)) c ((k : True) => Eq.refl s0 (f0 (Eq.mpr_prop a True c k))) ((l : Not True) => Eq.refl s0 (f1 (Eq.mpr_not a True c l))))) (eq_self s0 (f0 (Eq.mpr_prop a True c True.intro))))
thm dite_cond_eq_false : (s0 : Sort(u)) -> (a : Prop) -> (b : Decidable a) -> (f0 : a -> s0) -> (f1 : Not a -> s0) -> (c : Eq Prop a False) -> Eq s0 (dite s0 a b f0 f1) (f1 (of_eq_false a c))
  (s0 : Sort(u)) => (a : Prop) => (b : Decidable a) => (f0 : a -> s0) => (f1 : Not a -> s0) => (c : Eq Prop a False) => of_eq_true (Eq s0 (dite s0 a b f0 f1) (f1 (of_eq_false a c))) (Eq.trans Prop (Eq s0 (dite s0 a b f0 f1) (f1 (of_eq_false a c))) (Eq s0 (dite s0 False instDecidableFalse ((d : False) => f0 (Eq.mpr_prop a False c d)) ((e : Not False) => f1 (Eq.mpr_not a False c e))) (f1 (of_eq_false a c))) True (congrArg s0 Prop (dite s0 a b f0 f1) (dite s0 False instDecidableFalse ((f : False) => f0 (Eq.mpr_prop a False c f)) ((g : Not False) => f1 (Eq.mpr_not a False c g))) ((h : s0) => Eq s0 h (f1 (of_eq_false a c))) (dite_congr a False s0 b instDecidableFalse f0 ((i : False) => f0 (Eq.mpr_prop a False c i)) f1 ((j : Not False) => f1 (Eq.mpr_not a False c j)) c ((k : False) => Eq.refl s0 (f0 (Eq.mpr_prop a False c k))) ((l : Not False) => Eq.refl s0 (f1 (Eq.mpr_not a False c l))))) (eq_self s0 (f1 (Eq.mpr_not a False c not_false))))
def And : Prop -> Prop -> Prop
def And.intro : (a : Prop) -> (b : Prop) -> a -> b -> And a b
def And.rec : (a : Prop) -> (b : Prop) -> (f0 : And a b -> Sort(u)) -> ((c : a) -> (d : b) -> f0 (And.intro a b c d)) -> (e : And a b) -> f0 e
def And.casesOn := (a : Prop) => (b : Prop) => (f0 : And a b -> Sort(u)) => (c : And a b) => (f1 : (d : a) -> (e : b) -> f0 (And.intro a b d e)) => And.rec a b f0 ((f : a) => (g : b) => f1 f g) c
def and_imp.match_1 := (a : Prop) => (b : Prop) => (f0 : And a b -> Prop) => (c : And a b) => (f1 : (d : a) -> (e : b) -> f0 (And.intro a b d e)) => And.casesOn a b ((f : And a b) => f0 f) c ((g : a) => (h : b) => f1 g h)
def Iff.mp : (a : Prop) -> (b : Prop) -> Iff a b -> a -> b
def Iff.mpr : (a : Prop) -> (b : Prop) -> Iff a b -> b -> a
thm and_congr_right : (a : Prop) -> (b : Prop) -> (c : Prop) -> (a -> Iff b c) -> Iff (And a b) (And a c)
  (a : Prop) => (b : Prop) => (c : Prop) => (f0 : a -> Iff b c) => Iff.intro (And a b) (And a c) ((d : And a b) => and_imp.match_1 a b (And a b => And a c) d ((e : a) => (f : b) => And.intro a c e (Iff.mp b c (f0 e) f))) ((g : And a c) => and_imp.match_1 a c (And a c => And a b) g ((h : a) => (i : c) => And.intro a b h (Iff.mpr b c (f0 h) i)))
def Function.comp := (s0 : Sort(u)) => (s1 : Sort(v)) => (s2 : Sort(w)) => (f0 : s1 -> s2) => (f1 : s0 -> s1) => (a : s0) => f0 (f1 a)
thm Iff.trans : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff a b -> Iff b c -> Iff a c
  (a : Prop) => (b : Prop) => (c : Prop) => (d : Iff a b) => (e : Iff b c) => Iff.intro a c (Function.comp a b c (Iff.mp b c e) (Iff.mp a b d)) (Function.comp c b a (Iff.mpr a b d) (Iff.mpr b c e))
def And.symm.match_1 := (a : Prop) => (b : Prop) => (f0 : And a b -> Prop) => (c : And a b) => (f1 : (d : a) -> (e : b) -> f0 (And.intro a b d e)) => And.casesOn a b ((f : And a b) => f0 f) c ((g : a) => (h : b) => f1 g h)
thm And.symm : (a : Prop) -> (b : Prop) -> And a b -> And b a
  (a : Prop) => (b : Prop) => (c : And a b) => And.symm.match_1 a b (And a b => And b a) c ((d : a) => (e : b) => And.intro b a e d)
thm And.comm : (a : Prop) -> (b : Prop) -> Iff (And a b) (And b a)
  (a : Prop) => (b : Prop) => Iff.intro (And a b) (And b a) (And.symm a b) (And.symm b a)
thm and_comm : (a : Prop) -> (b : Prop) -> Iff (And a b) (And b a)
  (a : Prop) => (b : Prop) => And.comm a b
thm and_congr_left : (a : Prop) -> (b : Prop) -> (c : Prop) -> (a -> Iff b c) -> Iff (And b a) (And c a)
  (a : Prop) => (b : Prop) => (c : Prop) => (f0 : a -> Iff b c) => Iff.trans (And b a) (And a b) (And c a) (and_comm b a) (Iff.trans (And a b) (And a c) (And c a) (and_congr_right a b c f0) (and_comm a c))
def and_assoc.match_1 := (a : Prop) => (b : Prop) => (c : Prop) => (f0 : And (And a b) c -> Prop) => (d : And (And a b) c) => (f1 : (e : a) -> (f : b) -> (g : c) -> f0 (And.intro (And a b) c (And.intro a b e f) g)) => And.casesOn (And a b) c ((h : And (And a b) c) => f0 h) d ((i : And a b) => (j : c) => And.casesOn a b ((k : And a b) => f0 (And.intro (And a b) c k j)) i ((l : a) => (m : b) => f1 l m j))
def and_assoc.match_2 := (a : Prop) => (b : Prop) => (c : Prop) => (f0 : And a (And b c) -> Prop) => (d : And a (And b c)) => (f1 : (e : a) -> (f : b) -> (g : c) -> f0 (And.intro a (And b c) e (And.intro b c f g))) => And.casesOn a (And b c) ((h : And a (And b c)) => f0 h) d ((i : a) => (j : And b c) => And.casesOn b c ((k : And b c) => f0 (And.intro a (And b c) i k)) j ((l : b) => (m : c) => f1 i l m))
thm and_assoc : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff (And (And a b) c) (And a (And b c))
  (a : Prop) => (b : Prop) => (c : Prop) => Iff.intro (And (And a b) c) (And a (And b c)) ((d : And (And a b) c) => and_assoc.match_1 a b c (And (And a b) c => And a (And b c)) d ((e : a) => (f : b) => (g : c) => And.intro a (And b c) e (And.intro b c f g))) ((h : And a (And b c)) => and_assoc.match_2 a b c (And a (And b c) => And (And a b) c) h ((i : a) => (j : b) => (k : c) => And.intro (And a b) c (And.intro a b i j) k))
def And.left : (a : Prop) -> (b : Prop) -> And a b -> a
thm and_iff_left_of_imp : (a : Prop) -> (b : Prop) -> (a -> b) -> Iff (And a b) a
  (a : Prop) => (b : Prop) => (f0 : a -> b) => Iff.intro (And a b) a (And.left a b) ((c : a) => And.intro a b c (f0 c))
thm and_iff_right_of_imp : (a : Prop) -> (b : Prop) -> (a -> b) -> Iff (And b a) a
  (a : Prop) => (b : Prop) => (f0 : a -> b) => Iff.trans (And b a) (And a b) a (And.comm b a) (and_iff_left_of_imp a b f0)
def Or.elim.match_1 := (a : Prop) => (b : Prop) => (f0 : Or a b -> Prop) => (c : Or a b) => (f1 : (d : a) -> f0 (Or.inl a b d)) => (f2 : (e : b) -> f0 (Or.inr a b e)) => Or.casesOn a b ((f : Or a b) => f0 f) c ((g : a) => f1 g) ((h : b) => f2 h)
thm Or.elim : (a : Prop) -> (b : Prop) -> (c : Prop) -> Or a b -> (a -> c) -> (b -> c) -> c
  (a : Prop) => (b : Prop) => (c : Prop) => (d : Or a b) => (f0 : a -> c) => (f1 : b -> c) => Or.elim.match_1 a b (Or a b => c) d ((e : a) => f0 e) ((f : b) => f1 f)
thm Or.imp : (a : Prop) -> (b : Prop) -> (c : Prop) -> (d : Prop) -> (a -> b) -> (c -> d) -> Or a c -> Or b d
  (a : Prop) => (b : Prop) => (c : Prop) => (d : Prop) => (f0 : a -> b) => (f1 : c -> d) => (e : Or a c) => Or.elim a c (Or b d) e (Function.comp a b (Or b d) (Or.inl b d) f0) (Function.comp c d (Or b d) (Or.inr b d) f1)
thm Or.imp_left : (a : Prop) -> (b : Prop) -> (c : Prop) -> (a -> b) -> Or a c -> Or b c
  (a : Prop) => (b : Prop) => (c : Prop) => (f0 : a -> b) => Or.imp a b c c f0 (id c)
thm Or.imp_right : (a : Prop) -> (b : Prop) -> (c : Prop) -> (a -> b) -> Or c a -> Or c b
  (a : Prop) => (b : Prop) => (c : Prop) => (f0 : a -> b) => Or.imp c c a b (id c) f0
thm or_assoc : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff (Or (Or a b) c) (Or a (Or b c))
  (a : Prop) => (b : Prop) => (c : Prop) => Iff.intro (Or (Or a b) c) (Or a (Or b c)) ((d : Or (Or a b) c) => Or.rec (Or a b) c (Or (Or a b) c => Or a (Or b c)) (Or.imp_right b (Or b c) a (Or.inl b c)) (Function.comp c (Or b c) (Or a (Or b c)) (Or.inr a (Or b c)) (Or.inr b c)) d) ((e : Or a (Or b c)) => Or.rec a (Or b c) (Or a (Or b c) => Or (Or a b) c) (Function.comp a (Or a b) (Or (Or a b) c) (Or.inl (Or a b) c) (Or.inl a b)) (Or.imp_left b (Or a b) c (Or.inr a b)) e)
thm or_iff_right_of_imp : (a : Prop) -> (b : Prop) -> (a -> b) -> Iff (Or a b) b
  (a : Prop) => (b : Prop) => (f0 : a -> b) => Iff.intro (Or a b) b ((c : Or a b) => Or.rec a b (Or a b => b) f0 (id b) c) (Or.inr a b)
thm or_iff_left_of_imp : (a : Prop) -> (b : Prop) -> (a -> b) -> Iff (Or b a) b
  (a : Prop) => (b : Prop) => (f0 : a -> b) => Iff.intro (Or b a) b ((c : Or b a) => Or.rec b a (Or b a => b) (id b) f0 c) (Or.inl b a)
def PUnit : Sort(u)
def Unit := PUnit
def PUnit.unit : PUnit
def Unit.unit := PUnit.unit
def Bool.and.match_1 := (f0 : (a : Bool) -> Sort(u_1)) => (b : Bool) => (f1 : Unit -> f0 Bool.false) => (f2 : Unit -> f0 Bool.true) => Bool.casesOn ((c : Bool) => f0 c) b (f1 Unit.unit) (f2 Unit.unit)
def Bool.and := (a : Bool) => (b : Bool) => Bool.and.match_1 ((c : Bool) => Bool) a (Unit => Bool.false) (Unit => b)
def Bool.decEq.match_1 := (f0 : (a : Bool) -> (b : Bool) -> Sort(u_1)) => (c : Bool) => (d : Bool) => (f1 : Unit -> f0 Bool.false Bool.false) => (f2 : Unit -> f0 Bool.false Bool.true) => (f3 : Unit -> f0 Bool.true Bool.false) => (f4 : Unit -> f0 Bool.true Bool.true) => Bool.casesOn ((e : Bool) => f0 e d) c (Bool.casesOn ((f : Bool) => f0 Bool.false f) d (f1 Unit.unit) (f2 Unit.unit)) (Bool.casesOn ((g : Bool) => f0 Bool.true g) d (f3 Unit.unit) (f4 Unit.unit))
def Bool.decEq := (a : Bool) => (b : Bool) => Bool.decEq.match_1 ((c : Bool) => (d : Bool) => Decidable (Eq Bool c d)) a b (Unit => Decidable.isTrue (Eq Bool Bool.false Bool.false) (rfl Bool Bool.false)) (Unit => Decidable.isFalse (Eq Bool Bool.false Bool.true) ((e : Eq Bool Bool.false Bool.true) => Bool.noConfusion False Bool.false Bool.true e)) (Unit => Decidable.isFalse (Eq Bool Bool.true Bool.false) ((f : Eq Bool Bool.true Bool.false) => Bool.noConfusion False Bool.true Bool.false f)) (Unit => Decidable.isTrue (Eq Bool Bool.true Bool.true) (rfl Bool Bool.true))
def instDecidableEqBool := Bool.decEq
thm Bool.and_assoc : (a : Bool) -> (b : Bool) -> (c : Bool) -> Eq Bool (Bool.and (Bool.and a b) c) (Bool.and a (Bool.and b c))
  (a : Bool) => (b : Bool) => (c : Bool) => Bool.casesOn ((d : Bool) => (Eq Bool a d -> Eq Bool (Bool.and (Bool.and a b) c) (Bool.and a (Bool.and b c)))) a ((e : Eq Bool a Bool.false) => Eq.ndrec Bool Bool.false ((f : Bool) => Eq Bool (Bool.and (Bool.and f b) c) (Bool.and f (Bool.and b c))) (Bool.casesOn ((g : Bool) => (Eq Bool b g -> Eq Bool (Bool.and (Bool.and Bool.false b) c) (Bool.and Bool.false (Bool.and b c)))) b ((h : Eq Bool b Bool.false) => Eq.ndrec Bool Bool.false ((i : Bool) => Eq Bool (Bool.and (Bool.and Bool.false i) c) (Bool.and Bool.false (Bool.and i c))) (Bool.casesOn ((j : Bool) => (Eq Bool c j -> Eq Bool (Bool.and (Bool.and Bool.false Bool.false) c) (Bool.and Bool.false (Bool.and Bool.false c)))) c ((k : Eq Bool c Bool.false) => Eq.ndrec Bool Bool.false ((l : Bool) => Eq Bool (Bool.and (Bool.and Bool.false Bool.false) l) (Bool.and Bool.false (Bool.and Bool.false l))) (of_decide_eq_true (Eq Bool (Bool.and (Bool.and Bool.false Bool.false) Bool.false) (Bool.and Bool.false (Bool.and Bool.false Bool.false))) (instDecidableEqBool (Bool.and (Bool.and Bool.false Bool.false) Bool.false) (Bool.and Bool.false (Bool.and Bool.false Bool.false))) (id (Eq Bool (Decidable.decide (Eq Bool (Bool.and (Bool.and Bool.false Bool.false) Bool.false) (Bool.and Bool.false (Bool.and Bool.false Bool.false))) (instDecidableEqBool (Bool.and (Bool.and Bool.false Bool.false) Bool.false) (Bool.and Bool.false (Bool.and Bool.false Bool.false)))) Bool.true) (Eq.refl Bool Bool.true))) c (Eq.symm Bool c Bool.false k)) ((m : Eq Bool c Bool.true) => Eq.ndrec Bool Bool.true ((n : Bool) => Eq Bool (Bool.and (Bool.and Bool.false Bool.false) n) (Bool.and Bool.false (Bool.and Bool.false n))) (of_decide_eq_true (Eq Bool (Bool.and (Bool.and Bool.false Bool.false) Bool.true) (Bool.and Bool.false (Bool.and Bool.false Bool.true))) (instDecidableEqBool (Bool.and (Bool.and Bool.false Bool.false) Bool.true) (Bool.and Bool.false (Bool.and Bool.false Bool.true))) (id (Eq Bool (Decidable.decide (Eq Bool (Bool.and (Bool.and Bool.false Bool.false) Bool.true) (Bool.and Bool.false (Bool.and Bool.false Bool.true))) (instDecidableEqBool (Bool.and (Bool.and Bool.false Bool.false) Bool.true) (Bool.and Bool.false (Bool.and Bool.false Bool.true)))) Bool.true) (Eq.refl Bool Bool.true))) c (Eq.symm Bool c Bool.true m)) (Eq.refl Bool c)) b (Eq.symm Bool b Bool.false h)) ((o : Eq Bool b Bool.true) => Eq.ndrec Bool Bool.true ((p : Bool) => Eq Bool (Bool.and (Bool.and Bool.false p) c) (Bool.and Bool.false (Bool.and p c))) (Bool.casesOn ((q : Bool) => (Eq Bool c q -> Eq Bool (Bool.and (Bool.and Bool.false Bool.true) c) (Bool.and Bool.false (Bool.and Bool.true c)))) c ((r : Eq Bool c Bool.false) => Eq.ndrec Bool Bool.false ((s : Bool) => Eq Bool (Bool.and (Bool.and Bool.false Bool.true) s) (Bool.and Bool.false (Bool.and Bool.true s))) (of_decide_eq_true (Eq Bool (Bool.and (Bool.and Bool.false Bool.true) Bool.false) (Bool.and Bool.false (Bool.and Bool.true Bool.false))) (instDecidableEqBool (Bool.and (Bool.and Bool.false Bool.true) Bool.false) (Bool.and Bool.false (Bool.and Bool.true Bool.false))) (id (Eq Bool (Decidable.decide (Eq Bool (Bool.and (Bool.and Bool.false Bool.true) Bool.false) (Bool.and Bool.false (Bool.and Bool.true Bool.false))) (instDecidableEqBool (Bool.and (Bool.and Bool.false Bool.true) Bool.false) (Bool.and Bool.false (Bool.and Bool.true Bool.false)))) Bool.true) (Eq.refl Bool Bool.true))) c (Eq.symm Bool c Bool.false r)) ((t : Eq Bool c Bool.true) => Eq.ndrec Bool Bool.true ((u : Bool) => Eq Bool (Bool.and (Bool.and Bool.false Bool.true) u) (Bool.and Bool.false (Bool.and Bool.true u))) (of_decide_eq_true (Eq Bool (Bool.and (Bool.and Bool.false Bool.true) Bool.true) (Bool.and Bool.false (Bool.and Bool.true Bool.true))) (instDecidableEqBool (Bool.and (Bool.and Bool.false Bool.true) Bool.true) (Bool.and Bool.false (Bool.and Bool.true Bool.true))) (id (Eq Bool (Decidable.decide (Eq Bool (Bool.and (Bool.and Bool.false Bool.true) Bool.true) (Bool.and Bool.false (Bool.and Bool.true Bool.true))) (instDecidableEqBool (Bool.and (Bool.and Bool.false Bool.true) Bool.true) (Bool.and Bool.false (Bool.and Bool.true Bool.true)))) Bool.true) (Eq.refl Bool Bool.true))) c (Eq.symm Bool c Bool.true t)) (Eq.refl Bool c)) b (Eq.symm Bool b Bool.true o)) (Eq.refl Bool b)) a (Eq.symm Bool a Bool.false e)) ((v : Eq Bool a Bool.true) => Eq.ndrec Bool Bool.true ((w : Bool) => Eq Bool (Bool.and (Bool.and w b) c) (Bool.and w (Bool.and b c))) (Bool.casesOn ((x : Bool) => (Eq Bool b x -> Eq Bool (Bool.and (Bool.and Bool.true b) c) (Bool.and Bool.true (Bool.and b c)))) b ((y : Eq Bool b Bool.false) => Eq.ndrec Bool Bool.false ((z : Bool) => Eq Bool (Bool.and (Bool.and Bool.true z) c) (Bool.and Bool.true (Bool.and z c))) (Bool.casesOn ((A : Bool) => (Eq Bool c A -> Eq Bool (Bool.and (Bool.and Bool.true Bool.false) c) (Bool.and Bool.true (Bool.and Bool.false c)))) c ((B : Eq Bool c Bool.false) => Eq.ndrec Bool Bool.false ((C : Bool) => Eq Bool (Bool.and (Bool.and Bool.true Bool.false) C) (Bool.and Bool.true (Bool.and Bool.false C))) (of_decide_eq_true (Eq Bool (Bool.and (Bool.and Bool.true Bool.false) Bool.false) (Bool.and Bool.true (Bool.and Bool.false Bool.false))) (instDecidableEqBool (Bool.and (Bool.and Bool.true Bool.false) Bool.false) (Bool.and Bool.true (Bool.and Bool.false Bool.false))) (id (Eq Bool (Decidable.decide (Eq Bool (Bool.and (Bool.and Bool.true Bool.false) Bool.false) (Bool.and Bool.true (Bool.and Bool.false Bool.false))) (instDecidableEqBool (Bool.and (Bool.and Bool.true Bool.false) Bool.false) (Bool.and Bool.true (Bool.and Bool.false Bool.false)))) Bool.true) (Eq.refl Bool Bool.true))) c (Eq.symm Bool c Bool.false B)) ((D : Eq Bool c Bool.true) => Eq.ndrec Bool Bool.true ((E : Bool) => Eq Bool (Bool.and (Bool.and Bool.true Bool.false) E) (Bool.and Bool.true (Bool.and Bool.false E))) (of_decide_eq_true (Eq Bool (Bool.and (Bool.and Bool.true Bool.false) Bool.true) (Bool.and Bool.true (Bool.and Bool.false Bool.true))) (instDecidableEqBool (Bool.and (Bool.and Bool.true Bool.false) Bool.true) (Bool.and Bool.true (Bool.and Bool.false Bool.true))) (id (Eq Bool (Decidable.decide (Eq Bool (Bool.and (Bool.and Bool.true Bool.false) Bool.true) (Bool.and Bool.true (Bool.and Bool.false Bool.true))) (instDecidableEqBool (Bool.and (Bool.and Bool.true Bool.false) Bool.true) (Bool.and Bool.true (Bool.and Bool.false Bool.true)))) Bool.true) (Eq.refl Bool Bool.true))) c (Eq.symm Bool c Bool.true D)) (Eq.refl Bool c)) b (Eq.symm Bool b Bool.false y)) ((F : Eq Bool b Bool.true) => Eq.ndrec Bool Bool.true ((G : Bool) => Eq Bool (Bool.and (Bool.and Bool.true G) c) (Bool.and Bool.true (Bool.and G c))) (Bool.casesOn ((H : Bool) => (Eq Bool c H -> Eq Bool (Bool.and (Bool.and Bool.true Bool.true) c) (Bool.and Bool.true (Bool.and Bool.true c)))) c ((I : Eq Bool c Bool.false) => Eq.ndrec Bool Bool.false ((J : Bool) => Eq Bool (Bool.and (Bool.and Bool.true Bool.true) J) (Bool.and Bool.true (Bool.and Bool.true J))) (of_decide_eq_true (Eq Bool (Bool.and (Bool.and Bool.true Bool.true) Bool.false) (Bool.and Bool.true (Bool.and Bool.true Bool.false))) (instDecidableEqBool (Bool.and (Bool.and Bool.true Bool.true) Bool.false) (Bool.and Bool.true (Bool.and Bool.true Bool.false))) (id (Eq Bool (Decidable.decide (Eq Bool (Bool.and (Bool.and Bool.true Bool.true) Bool.false) (Bool.and Bool.true (Bool.and Bool.true Bool.false))) (instDecidableEqBool (Bool.and (Bool.and Bool.true Bool.true) Bool.false) (Bool.and Bool.true (Bool.and Bool.true Bool.false)))) Bool.true) (Eq.refl Bool Bool.true))) c (Eq.symm Bool c Bool.false I)) ((K : Eq Bool c Bool.true) => Eq.ndrec Bool Bool.true ((L : Bool) => Eq Bool (Bool.and (Bool.and Bool.true Bool.true) L) (Bool.and Bool.true (Bool.and Bool.true L))) (of_decide_eq_true (Eq Bool (Bool.and (Bool.and Bool.true Bool.true) Bool.true) (Bool.and Bool.true (Bool.and Bool.true Bool.true))) (instDecidableEqBool (Bool.and (Bool.and Bool.true Bool.true) Bool.true) (Bool.and Bool.true (Bool.and Bool.true Bool.true))) (id (Eq Bool (Decidable.decide (Eq Bool (Bool.and (Bool.and Bool.true Bool.true) Bool.true) (Bool.and Bool.true (Bool.and Bool.true Bool.true))) (instDecidableEqBool (Bool.and (Bool.and Bool.true Bool.true) Bool.true) (Bool.and Bool.true (Bool.and Bool.true Bool.true)))) Bool.true) (Eq.refl Bool Bool.true))) c (Eq.symm Bool c Bool.true K)) (Eq.refl Bool c)) b (Eq.symm Bool b Bool.true F)) (Eq.refl Bool b)) a (Eq.symm Bool a Bool.true v)) (Eq.refl Bool a)
def cond.match_1 := (f0 : (a : Bool) -> Sort(u_1)) => (b : Bool) => (f1 : Unit -> f0 Bool.true) => (f2 : Unit -> f0 Bool.false) => Bool.casesOn ((c : Bool) => f0 c) b (f2 Unit.unit) (f1 Unit.unit)
def Bool.or := (a : Bool) => (b : Bool) => cond.match_1 ((c : Bool) => Bool) a (Unit => Bool.true) (Unit => b)
thm Bool.or_assoc : (a : Bool) -> (b : Bool) -> (c : Bool) -> Eq Bool (Bool.or (Bool.or a b) c) (Bool.or a (Bool.or b c))
  (a : Bool) => (b : Bool) => (c : Bool) => Bool.casesOn ((d : Bool) => (Eq Bool a d -> Eq Bool (Bool.or (Bool.or a b) c) (Bool.or a (Bool.or b c)))) a ((e : Eq Bool a Bool.false) => Eq.ndrec Bool Bool.false ((f : Bool) => Eq Bool (Bool.or (Bool.or f b) c) (Bool.or f (Bool.or b c))) (Bool.casesOn ((g : Bool) => (Eq Bool b g -> Eq Bool (Bool.or (Bool.or Bool.false b) c) (Bool.or Bool.false (Bool.or b c)))) b ((h : Eq Bool b Bool.false) => Eq.ndrec Bool Bool.false ((i : Bool) => Eq Bool (Bool.or (Bool.or Bool.false i) c) (Bool.or Bool.false (Bool.or i c))) (Bool.casesOn ((j : Bool) => (Eq Bool c j -> Eq Bool (Bool.or (Bool.or Bool.false Bool.false) c) (Bool.or Bool.false (Bool.or Bool.false c)))) c ((k : Eq Bool c Bool.false) => Eq.ndrec Bool Bool.false ((l : Bool) => Eq Bool (Bool.or (Bool.or Bool.false Bool.false) l) (Bool.or Bool.false (Bool.or Bool.false l))) (of_decide_eq_true (Eq Bool (Bool.or (Bool.or Bool.false Bool.false) Bool.false) (Bool.or Bool.false (Bool.or Bool.false Bool.false))) (instDecidableEqBool (Bool.or (Bool.or Bool.false Bool.false) Bool.false) (Bool.or Bool.false (Bool.or Bool.false Bool.false))) (id (Eq Bool (Decidable.decide (Eq Bool (Bool.or (Bool.or Bool.false Bool.false) Bool.false) (Bool.or Bool.false (Bool.or Bool.false Bool.false))) (instDecidableEqBool (Bool.or (Bool.or Bool.false Bool.false) Bool.false) (Bool.or Bool.false (Bool.or Bool.false Bool.false)))) Bool.true) (Eq.refl Bool Bool.true))) c (Eq.symm Bool c Bool.false k)) ((m : Eq Bool c Bool.true) => Eq.ndrec Bool Bool.true ((n : Bool) => Eq Bool (Bool.or (Bool.or Bool.false Bool.false) n) (Bool.or Bool.false (Bool.or Bool.false n))) (of_decide_eq_true (Eq Bool (Bool.or (Bool.or Bool.false Bool.false) Bool.true) (Bool.or Bool.false (Bool.or Bool.false Bool.true))) (instDecidableEqBool (Bool.or (Bool.or Bool.false Bool.false) Bool.true) (Bool.or Bool.false (Bool.or Bool.false Bool.true))) (id (Eq Bool (Decidable.decide (Eq Bool (Bool.or (Bool.or Bool.false Bool.false) Bool.true) (Bool.or Bool.false (Bool.or Bool.false Bool.true))) (instDecidableEqBool (Bool.or (Bool.or Bool.false Bool.false) Bool.true) (Bool.or Bool.false (Bool.or Bool.false Bool.true)))) Bool.true) (Eq.refl Bool Bool.true))) c (Eq.symm Bool c Bool.true m)) (Eq.refl Bool c)) b (Eq.symm Bool b Bool.false h)) ((o : Eq Bool b Bool.true) => Eq.ndrec Bool Bool.true ((p : Bool) => Eq Bool (Bool.or (Bool.or Bool.false p) c) (Bool.or Bool.false (Bool.or p c))) (Bool.casesOn ((q : Bool) => (Eq Bool c q -> Eq Bool (Bool.or (Bool.or Bool.false Bool.true) c) (Bool.or Bool.false (Bool.or Bool.true c)))) c ((r : Eq Bool c Bool.false) => Eq.ndrec Bool Bool.false ((s : Bool) => Eq Bool (Bool.or (Bool.or Bool.false Bool.true) s) (Bool.or Bool.false (Bool.or Bool.true s))) (of_decide_eq_true (Eq Bool (Bool.or (Bool.or Bool.false Bool.true) Bool.false) (Bool.or Bool.false (Bool.or Bool.true Bool.false))) (instDecidableEqBool (Bool.or (Bool.or Bool.false Bool.true) Bool.false) (Bool.or Bool.false (Bool.or Bool.true Bool.false))) (id (Eq Bool (Decidable.decide (Eq Bool (Bool.or (Bool.or Bool.false Bool.true) Bool.false) (Bool.or Bool.false (Bool.or Bool.true Bool.false))) (instDecidableEqBool (Bool.or (Bool.or Bool.false Bool.true) Bool.false) (Bool.or Bool.false (Bool.or Bool.true Bool.false)))) Bool.true) (Eq.refl Bool Bool.true))) c (Eq.symm Bool c Bool.false r)) ((t : Eq Bool c Bool.true) => Eq.ndrec Bool Bool.true ((u : Bool) => Eq Bool (Bool.or (Bool.or Bool.false Bool.true) u) (Bool.or Bool.false (Bool.or Bool.true u))) (of_decide_eq_true (Eq Bool (Bool.or (Bool.or Bool.false Bool.true) Bool.true) (Bool.or Bool.false (Bool.or Bool.true Bool.true))) (instDecidableEqBool (Bool.or (Bool.or Bool.false Bool.true) Bool.true) (Bool.or Bool.false (Bool.or Bool.true Bool.true))) (id (Eq Bool (Decidable.decide (Eq Bool (Bool.or (Bool.or Bool.false Bool.true) Bool.true) (Bool.or Bool.false (Bool.or Bool.true Bool.true))) (instDecidableEqBool (Bool.or (Bool.or Bool.false Bool.true) Bool.true) (Bool.or Bool.false (Bool.or Bool.true Bool.true)))) Bool.true) (Eq.refl Bool Bool.true))) c (Eq.symm Bool c Bool.true t)) (Eq.refl Bool c)) b (Eq.symm Bool b Bool.true o)) (Eq.refl Bool b)) a (Eq.symm Bool a Bool.false e)) ((v : Eq Bool a Bool.true) => Eq.ndrec Bool Bool.true ((w : Bool) => Eq Bool (Bool.or (Bool.or w b) c) (Bool.or w (Bool.or b c))) (Bool.casesOn ((x : Bool) => (Eq Bool b x -> Eq Bool (Bool.or (Bool.or Bool.true b) c) (Bool.or Bool.true (Bool.or b c)))) b ((y : Eq Bool b Bool.false) => Eq.ndrec Bool Bool.false ((z : Bool) => Eq Bool (Bool.or (Bool.or Bool.true z) c) (Bool.or Bool.true (Bool.or z c))) (Bool.casesOn ((A : Bool) => (Eq Bool c A -> Eq Bool (Bool.or (Bool.or Bool.true Bool.false) c) (Bool.or Bool.true (Bool.or Bool.false c)))) c ((B : Eq Bool c Bool.false) => Eq.ndrec Bool Bool.false ((C : Bool) => Eq Bool (Bool.or (Bool.or Bool.true Bool.false) C) (Bool.or Bool.true (Bool.or Bool.false C))) (of_decide_eq_true (Eq Bool (Bool.or (Bool.or Bool.true Bool.false) Bool.false) (Bool.or Bool.true (Bool.or Bool.false Bool.false))) (instDecidableEqBool (Bool.or (Bool.or Bool.true Bool.false) Bool.false) (Bool.or Bool.true (Bool.or Bool.false Bool.false))) (id (Eq Bool (Decidable.decide (Eq Bool (Bool.or (Bool.or Bool.true Bool.false) Bool.false) (Bool.or Bool.true (Bool.or Bool.false Bool.false))) (instDecidableEqBool (Bool.or (Bool.or Bool.true Bool.false) Bool.false) (Bool.or Bool.true (Bool.or Bool.false Bool.false)))) Bool.true) (Eq.refl Bool Bool.true))) c (Eq.symm Bool c Bool.false B)) ((D : Eq Bool c Bool.true) => Eq.ndrec Bool Bool.true ((E : Bool) => Eq Bool (Bool.or (Bool.or Bool.true Bool.false) E) (Bool.or Bool.true (Bool.or Bool.false E))) (of_decide_eq_true (Eq Bool (Bool.or (Bool.or Bool.true Bool.false) Bool.true) (Bool.or Bool.true (Bool.or Bool.false Bool.true))) (instDecidableEqBool (Bool.or (Bool.or Bool.true Bool.false) Bool.true) (Bool.or Bool.true (Bool.or Bool.false Bool.true))) (id (Eq Bool (Decidable.decide (Eq Bool (Bool.or (Bool.or Bool.true Bool.false) Bool.true) (Bool.or Bool.true (Bool.or Bool.false Bool.true))) (instDecidableEqBool (Bool.or (Bool.or Bool.true Bool.false) Bool.true) (Bool.or Bool.true (Bool.or Bool.false Bool.true)))) Bool.true) (Eq.refl Bool Bool.true))) c (Eq.symm Bool c Bool.true D)) (Eq.refl Bool c)) b (Eq.symm Bool b Bool.false y)) ((F : Eq Bool b Bool.true) => Eq.ndrec Bool Bool.true ((G : Bool) => Eq Bool (Bool.or (Bool.or Bool.true G) c) (Bool.or Bool.true (Bool.or G c))) (Bool.casesOn ((H : Bool) => (Eq Bool c H -> Eq Bool (Bool.or (Bool.or Bool.true Bool.true) c) (Bool.or Bool.true (Bool.or Bool.true c)))) c ((I : Eq Bool c Bool.false) => Eq.ndrec Bool Bool.false ((J : Bool) => Eq Bool (Bool.or (Bool.or Bool.true Bool.true) J) (Bool.or Bool.true (Bool.or Bool.true J))) (of_decide_eq_true (Eq Bool (Bool.or (Bool.or Bool.true Bool.true) Bool.false) (Bool.or Bool.true (Bool.or Bool.true Bool.false))) (instDecidableEqBool (Bool.or (Bool.or Bool.true Bool.true) Bool.false) (Bool.or Bool.true (Bool.or Bool.true Bool.false))) (id (Eq Bool (Decidable.decide (Eq Bool (Bool.or (Bool.or Bool.true Bool.true) Bool.false) (Bool.or Bool.true (Bool.or Bool.true Bool.false))) (instDecidableEqBool (Bool.or (Bool.or Bool.true Bool.true) Bool.false) (Bool.or Bool.true (Bool.or Bool.true Bool.false)))) Bool.true) (Eq.refl Bool Bool.true))) c (Eq.symm Bool c Bool.false I)) ((K : Eq Bool c Bool.true) => Eq.ndrec Bool Bool.true ((L : Bool) => Eq Bool (Bool.or (Bool.or Bool.true Bool.true) L) (Bool.or Bool.true (Bool.or Bool.true L))) (of_decide_eq_true (Eq Bool (Bool.or (Bool.or Bool.true Bool.true) Bool.true) (Bool.or Bool.true (Bool.or Bool.true Bool.true))) (instDecidableEqBool (Bool.or (Bool.or Bool.true Bool.true) Bool.true) (Bool.or Bool.true (Bool.or Bool.true Bool.true))) (id (Eq Bool (Decidable.decide (Eq Bool (Bool.or (Bool.or Bool.true Bool.true) Bool.true) (Bool.or Bool.true (Bool.or Bool.true Bool.true))) (instDecidableEqBool (Bool.or (Bool.or Bool.true Bool.true) Bool.true) (Bool.or Bool.true (Bool.or Bool.true Bool.true)))) Bool.true) (Eq.refl Bool Bool.true))) c (Eq.symm Bool c Bool.true K)) (Eq.refl Bool c)) b (Eq.symm Bool b Bool.true F)) (Eq.refl Bool b)) a (Eq.symm Bool a Bool.true v)) (Eq.refl Bool a)
def Bool.not := (a : Bool) => cond.match_1 ((b : Bool) => Bool) a (Unit => Bool.false) (Unit => Bool.true)
thm congr : (s0 : Sort(u)) -> (s1 : Sort(v)) -> (f0 : s0 -> s1) -> (f1 : s0 -> s1) -> (a : s0) -> (b : s0) -> Eq (s0 -> s1) f0 f1 -> Eq s0 a b -> Eq s1 (f0 a) (f1 b)
  (s0 : Sort(u)) => (s1 : Sort(v)) => (f0 : s0 -> s1) => (f1 : s0 -> s1) => (a : s0) => (b : s0) => (c : Eq (s0 -> s1) f0 f1) => (d : Eq s0 a b) => Eq.rec ((e : s0) -> s1) f0 ((f2 : (f : s0) -> s1) => Eq (s0 -> s1) f0 f2 => Eq s1 (f0 a) (f2 b)) (Eq.rec s0 a ((g : s0) => Eq s0 a g => Eq s1 (f0 a) (f0 g)) (rfl s1 (f0 a)) b d) f1 c
thm Bool.not_false : Eq Bool (Bool.not Bool.false) Bool.true
  of_decide_eq_true (Eq Bool (Bool.not Bool.false) Bool.true) (instDecidableEqBool (Bool.not Bool.false) Bool.true) (id (Eq Bool (Decidable.decide (Eq Bool (Bool.not Bool.false) Bool.true) (instDecidableEqBool (Bool.not Bool.false) Bool.true)) Bool.true) (Eq.refl Bool Bool.true))
thm iff_self : (a : Prop) -> Eq Prop (Iff a a) True
  (a : Prop) => eq_true (Iff a a) (Iff.rfl a)
thm Bool.not_true : Eq Bool (Bool.not Bool.true) Bool.false
  of_decide_eq_true (Eq Bool (Bool.not Bool.true) Bool.false) (instDecidableEqBool (Bool.not Bool.true) Bool.false) (id (Eq Bool (Decidable.decide (Eq Bool (Bool.not Bool.true) Bool.false) (instDecidableEqBool (Bool.not Bool.true) Bool.false)) Bool.true) (Eq.refl Bool Bool.true))
thm Bool.not_eq_eq_eq_not : (a : Bool) -> (b : Bool) -> Iff (Eq Bool (Bool.not a) b) (Eq Bool a (Bool.not b))
  (a : Bool) => (b : Bool) => Bool.casesOn ((c : Bool) => (Eq Bool a c -> Iff (Eq Bool (Bool.not a) b) (Eq Bool a (Bool.not b)))) a ((d : Eq Bool a Bool.false) => Eq.ndrec Bool Bool.false ((e : Bool) => Iff (Eq Bool (Bool.not e) b) (Eq Bool e (Bool.not b))) (Bool.casesOn ((f : Bool) => (Eq Bool b f -> Iff (Eq Bool (Bool.not Bool.false) b) (Eq Bool Bool.false (Bool.not b)))) b ((g : Eq Bool b Bool.false) => Eq.ndrec Bool Bool.false ((h : Bool) => Iff (Eq Bool (Bool.not Bool.false) h) (Eq Bool Bool.false (Bool.not h))) (of_eq_true (Iff (Eq Bool (Bool.not Bool.false) Bool.false) (Eq Bool Bool.false (Bool.not Bool.false))) (Eq.trans Prop (Iff (Eq Bool (Bool.not Bool.false) Bool.false) (Eq Bool Bool.false (Bool.not Bool.false))) (Iff False False) True (congr Prop Prop (Iff (Eq Bool (Bool.not Bool.false) Bool.false)) (Iff False) (Eq Bool Bool.false (Bool.not Bool.false)) False (congrArg Prop (Prop -> Prop) (Eq Bool (Bool.not Bool.false) Bool.false) False Iff (Eq.trans Prop (Eq Bool (Bool.not Bool.false) Bool.false) (Eq Bool Bool.true Bool.false) False (congrArg Bool Prop (Bool.not Bool.false) Bool.true ((i : Bool) => Eq Bool i Bool.false) Bool.not_false) (eq_false' (Eq Bool Bool.true Bool.false) ((j : Eq Bool Bool.true Bool.false) => Bool.noConfusion False Bool.true Bool.false j)))) (Eq.trans Prop (Eq Bool Bool.false (Bool.not Bool.false)) (Eq Bool Bool.false Bool.true) False (congrArg Bool Prop (Bool.not Bool.false) Bool.true (Eq Bool Bool.false) Bool.not_false) (eq_false' (Eq Bool Bool.false Bool.true) ((k : Eq Bool Bool.false Bool.true) => Bool.noConfusion False Bool.false Bool.true k)))) (iff_self False))) b (Eq.symm Bool b Bool.false g)) ((l : Eq Bool b Bool.true) => Eq.ndrec Bool Bool.true ((m : Bool) => Iff (Eq Bool (Bool.not Bool.false) m) (Eq Bool Bool.false (Bool.not m))) (of_eq_true (Iff (Eq Bool (Bool.not Bool.false) Bool.true) (Eq Bool Bool.false (Bool.not Bool.true))) (Eq.trans Prop (Iff (Eq Bool (Bool.not Bool.false) Bool.true) (Eq Bool Bool.false (Bool.not Bool.true))) (Iff True True) True (congr Prop Prop (Iff (Eq Bool (Bool.not Bool.false) Bool.true)) (Iff True) (Eq Bool Bool.false (Bool.not Bool.true)) True (congrArg Prop (Prop -> Prop) (Eq Bool (Bool.not Bool.false) Bool.true) True Iff (Eq.trans Prop (Eq Bool (Bool.not Bool.false) Bool.true) (Eq Bool Bool.true Bool.true) True (congrArg Bool Prop (Bool.not Bool.false) Bool.true ((n : Bool) => Eq Bool n Bool.true) Bool.not_false) (eq_self Bool Bool.true))) (Eq.trans Prop (Eq Bool Bool.false (Bool.not Bool.true)) (Eq Bool Bool.false Bool.false) True (congrArg Bool Prop (Bool.not Bool.true) Bool.false (Eq Bool Bool.false) Bool.not_true) (eq_self Bool Bool.false))) (iff_self True))) b (Eq.symm Bool b Bool.true l)) (Eq.refl Bool b)) a (Eq.symm Bool a Bool.false d)) ((o : Eq Bool a Bool.true) => Eq.ndrec Bool Bool.true ((p : Bool) => Iff (Eq Bool (Bool.not p) b) (Eq Bool p (Bool.not b))) (Bool.casesOn ((q : Bool) => (Eq Bool b q -> Iff (Eq Bool (Bool.not Bool.true) b) (Eq Bool Bool.true (Bool.not b)))) b ((r : Eq Bool b Bool.false) => Eq.ndrec Bool Bool.false ((s : Bool) => Iff (Eq Bool (Bool.not Bool.true) s) (Eq Bool Bool.true (Bool.not s))) (of_eq_true (Iff (Eq Bool (Bool.not Bool.true) Bool.false) (Eq Bool Bool.true (Bool.not Bool.false))) (Eq.trans Prop (Iff (Eq Bool (Bool.not Bool.true) Bool.false) (Eq Bool Bool.true (Bool.not Bool.false))) (Iff True True) True (congr Prop Prop (Iff (Eq Bool (Bool.not Bool.true) Bool.false)) (Iff True) (Eq Bool Bool.true (Bool.not Bool.false)) True (congrArg Prop (Prop -> Prop) (Eq Bool (Bool.not Bool.true) Bool.false) True Iff (Eq.trans Prop (Eq Bool (Bool.not Bool.true) Bool.false) (Eq Bool Bool.false Bool.false) True (congrArg Bool Prop (Bool.not Bool.true) Bool.false ((t : Bool) => Eq Bool t Bool.false) Bool.not_true) (eq_self Bool Bool.false))) (Eq.trans Prop (Eq Bool Bool.true (Bool.not Bool.false)) (Eq Bool Bool.true Bool.true) True (congrArg Bool Prop (Bool.not Bool.false) Bool.true (Eq Bool Bool.true) Bool.not_false) (eq_self Bool Bool.true))) (iff_self True))) b (Eq.symm Bool b Bool.false r)) ((u : Eq Bool b Bool.true) => Eq.ndrec Bool Bool.true ((v : Bool) => Iff (Eq Bool (Bool.not Bool.true) v) (Eq Bool Bool.true (Bool.not v))) (of_eq_true (Iff (Eq Bool (Bool.not Bool.true) Bool.true) (Eq Bool Bool.true (Bool.not Bool.true))) (Eq.trans Prop (Iff (Eq Bool (Bool.not Bool.true) Bool.true) (Eq Bool Bool.true (Bool.not Bool.true))) (Iff False False) True (congr Prop Prop (Iff (Eq Bool (Bool.not Bool.true) Bool.true)) (Iff False) (Eq Bool Bool.true (Bool.not Bool.true)) False (congrArg Prop (Prop -> Prop) (Eq Bool (Bool.not Bool.true) Bool.true) False Iff (Eq.trans Prop (Eq Bool (Bool.not Bool.true) Bool.true) (Eq Bool Bool.false Bool.true) False (congrArg Bool Prop (Bool.not Bool.true) Bool.false ((w : Bool) => Eq Bool w Bool.true) Bool.not_true) (eq_false' (Eq Bool Bool.false Bool.true) ((x : Eq Bool Bool.false Bool.true) => Bool.noConfusion False Bool.false Bool.true x)))) (Eq.trans Prop (Eq Bool Bool.true (Bool.not Bool.true)) (Eq Bool Bool.true Bool.false) False (congrArg Bool Prop (Bool.not Bool.true) Bool.false (Eq Bool Bool.true) Bool.not_true) (eq_false' (Eq Bool Bool.true Bool.false) ((y : Eq Bool Bool.true Bool.false) => Bool.noConfusion False Bool.true Bool.false y)))) (iff_self False))) b (Eq.symm Bool b Bool.true u)) (Eq.refl Bool b)) a (Eq.symm Bool a Bool.true o)) (Eq.refl Bool a)
thm Init.SimpLemmas._auxLemma.22 : (a : Bool) -> (b : Bool) -> Eq Prop (Eq Bool (Bool.not a) b) (Eq Bool a (Bool.not b))
  (a : Bool) => (b : Bool) => propext (Eq Bool (Bool.not a) b) (Eq Bool a (Bool.not b)) (Bool.not_eq_eq_eq_not a b)
thm not_false_eq_true : Eq Prop (Not False) True
  eq_true (Not False) (False.elim False)
def instDecidableEqOfIff.match_1 := (a : Prop) => (b : Prop) => (f0 : Decidable (Iff a b) -> Sort(u_1)) => (c : Decidable (Iff a b)) => (f1 : (d : Iff a b) -> f0 (Decidable.isTrue (Iff a b) d)) => (f2 : (e : Not (Iff a b)) -> f0 (Decidable.isFalse (Iff a b) e)) => Decidable.casesOn (Iff a b) ((f : Decidable (Iff a b)) => f0 f) c ((g : Not (Iff a b)) => f2 g) ((h : Iff a b) => f1 h)
thm instDecidableEqOfIff.proof_1 : (a : Prop) -> (b : Prop) -> Not (Iff a b) -> Eq Prop a b -> False
  (a : Prop) => (b : Prop) => (c : Not (Iff a b)) => (d : Eq Prop a b) => c (Eq.rec Prop a ((e : Prop) => Eq Prop a e => Iff a e) (Iff.rfl a) b d)
def instDecidableEqOfIff := (a : Prop) => (b : Prop) => (c : Decidable (Iff a b)) => instDecidableEqOfIff.match_1 a b (Decidable (Iff a b) => Decidable (Eq Prop a b)) c ((d : Iff a b) => Decidable.isTrue (Eq Prop a b) (propext a b d)) ((e : Not (Iff a b)) => Decidable.isFalse (Eq Prop a b) (instDecidableEqOfIff.proof_1 a b e))
thm instDecidableIff.proof_1 : (a : Prop) -> (b : Prop) -> a -> b -> Iff a b
  (a : Prop) => (b : Prop) => (c : a) => (d : b) => Iff.intro a b (a => d) (b => c)
thm instDecidableIff.proof_2 : (a : Prop) -> (b : Prop) -> a -> Not b -> Iff a b -> False
  (a : Prop) => (b : Prop) => (c : a) => (d : Not b) => (e : Iff a b) => d (Iff.mp a b e c)
thm instDecidableIff.proof_3 : (a : Prop) -> (b : Prop) -> Not a -> b -> Iff a b -> False
  (a : Prop) => (b : Prop) => (c : Not a) => (d : b) => (e : Iff a b) => c (Iff.mpr a b e d)
thm instDecidableIff.proof_4 : (a : Prop) -> (b : Prop) -> Not a -> Not b -> Iff a b
  (a : Prop) => (b : Prop) => (c : Not a) => (d : Not b) => Iff.intro a b ((e : a) => absurd a b e c) ((f : b) => absurd b a f d)
def instDecidableIff := (a : Prop) => (b : Prop) => (c : Decidable a) => (d : Decidable b) => dite (Decidable (Iff a b)) a c ((e : a) => dite (Decidable (Iff a b)) b d ((f : b) => Decidable.isTrue (Iff a b) (instDecidableIff.proof_1 a b e f)) ((g : Not b) => Decidable.isFalse (Iff a b) (instDecidableIff.proof_2 a b e g))) ((h : Not a) => dite (Decidable (Iff a b)) b d ((i : b) => Decidable.isFalse (Iff a b) (instDecidableIff.proof_3 a b h i)) ((j : Not b) => Decidable.isTrue (Iff a b) (instDecidableIff.proof_4 a b h j)))
def instDecidableAnd.match_1 := (a : Prop) => (f0 : Decidable a -> Sort(u_1)) => (b : Decidable a) => (f1 : (c : a) -> f0 (Decidable.isTrue a c)) => (f2 : (d : Not a) -> f0 (Decidable.isFalse a d)) => Decidable.casesOn a ((e : Decidable a) => f0 e) b ((f : Not a) => f2 f) ((g : a) => f1 g)
def instDecidableNot := (a : Prop) => (b : Decidable a) => instDecidableAnd.match_1 a (Decidable a => Decidable (Not a)) b ((c : a) => Decidable.isFalse (Not a) (absurd a False c)) ((d : Not a) => Decidable.isTrue (Not a) d)
thm not_true_eq_false : Eq Prop (Not True) False
  of_decide_eq_true (Eq Prop (Not True) False) (instDecidableEqOfIff (Not True) False (instDecidableIff (Not True) False (instDecidableNot True instDecidableTrue) instDecidableFalse)) (id (Eq Bool (Decidable.decide (Eq Prop (Not True) False) (instDecidableEqOfIff (Not True) False (instDecidableIff (Not True) False (instDecidableNot True instDecidableTrue) instDecidableFalse))) Bool.true) (Eq.refl Bool Bool.true))
thm Bool.not_eq_not : (a : Bool) -> (b : Bool) -> Iff (Not (Eq Bool a (Bool.not b))) (Eq Bool a b)
  (a : Bool) => (b : Bool) => Bool.casesOn ((c : Bool) => (Eq Bool a c -> Iff (Not (Eq Bool a (Bool.not b))) (Eq Bool a b))) a ((d : Eq Bool a Bool.false) => Eq.ndrec Bool Bool.false ((e : Bool) => Iff (Not (Eq Bool e (Bool.not b))) (Eq Bool e b)) (Bool.casesOn ((f : Bool) => (Eq Bool b f -> Iff (Not (Eq Bool Bool.false (Bool.not b))) (Eq Bool Bool.false b))) b ((g : Eq Bool b Bool.false) => Eq.ndrec Bool Bool.false ((h : Bool) => Iff (Not (Eq Bool Bool.false (Bool.not h))) (Eq Bool Bool.false h)) (of_eq_true (Iff (Not (Eq Bool Bool.false (Bool.not Bool.false))) (Eq Bool Bool.false Bool.false)) (Eq.trans Prop (Iff (Not (Eq Bool Bool.false (Bool.not Bool.false))) (Eq Bool Bool.false Bool.false)) (Iff True True) True (congr Prop Prop (Iff (Not (Eq Bool Bool.false (Bool.not Bool.false)))) (Iff True) (Eq Bool Bool.false Bool.false) True (congrArg Prop (Prop -> Prop) (Not (Eq Bool Bool.false (Bool.not Bool.false))) True Iff (Eq.trans Prop (Not (Eq Bool Bool.false (Bool.not Bool.false))) (Not False) True (congrArg Prop Prop (Eq Bool Bool.false (Bool.not Bool.false)) False Not (Eq.trans Prop (Eq Bool Bool.false (Bool.not Bool.false)) (Eq Bool Bool.false Bool.true) False (congrArg Bool Prop (Bool.not Bool.false) Bool.true (Eq Bool Bool.false) Bool.not_false) (eq_false' (Eq Bool Bool.false Bool.true) ((i : Eq Bool Bool.false Bool.true) => Bool.noConfusion False Bool.false Bool.true i)))) not_false_eq_true)) (eq_self Bool Bool.false)) (iff_self True))) b (Eq.symm Bool b Bool.false g)) ((j : Eq Bool b Bool.true) => Eq.ndrec Bool Bool.true ((k : Bool) => Iff (Not (Eq Bool Bool.false (Bool.not k))) (Eq Bool Bool.false k)) (of_eq_true (Iff (Not (Eq Bool Bool.false (Bool.not Bool.true))) (Eq Bool Bool.false Bool.true)) (Eq.trans Prop (Iff (Not (Eq Bool Bool.false (Bool.not Bool.true))) (Eq Bool Bool.false Bool.true)) (Iff False False) True (congr Prop Prop (Iff (Not (Eq Bool Bool.false (Bool.not Bool.true)))) (Iff False) (Eq Bool Bool.false Bool.true) False (congrArg Prop (Prop -> Prop) (Not (Eq Bool Bool.false (Bool.not Bool.true))) False Iff (Eq.trans Prop (Not (Eq Bool Bool.false (Bool.not Bool.true))) (Not True) False (congrArg Prop Prop (Eq Bool Bool.false (Bool.not Bool.true)) True Not (Eq.trans Prop (Eq Bool Bool.false (Bool.not Bool.true)) (Eq Bool Bool.false Bool.false) True (congrArg Bool Prop (Bool.not Bool.true) Bool.false (Eq Bool Bool.false) Bool.not_true) (eq_self Bool Bool.false))) not_true_eq_false)) (eq_false' (Eq Bool Bool.false Bool.true) ((l : Eq Bool Bool.false Bool.true) => Bool.noConfusion False Bool.false Bool.true l))) (iff_self False))) b (Eq.symm Bool b Bool.true j)) (Eq.refl Bool b)) a (Eq.symm Bool a Bool.false d)) ((m : Eq Bool a Bool.true) => Eq.ndrec Bool Bool.true ((n : Bool) => Iff (Not (Eq Bool n (Bool.not b))) (Eq Bool n b)) (Bool.casesOn ((o : Bool) => (Eq Bool b o -> Iff (Not (Eq Bool Bool.true (Bool.not b))) (Eq Bool Bool.true b))) b ((p : Eq Bool b Bool.false) => Eq.ndrec Bool Bool.false ((q : Bool) => Iff (Not (Eq Bool Bool.true (Bool.not q))) (Eq Bool Bool.true q)) (of_eq_true (Iff (Not (Eq Bool Bool.true (Bool.not Bool.false))) (Eq Bool Bool.true Bool.false)) (Eq.trans Prop (Iff (Not (Eq Bool Bool.true (Bool.not Bool.false))) (Eq Bool Bool.true Bool.false)) (Iff False False) True (congr Prop Prop (Iff (Not (Eq Bool Bool.true (Bool.not Bool.false)))) (Iff False) (Eq Bool Bool.true Bool.false) False (congrArg Prop (Prop -> Prop) (Not (Eq Bool Bool.true (Bool.not Bool.false))) False Iff (Eq.trans Prop (Not (Eq Bool Bool.true (Bool.not Bool.false))) (Not True) False (congrArg Prop Prop (Eq Bool Bool.true (Bool.not Bool.false)) True Not (Eq.trans Prop (Eq Bool Bool.true (Bool.not Bool.false)) (Eq Bool Bool.true Bool.true) True (congrArg Bool Prop (Bool.not Bool.false) Bool.true (Eq Bool Bool.true) Bool.not_false) (eq_self Bool Bool.true))) not_true_eq_false)) (eq_false' (Eq Bool Bool.true Bool.false) ((r : Eq Bool Bool.true Bool.false) => Bool.noConfusion False Bool.true Bool.false r))) (iff_self False))) b (Eq.symm Bool b Bool.false p)) ((s : Eq Bool b Bool.true) => Eq.ndrec Bool Bool.true ((t : Bool) => Iff (Not (Eq Bool Bool.true (Bool.not t))) (Eq Bool Bool.true t)) (of_eq_true (Iff (Not (Eq Bool Bool.true (Bool.not Bool.true))) (Eq Bool Bool.true Bool.true)) (Eq.trans Prop (Iff (Not (Eq Bool Bool.true (Bool.not Bool.true))) (Eq Bool Bool.true Bool.true)) (Iff True True) True (congr Prop Prop (Iff (Not (Eq Bool Bool.true (Bool.not Bool.true)))) (Iff True) (Eq Bool Bool.true Bool.true) True (congrArg Prop (Prop -> Prop) (Not (Eq Bool Bool.true (Bool.not Bool.true))) True Iff (Eq.trans Prop (Not (Eq Bool Bool.true (Bool.not Bool.true))) (Not False) True (congrArg Prop Prop (Eq Bool Bool.true (Bool.not Bool.true)) False Not (Eq.trans Prop (Eq Bool Bool.true (Bool.not Bool.true)) (Eq Bool Bool.true Bool.false) False (congrArg Bool Prop (Bool.not Bool.true) Bool.false (Eq Bool Bool.true) Bool.not_true) (eq_false' (Eq Bool Bool.true Bool.false) ((u : Eq Bool Bool.true Bool.false) => Bool.noConfusion False Bool.true Bool.false u)))) not_false_eq_true)) (eq_self Bool Bool.true)) (iff_self True))) b (Eq.symm Bool b Bool.true s)) (Eq.refl Bool b)) a (Eq.symm Bool a Bool.true m)) (Eq.refl Bool a)
thm Init.SimpLemmas._auxLemma.23 : (a : Bool) -> (b : Bool) -> Eq Prop (Not (Eq Bool a (Bool.not b))) (Eq Bool a b)
  (a : Bool) => (b : Bool) => propext (Not (Eq Bool a (Bool.not b))) (Eq Bool a b) (Bool.not_eq_not a b)
thm Bool.not_not_eq : (a : Bool) -> (b : Bool) -> Iff (Not (Eq Bool (Bool.not a) b)) (Eq Bool a b)
  (a : Bool) => (b : Bool) => of_eq_true (Iff (Not (Eq Bool (Bool.not a) b)) (Eq Bool a b)) (Eq.trans Prop (Iff (Not (Eq Bool (Bool.not a) b)) (Eq Bool a b)) (Iff (Eq Bool a b) (Eq Bool a b)) True (congrArg Prop Prop (Not (Eq Bool (Bool.not a) b)) (Eq Bool a b) ((c : Prop) => Iff c (Eq Bool a b)) (Eq.trans Prop (Not (Eq Bool (Bool.not a) b)) (Not (Eq Bool a (Bool.not b))) (Eq Bool a b) (congrArg Prop Prop (Eq Bool (Bool.not a) b) (Eq Bool a (Bool.not b)) Not (Init.SimpLemmas._auxLemma.22 a b)) (Init.SimpLemmas._auxLemma.23 a b))) (iff_self (Eq Bool a b)))
thm Bool.not_eq_true' : (a : Bool) -> Eq Prop (Eq Bool (Bool.not a) Bool.true) (Eq Bool a Bool.false)
  (a : Bool) => of_eq_true (Eq Prop (Eq Bool (Bool.not a) Bool.true) (Eq Bool a Bool.false)) (Eq.trans Prop (Eq Prop (Eq Bool (Bool.not a) Bool.true) (Eq Bool a Bool.false)) (Eq Prop (Eq Bool a Bool.false) (Eq Bool a Bool.false)) True (congrArg Prop Prop (Eq Bool (Bool.not a) Bool.true) (Eq Bool a Bool.false) ((b : Prop) => Eq Prop b (Eq Bool a Bool.false)) (Eq.trans Prop (Eq Bool (Bool.not a) Bool.true) (Eq Bool a (Bool.not Bool.true)) (Eq Bool a Bool.false) (Init.SimpLemmas._auxLemma.22 a Bool.true) (congrArg Bool Prop (Bool.not Bool.true) Bool.false (Eq Bool a) Bool.not_true))) (eq_self Prop (Eq Bool a Bool.false)))
thm Bool.not_eq_false' : (a : Bool) -> Eq Prop (Eq Bool (Bool.not a) Bool.false) (Eq Bool a Bool.true)
  (a : Bool) => of_eq_true (Eq Prop (Eq Bool (Bool.not a) Bool.false) (Eq Bool a Bool.true)) (Eq.trans Prop (Eq Prop (Eq Bool (Bool.not a) Bool.false) (Eq Bool a Bool.true)) (Eq Prop (Eq Bool a Bool.true) (Eq Bool a Bool.true)) True (congrArg Prop Prop (Eq Bool (Bool.not a) Bool.false) (Eq Bool a Bool.true) ((b : Prop) => Eq Prop b (Eq Bool a Bool.true)) (Eq.trans Prop (Eq Bool (Bool.not a) Bool.false) (Eq Bool a (Bool.not Bool.false)) (Eq Bool a Bool.true) (Init.SimpLemmas._auxLemma.22 a Bool.false) (congrArg Bool Prop (Bool.not Bool.false) Bool.true (Eq Bool a) Bool.not_false))) (eq_self Prop (Eq Bool a Bool.true)))
thm decide_eq_false_iff_not : (a : Prop) -> (b : Decidable a) -> Iff (Eq Bool (Decidable.decide a b) Bool.false) (Not a)
  (a : Prop) => (b : Decidable a) => Iff.intro (Eq Bool (Decidable.decide a b) Bool.false) (Not a) (of_decide_eq_false a b) (decide_eq_false a b)
thm Init.SimpLemmas._auxLemma.24 : (a : Prop) -> (b : Decidable a) -> Eq Prop (Eq Bool (Decidable.decide a b) Bool.false) (Not a)
  (a : Prop) => (b : Decidable a) => propext (Eq Bool (Decidable.decide a b) Bool.false) (Not a) (decide_eq_false_iff_not a b)
thm not_decide_eq_true : (a : Prop) -> (b : Decidable a) -> Eq Prop (Eq Bool (Bool.not (Decidable.decide a b)) Bool.true) (Not a)
  (a : Prop) => (b : Decidable a) => of_eq_true (Eq Prop (Eq Bool (Bool.not (Decidable.decide a b)) Bool.true) (Not a)) (Eq.trans Prop (Eq Prop (Eq Bool (Bool.not (Decidable.decide a b)) Bool.true) (Not a)) (Eq Prop (Not a) (Not a)) True (congrArg Prop Prop (Eq Bool (Bool.not (Decidable.decide a b)) Bool.true) (Not a) ((c : Prop) => Eq Prop c (Not a)) (Eq.trans Prop (Eq Bool (Bool.not (Decidable.decide a b)) Bool.true) (Eq Bool (Decidable.decide a b) (Bool.not Bool.true)) (Not a) (Init.SimpLemmas._auxLemma.22 (Decidable.decide a b) Bool.true) (Eq.trans Prop (Eq Bool (Decidable.decide a b) (Bool.not Bool.true)) (Eq Bool (Decidable.decide a b) Bool.false) (Not a) (congrArg Bool Prop (Bool.not Bool.true) Bool.false (Eq Bool (Decidable.decide a b)) Bool.not_true) (Init.SimpLemmas._auxLemma.24 a b)))) (eq_self Prop (Not a)))
def DecidableEq := (s0 : Sort(u)) => ((a : s0) -> (b : s0) -> Decidable (Eq s0 a b))
def BEq : Sort(u + 1) -> Sort(u + 1)
def BEq.beq : (s0 : Sort(u + 1)) -> BEq s0 -> s0 -> s0 -> Bool
def BEq.mk : (s0 : Sort(u + 1)) -> (s0 -> s0 -> Bool) -> BEq s0
def instBEqOfDecidableEq := (s0 : Sort(u_1 + 1)) => (a : DecidableEq s0) => BEq.mk s0 ((b : s0) => (c : s0) => Decidable.decide (Eq s0 b c) (a b c))
def LawfulBEq : (s0 : Sort(u + 1)) -> BEq s0 -> Prop
def LawfulBEq.rfl : (s0 : Sort(u + 1)) -> (a : BEq s0) -> LawfulBEq s0 a -> (b : s0) -> Eq Bool (BEq.beq s0 a b b) Bool.true
thm beq_self_eq_true : (s0 : Sort(u_1 + 1)) -> (a : BEq s0) -> LawfulBEq s0 a -> (b : s0) -> Eq Bool (BEq.beq s0 a b b) Bool.true
  (s0 : Sort(u_1 + 1)) => (a : BEq s0) => (b : LawfulBEq s0 a) => (c : s0) => LawfulBEq.rfl s0 a b c
def LawfulBEq.mk : (s0 : Sort(u + 1)) -> (a : BEq s0) -> ((b : s0) -> (c : s0) -> Eq Bool (BEq.beq s0 a b c) Bool.true -> Eq s0 b c) -> ((d : s0) -> Eq Bool (BEq.beq s0 a d d) Bool.true) -> LawfulBEq s0 a
def of_decide_eq_self_eq_true.match_1 := (s0 : Sort(u_1)) => (a : s0) => (f0 : Decidable (Eq s0 a a) -> Prop) => (b : Decidable (Eq s0 a a)) => (f1 : (c : Eq s0 a a) -> f0 (Decidable.isTrue (Eq s0 a a) c)) => (f2 : (d : Not (Eq s0 a a)) -> f0 (Decidable.isFalse (Eq s0 a a) d)) => Decidable.casesOn (Eq s0 a a) ((e : Decidable (Eq s0 a a)) => f0 e) b ((f : Not (Eq s0 a a)) => f2 f) ((g : Eq s0 a a) => f1 g)
thm of_decide_eq_self_eq_true : (s0 : Sort(u_1)) -> (a : DecidableEq s0) -> (b : s0) -> Eq Bool (Decidable.decide (Eq s0 b b) (a b b)) Bool.true
  (s0 : Sort(u_1)) => (a : DecidableEq s0) => (b : s0) => of_decide_eq_self_eq_true.match_1 s0 b ((c : Decidable (Eq s0 b b)) => Eq Bool (Decidable.decide (Eq s0 b b) c) Bool.true) (a b b) ((d : Eq s0 b b) => rfl Bool (Decidable.decide (Eq s0 b b) (Decidable.isTrue (Eq s0 b b) d))) ((e : Not (Eq s0 b b)) => absurd (Eq s0 b b) (Eq Bool (Decidable.decide (Eq s0 b b) (Decidable.isFalse (Eq s0 b b) e)) Bool.true) (rfl s0 b) e)
thm instLawfulBEq : (s0 : Sort(u_1 + 1)) -> (a : DecidableEq s0) -> LawfulBEq s0 (instBEqOfDecidableEq s0 a)
  (s0 : Sort(u_1 + 1)) => (a : DecidableEq s0) => LawfulBEq.mk s0 (instBEqOfDecidableEq s0 a) ((b : s0) => (c : s0) => of_decide_eq_true (Eq s0 b c) (a b c)) ((d : s0) => of_decide_eq_self_eq_true s0 a d)
thm beq_self_eq_true' : (s0 : Sort(u_1 + 1)) -> (a : DecidableEq s0) -> (b : s0) -> Eq Bool (BEq.beq s0 (instBEqOfDecidableEq s0 a) b b) Bool.true
  (s0 : Sort(u_1 + 1)) => (a : DecidableEq s0) => (b : s0) => of_eq_true (Eq Bool (BEq.beq s0 (instBEqOfDecidableEq s0 a) b b) Bool.true) (Eq.trans Prop (Eq Bool (BEq.beq s0 (instBEqOfDecidableEq s0 a) b b) Bool.true) (Eq Bool Bool.true Bool.true) True (congrArg Bool Prop (BEq.beq s0 (instBEqOfDecidableEq s0 a) b b) Bool.true ((c : Bool) => Eq Bool c Bool.true) (beq_self_eq_true s0 (instBEqOfDecidableEq s0 a) (instLawfulBEq s0 a) b)) (eq_self Bool Bool.true))
def bne := (s0 : Sort(u + 1)) => (a : BEq s0) => (b : s0) => (c : s0) => Bool.not (BEq.beq s0 a b c)
thm bne_self_eq_false : (s0 : Sort(u_1 + 1)) -> (a : BEq s0) -> LawfulBEq s0 a -> (b : s0) -> Eq Bool (bne s0 a b b) Bool.false
  (s0 : Sort(u_1 + 1)) => (a : BEq s0) => (b : LawfulBEq s0 a) => (c : s0) => of_eq_true (Eq Bool (Bool.not (BEq.beq s0 a c c)) Bool.false) (Eq.trans Prop (Eq Bool (Bool.not (BEq.beq s0 a c c)) Bool.false) (Eq Bool Bool.false Bool.false) True (congrArg Bool Prop (Bool.not (BEq.beq s0 a c c)) Bool.false ((d : Bool) => Eq Bool d Bool.false) (Eq.trans Bool (Bool.not (BEq.beq s0 a c c)) (Bool.not Bool.true) Bool.false (congrArg Bool Bool (BEq.beq s0 a c c) Bool.true Bool.not (beq_self_eq_true s0 a b c)) Bool.not_true)) (eq_self Bool Bool.false))
thm bne_self_eq_false' : (s0 : Sort(u_1 + 1)) -> (a : DecidableEq s0) -> (b : s0) -> Eq Bool (bne s0 (instBEqOfDecidableEq s0 a) b b) Bool.false
  (s0 : Sort(u_1 + 1)) => (a : DecidableEq s0) => (b : s0) => of_eq_true (Eq Bool (bne s0 (instBEqOfDecidableEq s0 a) b b) Bool.false) (Eq.trans Prop (Eq Bool (bne s0 (instBEqOfDecidableEq s0 a) b b) Bool.false) (Eq Bool Bool.false Bool.false) True (congrArg Bool Prop (bne s0 (instBEqOfDecidableEq s0 a) b b) Bool.false ((c : Bool) => Eq Bool c Bool.false) (bne_self_eq_false s0 (instBEqOfDecidableEq s0 a) (instLawfulBEq s0 a) b)) (eq_self Bool Bool.false))
def LawfulBEq.eq_of_beq : (s0 : Sort(u + 1)) -> (a : BEq s0) -> LawfulBEq s0 a -> (b : s0) -> (c : s0) -> Eq Bool (BEq.beq s0 a b c) Bool.true -> Eq s0 b c
thm beq_iff_eq : (s0 : Sort(u_1 + 1)) -> (a : BEq s0) -> LawfulBEq s0 a -> (b : s0) -> (c : s0) -> Iff (Eq Bool (BEq.beq s0 a b c) Bool.true) (Eq s0 b c)
  (s0 : Sort(u_1 + 1)) => (a : BEq s0) => (b : LawfulBEq s0 a) => (c : s0) => (d : s0) => Iff.intro (Eq Bool (BEq.beq s0 a c d) Bool.true) (Eq s0 c d) (LawfulBEq.eq_of_beq s0 a b c d) ((e : Eq s0 c d) => Eq.ndrec s0 c ((f : s0) => Eq Bool (BEq.beq s0 a c f) Bool.true) (LawfulBEq.rfl s0 a b c) d e)
thm Init.Core._auxLemma.1 : (s0 : Sort(u_1 + 1)) -> (a : BEq s0) -> LawfulBEq s0 a -> (b : s0) -> (c : s0) -> Eq Prop (Eq Bool (BEq.beq s0 a b c) Bool.true) (Eq s0 b c)
  (s0 : Sort(u_1 + 1)) => (a : BEq s0) => (b : LawfulBEq s0 a) => (c : s0) => (d : s0) => propext (Eq Bool (BEq.beq s0 a c d) Bool.true) (Eq s0 c d) (beq_iff_eq s0 a b c d)
thm instLawfulBEqBool : LawfulBEq Bool (instBEqOfDecidableEq Bool instDecidableEqBool)
  LawfulBEq.mk Bool (instBEqOfDecidableEq Bool instDecidableEqBool) ((a : Bool) => (b : Bool) => (c : Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) a b) Bool.true) => Bool.casesOn ((d : Bool) => (Eq Bool a d -> Eq Bool a b)) a ((e : Eq Bool a Bool.false) => Eq.ndrec Bool Bool.false ((f : Bool) => (Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) f b) Bool.true -> Eq Bool f b)) ((g : Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) Bool.false b) Bool.true) => Bool.casesOn ((h : Bool) => (Eq Bool b h -> Eq Bool Bool.false b)) b ((i : Eq Bool b Bool.false) => Eq.ndrec Bool Bool.false ((j : Bool) => (Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) Bool.false j) Bool.true -> Eq Bool Bool.false j)) (Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) Bool.false Bool.false) Bool.true => Eq.refl Bool Bool.false) b (Eq.symm Bool b Bool.false i) g) ((k : Eq Bool b Bool.true) => Eq.ndrec Bool Bool.true ((l : Bool) => (Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) Bool.false l) Bool.true -> Eq Bool Bool.false l)) ((m : Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) Bool.false Bool.true) Bool.true) => Bool.noConfusion (Eq Bool Bool.false Bool.true) (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) Bool.false Bool.true) Bool.true m) b (Eq.symm Bool b Bool.true k) g) (Eq.refl Bool b)) a (Eq.symm Bool a Bool.false e) c) ((n : Eq Bool a Bool.true) => Eq.ndrec Bool Bool.true ((o : Bool) => (Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) o b) Bool.true -> Eq Bool o b)) ((p : Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) Bool.true b) Bool.true) => Bool.casesOn ((q : Bool) => (Eq Bool b q -> Eq Bool Bool.true b)) b ((r : Eq Bool b Bool.false) => Eq.ndrec Bool Bool.false ((s : Bool) => (Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) Bool.true s) Bool.true -> Eq Bool Bool.true s)) ((t : Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) Bool.true Bool.false) Bool.true) => Bool.noConfusion (Eq Bool Bool.true Bool.false) (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) Bool.true Bool.false) Bool.true t) b (Eq.symm Bool b Bool.false r) p) ((u : Eq Bool b Bool.true) => Eq.ndrec Bool Bool.true ((v : Bool) => (Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) Bool.true v) Bool.true -> Eq Bool Bool.true v)) (Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) Bool.true Bool.true) Bool.true => Eq.refl Bool Bool.true) b (Eq.symm Bool b Bool.true u) p) (Eq.refl Bool b)) a (Eq.symm Bool a Bool.true n) c) (Eq.refl Bool a)) ((w : Bool) => Bool.casesOn ((x : Bool) => (Eq Bool w x -> Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) w w) Bool.true)) w ((y : Eq Bool w Bool.false) => Eq.ndrec Bool Bool.false ((z : Bool) => Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) z z) Bool.true) (of_decide_eq_true (Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) Bool.false Bool.false) Bool.true) (instDecidableEqBool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) Bool.false Bool.false) Bool.true) (id (Eq Bool (Decidable.decide (Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) Bool.false Bool.false) Bool.true) (instDecidableEqBool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) Bool.false Bool.false) Bool.true)) Bool.true) (Eq.refl Bool Bool.true))) w (Eq.symm Bool w Bool.false y)) ((A : Eq Bool w Bool.true) => Eq.ndrec Bool Bool.true ((B : Bool) => Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) B B) Bool.true) (of_decide_eq_true (Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) Bool.true Bool.true) Bool.true) (instDecidableEqBool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) Bool.true Bool.true) Bool.true) (id (Eq Bool (Decidable.decide (Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) Bool.true Bool.true) Bool.true) (instDecidableEqBool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) Bool.true Bool.true) Bool.true)) Bool.true) (Eq.refl Bool Bool.true))) w (Eq.symm Bool w Bool.true A)) (Eq.refl Bool w))
thm Bool.beq_to_eq : (a : Bool) -> (b : Bool) -> Eq Prop (Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) a b) Bool.true) (Eq Bool a b)
  (a : Bool) => (b : Bool) => of_eq_true (Eq Prop (Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) a b) Bool.true) (Eq Bool a b)) (Eq.trans Prop (Eq Prop (Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) a b) Bool.true) (Eq Bool a b)) (Eq Prop (Eq Bool a b) (Eq Bool a b)) True (congrArg Prop Prop (Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) a b) Bool.true) (Eq Bool a b) ((c : Prop) => Eq Prop c (Eq Bool a b)) (Init.Core._auxLemma.1 Bool (instBEqOfDecidableEq Bool instDecidableEqBool) instLawfulBEqBool a b)) (eq_self Prop (Eq Bool a b)))
def Ne := (s0 : Sort(u)) => (a : s0) => (b : s0) => Not (Eq s0 a b)
thm ne_eq : (s0 : Sort(u_1)) -> (a : s0) -> (b : s0) -> Eq Prop (Ne s0 a b) (Not (Eq s0 a b))
  (s0 : Sort(u_1)) => (a : s0) => (b : s0) => rfl Prop (Ne s0 a b)
thm beq_eq_false_iff_ne : (s0 : Sort(u_1 + 1)) -> (a : BEq s0) -> LawfulBEq s0 a -> (b : s0) -> (c : s0) -> Iff (Eq Bool (BEq.beq s0 a b c) Bool.false) (Ne s0 b c)
  (s0 : Sort(u_1 + 1)) => (a : BEq s0) => (b : LawfulBEq s0 a) => (c : s0) => (d : s0) => Eq.mpr (Iff (Eq Bool (BEq.beq s0 a c d) Bool.false) (Ne s0 c d)) (Iff (Eq Bool (BEq.beq s0 a c d) Bool.false) (Not (Eq s0 c d))) (id (Eq Prop (Iff (Eq Bool (BEq.beq s0 a c d) Bool.false) (Ne s0 c d)) (Iff (Eq Bool (BEq.beq s0 a c d) Bool.false) (Not (Eq s0 c d)))) (congrArg Prop Prop (Ne s0 c d) (Not (Eq s0 c d)) ((e : Prop) => Iff (Eq Bool (BEq.beq s0 a c d) Bool.false) e) (ne_eq s0 c d))) (Eq.mpr (Iff (Eq Bool (BEq.beq s0 a c d) Bool.false) (Not (Eq s0 c d))) (Iff (Eq Bool (BEq.beq s0 a c d) Bool.false) (Not (Eq Bool (BEq.beq s0 a c d) Bool.true))) (id (Eq Prop (Iff (Eq Bool (BEq.beq s0 a c d) Bool.false) (Not (Eq s0 c d))) (Iff (Eq Bool (BEq.beq s0 a c d) Bool.false) (Not (Eq Bool (BEq.beq s0 a c d) Bool.true)))) (congrArg Prop Prop (Eq s0 c d) (Eq Bool (BEq.beq s0 a c d) Bool.true) ((f : Prop) => Iff (Eq Bool (BEq.beq s0 a c d) Bool.false) (Not f)) (Eq.symm Prop (Eq Bool (BEq.beq s0 a c d) Bool.true) (Eq s0 c d) (propext (Eq Bool (BEq.beq s0 a c d) Bool.true) (Eq s0 c d) (beq_iff_eq s0 a b c d))))) (Bool.casesOn ((g : Bool) => (Eq Bool (BEq.beq s0 a c d) g -> Iff (Eq Bool (BEq.beq s0 a c d) Bool.false) (Not (Eq Bool (BEq.beq s0 a c d) Bool.true)))) (BEq.beq s0 a c d) ((h : Eq Bool (BEq.beq s0 a c d) Bool.false) => Eq.ndrec Bool Bool.false ((i : Bool) => Iff (Eq Bool i Bool.false) (Not (Eq Bool i Bool.true))) (of_decide_eq_true (Iff (Eq Bool Bool.false Bool.false) (Not (Eq Bool Bool.false Bool.true))) (instDecidableIff (Eq Bool Bool.false Bool.false) (Not (Eq Bool Bool.false Bool.true)) (instDecidableEqBool Bool.false Bool.false) (instDecidableNot (Eq Bool Bool.false Bool.true) (instDecidableEqBool Bool.false Bool.true))) (id (Eq Bool (Decidable.decide (Iff (Eq Bool Bool.false Bool.false) (Not (Eq Bool Bool.false Bool.true))) (instDecidableIff (Eq Bool Bool.false Bool.false) (Not (Eq Bool Bool.false Bool.true)) (instDecidableEqBool Bool.false Bool.false) (instDecidableNot (Eq Bool Bool.false Bool.true) (instDecidableEqBool Bool.false Bool.true)))) Bool.true) (Eq.refl Bool Bool.true))) (BEq.beq s0 a c d) (Eq.symm Bool (BEq.beq s0 a c d) Bool.false h)) ((j : Eq Bool (BEq.beq s0 a c d) Bool.true) => Eq.ndrec Bool Bool.true ((k : Bool) => Iff (Eq Bool k Bool.false) (Not (Eq Bool k Bool.true))) (of_decide_eq_true (Iff (Eq Bool Bool.true Bool.false) (Not (Eq Bool Bool.true Bool.true))) (instDecidableIff (Eq Bool Bool.true Bool.false) (Not (Eq Bool Bool.true Bool.true)) (instDecidableEqBool Bool.true Bool.false) (instDecidableNot (Eq Bool Bool.true Bool.true) (instDecidableEqBool Bool.true Bool.true))) (id (Eq Bool (Decidable.decide (Iff (Eq Bool Bool.true Bool.false) (Not (Eq Bool Bool.true Bool.true))) (instDecidableIff (Eq Bool Bool.true Bool.false) (Not (Eq Bool Bool.true Bool.true)) (instDecidableEqBool Bool.true Bool.false) (instDecidableNot (Eq Bool Bool.true Bool.true) (instDecidableEqBool Bool.true Bool.true)))) Bool.true) (Eq.refl Bool Bool.true))) (BEq.beq s0 a c d) (Eq.symm Bool (BEq.beq s0 a c d) Bool.true j)) (Eq.refl Bool (BEq.beq s0 a c d))))
thm Init.SimpLemmas._auxLemma.26 : (s0 : Sort(u_1 + 1)) -> (a : BEq s0) -> LawfulBEq s0 a -> (b : s0) -> (c : s0) -> Eq Prop (Eq Bool (BEq.beq s0 a b c) Bool.false) (Ne s0 b c)
  (s0 : Sort(u_1 + 1)) => (a : BEq s0) => (b : LawfulBEq s0 a) => (c : s0) => (d : s0) => propext (Eq Bool (BEq.beq s0 a c d) Bool.false) (Ne s0 c d) (beq_eq_false_iff_ne s0 a b c d)
thm Bool.not_beq_to_not_eq : (a : Bool) -> (b : Bool) -> Eq Prop (Eq Bool (Bool.not (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) a b)) Bool.true) (Not (Eq Bool a b))
  (a : Bool) => (b : Bool) => of_eq_true (Eq Prop (Eq Bool (Bool.not (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) a b)) Bool.true) (Not (Eq Bool a b))) (Eq.trans Prop (Eq Prop (Eq Bool (Bool.not (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) a b)) Bool.true) (Not (Eq Bool a b))) (Eq Prop (Ne Bool a b) (Not (Eq Bool a b))) True (congrArg Prop Prop (Eq Bool (Bool.not (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) a b)) Bool.true) (Ne Bool a b) ((c : Prop) => Eq Prop c (Not (Eq Bool a b))) (Eq.trans Prop (Eq Bool (Bool.not (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) a b)) Bool.true) (Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) a b) (Bool.not Bool.true)) (Ne Bool a b) (Init.SimpLemmas._auxLemma.22 (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) a b) Bool.true) (Eq.trans Prop (Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) a b) (Bool.not Bool.true)) (Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) a b) Bool.false) (Ne Bool a b) (congrArg Bool Prop (Bool.not Bool.true) Bool.false (Eq Bool (BEq.beq Bool (instBEqOfDecidableEq Bool instDecidableEqBool) a b)) Bool.not_true) (Init.SimpLemmas._auxLemma.26 Bool (instBEqOfDecidableEq Bool instDecidableEqBool) instLawfulBEqBool a b)))) (eq_self Prop (Not (Eq Bool a b))))
