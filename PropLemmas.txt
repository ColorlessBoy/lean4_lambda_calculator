def Prop := Sort(0)
def HEq : (s0 : Sort(u)) -> s0 -> (s1 : Sort(u)) -> s1 -> Prop
def Eq : (s0 : Sort(u_1)) -> s0 -> s0 -> Prop
def Eq.refl : (s0 : Sort(u_1)) -> (a : s0) -> Eq s0 a a
def Eq.rec : (s0 : Sort(u_1)) -> (a : s0) -> (f0 : (b : s0) -> Eq s0 a b -> Sort(u)) -> f0 a (Eq.refl s0 a) -> (c : s0) -> (d : Eq s0 a c) -> f0 c d
def Eq.casesOn := (s0 : Sort(u_1)) => (a : s0) => (f0 : (b : s0) -> Eq s0 a b -> Sort(u)) => (c : s0) => (d : Eq s0 a c) => (e : f0 a (Eq.refl s0 a)) => Eq.rec s0 a f0 e c d
def Iff : Prop -> Prop -> Prop
def propext : (a : Prop) -> (b : Prop) -> Iff a b -> Eq Prop a b
def Iff.intro : (a : Prop) -> (b : Prop) -> (a -> b) -> (b -> a) -> Iff a b
thm iff_of_true : (a : Prop) -> (b : Prop) -> a -> b -> Iff a b
  (a : Prop) => (b : Prop) => (c : a) => (d : b) => Iff.intro a b (a => d) (b => c)
def rfl := (s0 : Sort(u)) => (a : s0) => Eq.refl s0 a
thm Eq.symm : (s0 : Sort(u)) -> (a : s0) -> (b : s0) -> Eq s0 a b -> Eq s0 b a
  (s0 : Sort(u)) => (a : s0) => (b : s0) => (c : Eq s0 a b) => Eq.rec s0 a ((d : s0) => Eq s0 a d => Eq s0 d a) (rfl s0 a) b c
def HEq.refl : (s0 : Sort(u)) -> (a : s0) -> HEq s0 a s0 a
thm HEq.of_eq : (a : Sort(u)) -> (x : a) -> (y : a) -> Eq a x y -> HEq a x a y
  (a : Sort(u)) => (x : a) => Eq.rec a x ((z : a) => Eq a x z => HEq a x a z) (HEq.refl a x)
def proof_irrel : (a : Prop) -> (x : a) -> (y : a) -> Eq a x y
thm proof_irrel_heq_1 : (a : Prop) -> (x : a) -> (y : a) -> HEq a x a y
  (a : Prop) => (x : a) => (y : a) => HEq.of_eq a x y (proof_irrel a x y)
thm proof_irrel_heq : (a : Prop) -> (b : Prop) -> (c : a) -> (d : b) -> HEq a c b d
  (a : Prop) => (b : Prop) => (c : a) => (d : b) => Eq.casesOn Prop a ((e : Prop) => (f : Eq Prop a e) => (Eq Prop b e -> HEq (Eq Prop a b) (propext a b (iff_of_true a b c d)) (Eq Prop a e) f -> HEq a c b d)) b (propext a b (iff_of_true a b c d)) ((f : Eq Prop b a) => Eq.casesOn Prop a ((h : Prop) => Eq Prop a h => ((i : h) -> HEq (Eq Prop a h) (propext a h (iff_of_true a h c i)) (Eq Prop a a) (Eq.refl Prop a) -> HEq a c h i)) b (Eq.symm Prop b a f) ((i : a) => HEq (Eq Prop a a) (propext a a (iff_of_true a a c i)) (Eq Prop a a) (Eq.refl Prop a) => proof_irrel_heq_1 a c i) d) (Eq.refl Prop b) (HEq.refl (Eq Prop a b) (propext a b (iff_of_true a b c d)))
def False : Prop
def Not := (a : Prop) => (a -> False)
def Or : Prop -> Prop -> Prop
def Or.inr : (a : Prop) -> (b : Prop) -> b -> Or a b
def Function.comp := (s0 : Sort(u)) => (s1 : Sort(v)) => (s2 : Sort(w)) => (f0 : s1 -> s2) => (f1 : s0 -> s1) => (a : s0) => f0 (f1 a)
def Or.inl : (a : Prop) -> (b : Prop) -> a -> Or a b
thm not_not_em : (a : Prop) -> Not (Not (Or a (Not a)))
  (a : Prop) => (b : Not (Or a (Not a))) => b (Or.inr a (Not a) (Function.comp a (Or a (Not a)) False b (Or.inl a (Not a))))
def And : Prop -> Prop -> Prop
thm Iff.refl : (a : Prop) -> Iff a a
  (a : Prop) => Iff.intro a a ((b : a) => b) ((c : a) => c)
thm Iff.rfl : (a : Prop) -> Iff a a
  (a : Prop) => Iff.refl a
thm Iff.of_eq : (a : Prop) -> (b : Prop) -> Eq Prop a b -> Iff a b
  (a : Prop) => (b : Prop) => (c : Eq Prop a b) => Eq.rec Prop a ((d : Prop) => Eq Prop a d => Iff a d) (Iff.rfl a) b c
def And.left : (a : Prop) -> (b : Prop) -> And a b -> a
def And.intro : (a : Prop) -> (b : Prop) -> a -> b -> And a b
thm and_self : (a : Prop) -> Eq Prop (And a a) a
  (a : Prop) => propext (And a a) a (Iff.intro (And a a) a ((b : And a a) => And.left a a b) ((c : a) => And.intro a a c c))
thm and_self_iff : (a : Prop) -> Iff (And a a) a
  (a : Prop) => Iff.of_eq (And a a) a (and_self a)
def False.rec : (f0 : (a : False) -> Sort(u)) -> (b : False) -> f0 b
def absurd := (a : Prop) => (s0 : Sort(v)) => (b : a) => (c : Not a) => False.rec (False => s0) (c b)
def Not.elim := (a : Prop) => (s0 : Sort(u_1)) => (b : Not a) => (c : a) => absurd a s0 c b
thm iff_of_false : (a : Prop) -> (b : Prop) -> Not a -> Not b -> Iff a b
  (a : Prop) => (b : Prop) => (c : Not a) => (d : Not b) => Iff.intro a b (Not.elim a b c) (Not.elim b a d)
def id := (s0 : Sort(u)) => (a : s0) => a
thm iff_false_intro : (a : Prop) -> Not a -> Iff a False
  (a : Prop) => (b : Not a) => iff_of_false a False b (id False)
def And.rec : (a : Prop) -> (b : Prop) -> (f0 : And a b -> Sort(u)) -> ((c : a) -> (d : b) -> f0 (And.intro a b c d)) -> (e : And a b) -> f0 e
def And.casesOn := (a : Prop) => (b : Prop) => (f0 : And a b -> Sort(u)) => (c : And a b) => (f1 : (d : a) -> (e : b) -> f0 (And.intro a b d e)) => And.rec a b f0 ((f : a) => (g : b) => f1 f g) c
def and_not_self.match_1 := (a : Prop) => (f0 : And a (Not a) -> Prop) => (b : And a (Not a)) => (f1 : (c : a) -> (d : Not a) -> f0 (And.intro a (Not a) c d)) => And.casesOn a (Not a) ((e : And a (Not a)) => f0 e) b ((f : a) => (g : Not a) => f1 f g)
thm and_not_self : (a : Prop) -> Not (And a (Not a))
  (a : Prop) => (b : And a (Not a)) => and_not_self.match_1 a (And a (Not a) => False) b ((c : a) => (d : Not a) => absurd a False c d)
thm and_not_self_iff : (a : Prop) -> Iff (And a (Not a)) False
  (a : Prop) => iff_false_intro (And a (Not a)) (and_not_self a)
def And.symm.match_1 := (a : Prop) => (b : Prop) => (f0 : And a b -> Prop) => (c : And a b) => (f1 : (d : a) -> (e : b) -> f0 (And.intro a b d e)) => And.casesOn a b ((f : And a b) => f0 f) c ((g : a) => (h : b) => f1 g h)
thm And.symm : (a : Prop) -> (b : Prop) -> And a b -> And b a
  (a : Prop) => (b : Prop) => (c : And a b) => And.symm.match_1 a b (And a b => And b a) c ((d : a) => (e : b) => And.intro b a e d)
thm not_and_self : (a : Prop) -> Not (And (Not a) a)
  (a : Prop) => Function.comp (And (Not a) a) (And a (Not a)) False (and_not_self a) (And.symm (Not a) a)
thm not_and_self_iff : (a : Prop) -> Iff (And (Not a) a) False
  (a : Prop) => iff_false_intro (And (Not a) a) (not_and_self a)
def And.right : (a : Prop) -> (b : Prop) -> And a b -> b
thm And.imp : (a : Prop) -> (b : Prop) -> (c : Prop) -> (d : Prop) -> (a -> b) -> (c -> d) -> And a c -> And b d
  (a : Prop) => (b : Prop) => (c : Prop) => (d : Prop) => (f0 : a -> b) => (f1 : c -> d) => (e : And a c) => And.intro b d (f0 (And.left a c e)) (f1 (And.right a c e))
thm And.imp_left : (a : Prop) -> (b : Prop) -> (c : Prop) -> (a -> b) -> And a c -> And b c
  (a : Prop) => (b : Prop) => (c : Prop) => (f0 : a -> b) => And.imp a b c c f0 (id c)
thm And.imp_right : (a : Prop) -> (b : Prop) -> (c : Prop) -> (a -> b) -> And c a -> And c b
  (a : Prop) => (b : Prop) => (c : Prop) => (f0 : a -> b) => And.imp c c a b (id c) f0
def Iff.mp : (a : Prop) -> (b : Prop) -> Iff a b -> a -> b
def Iff.mpr : (a : Prop) -> (b : Prop) -> Iff a b -> b -> a
thm and_congr : (a : Prop) -> (b : Prop) -> (c : Prop) -> (d : Prop) -> Iff a b -> Iff c d -> Iff (And a c) (And b d)
  (a : Prop) => (b : Prop) => (c : Prop) => (d : Prop) => (e : Iff a b) => (f : Iff c d) => Iff.intro (And a c) (And b d) (And.imp a b c d (Iff.mp a b e) (Iff.mp c d f)) (And.imp b a d c (Iff.mpr a b e) (Iff.mpr c d f))
thm and_congr_left' : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff a b -> Iff (And a c) (And b c)
  (a : Prop) => (b : Prop) => (c : Prop) => (d : Iff a b) => and_congr a b c c d (Iff.rfl c)
thm and_congr_right' : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff a b -> Iff (And c a) (And c b)
  (a : Prop) => (b : Prop) => (c : Prop) => (d : Iff a b) => and_congr c c a b (Iff.rfl c) d
thm mt : (a : Prop) -> (b : Prop) -> (a -> b) -> Not b -> Not a
  (a : Prop) => (b : Prop) => (f0 : a -> b) => (c : Not b) => (d : a) => c (f0 d)
thm not_and_of_not_left : (a : Prop) -> (b : Prop) -> Not a -> Not (And a b)
  (a : Prop) => (b : Prop) => mt (And a b) a (And.left a b)
thm not_and_of_not_right : (a : Prop) -> (b : Prop) -> Not b -> Not (And a b)
  (a : Prop) => (b : Prop) => mt (And a b) b (And.right a b)
def and_imp.match_1 := (a : Prop) => (b : Prop) => (f0 : And a b -> Prop) => (c : And a b) => (f1 : (d : a) -> (e : b) -> f0 (And.intro a b d e)) => And.casesOn a b ((f : And a b) => f0 f) c ((g : a) => (h : b) => f1 g h)
thm and_congr_right : (a : Prop) -> (b : Prop) -> (c : Prop) -> (a -> Iff b c) -> Iff (And a b) (And a c)
  (a : Prop) => (b : Prop) => (c : Prop) => (f0 : a -> Iff b c) => Iff.intro (And a b) (And a c) ((d : And a b) => and_imp.match_1 a b (And a b => And a c) d ((e : a) => (f : b) => And.intro a c e (Iff.mp b c (f0 e) f))) ((g : And a c) => and_imp.match_1 a c (And a c => And a b) g ((h : a) => (i : c) => And.intro a b h (Iff.mpr b c (f0 h) i)))
thm and_congr_right_eq : (a : Prop) -> (b : Prop) -> (c : Prop) -> (a -> Eq Prop b c) -> Eq Prop (And a b) (And a c)
  (a : Prop) => (b : Prop) => (c : Prop) => (f0 : a -> Eq Prop b c) => propext (And a b) (And a c) (and_congr_right a b c (Function.comp a (Eq Prop b c) (Iff b c) (Iff.of_eq b c) f0))
thm Iff.trans : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff a b -> Iff b c -> Iff a c
  (a : Prop) => (b : Prop) => (c : Prop) => (d : Iff a b) => (e : Iff b c) => Iff.intro a c (Function.comp a b c (Iff.mp b c e) (Iff.mp a b d)) (Function.comp c b a (Iff.mpr a b d) (Iff.mpr b c e))
thm And.comm : (a : Prop) -> (b : Prop) -> Iff (And a b) (And b a)
  (a : Prop) => (b : Prop) => Iff.intro (And a b) (And b a) (And.symm a b) (And.symm b a)
thm and_comm : (a : Prop) -> (b : Prop) -> Iff (And a b) (And b a)
  (a : Prop) => (b : Prop) => And.comm a b
thm and_congr_left : (a : Prop) -> (b : Prop) -> (c : Prop) -> (a -> Iff b c) -> Iff (And b a) (And c a)
  (a : Prop) => (b : Prop) => (c : Prop) => (f0 : a -> Iff b c) => Iff.trans (And b a) (And a b) (And c a) (and_comm b a) (Iff.trans (And a b) (And a c) (And c a) (and_congr_right a b c f0) (and_comm a c))
thm and_congr_left_eq : (a : Prop) -> (b : Prop) -> (c : Prop) -> (a -> Eq Prop b c) -> Eq Prop (And b a) (And c a)
  (a : Prop) => (b : Prop) => (c : Prop) => (f0 : a -> Eq Prop b c) => propext (And b a) (And c a) (and_congr_left a b c (Function.comp a (Eq Prop b c) (Iff b c) (Iff.of_eq b c) f0))
def and_left_comm.match_1 := (a : Prop) => (b : Prop) => (c : Prop) => (f0 : And a (And b c) -> Prop) => (d : And a (And b c)) => (f1 : (e : a) -> (f : b) -> (g : c) -> f0 (And.intro a (And b c) e (And.intro b c f g))) => And.casesOn a (And b c) ((h : And a (And b c)) => f0 h) d ((i : a) => (j : And b c) => And.casesOn b c ((k : And b c) => f0 (And.intro a (And b c) i k)) j ((l : b) => (m : c) => f1 i l m))
def and_left_comm.match_2 := (a : Prop) => (b : Prop) => (c : Prop) => (f0 : And b (And a c) -> Prop) => (d : And b (And a c)) => (f1 : (e : b) -> (f : a) -> (g : c) -> f0 (And.intro b (And a c) e (And.intro a c f g))) => And.casesOn b (And a c) ((h : And b (And a c)) => f0 h) d ((i : b) => (j : And a c) => And.casesOn a c ((k : And a c) => f0 (And.intro b (And a c) i k)) j ((l : a) => (m : c) => f1 i l m))
thm and_left_comm : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff (And a (And b c)) (And b (And a c))
  (a : Prop) => (b : Prop) => (c : Prop) => Iff.intro (And a (And b c)) (And b (And a c)) ((d : And a (And b c)) => and_left_comm.match_1 a b c (And a (And b c) => And b (And a c)) d ((e : a) => (f : b) => (g : c) => And.intro b (And a c) f (And.intro a c e g))) ((h : And b (And a c)) => and_left_comm.match_2 a b c (And b (And a c) => And a (And b c)) h ((i : b) => (j : a) => (k : c) => And.intro a (And b c) j (And.intro b c i k)))
def and_right_comm.match_1 := (a : Prop) => (b : Prop) => (c : Prop) => (f0 : And (And a b) c -> Prop) => (d : And (And a b) c) => (f1 : (e : a) -> (f : b) -> (g : c) -> f0 (And.intro (And a b) c (And.intro a b e f) g)) => And.casesOn (And a b) c ((h : And (And a b) c) => f0 h) d ((i : And a b) => (j : c) => And.casesOn a b ((k : And a b) => f0 (And.intro (And a b) c k j)) i ((l : a) => (m : b) => f1 l m j))
def and_right_comm.match_2 := (a : Prop) => (b : Prop) => (c : Prop) => (f0 : And (And a c) b -> Prop) => (d : And (And a c) b) => (f1 : (e : a) -> (f : c) -> (g : b) -> f0 (And.intro (And a c) b (And.intro a c e f) g)) => And.casesOn (And a c) b ((h : And (And a c) b) => f0 h) d ((i : And a c) => (j : b) => And.casesOn a c ((k : And a c) => f0 (And.intro (And a c) b k j)) i ((l : a) => (m : c) => f1 l m j))
thm and_right_comm : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff (And (And a b) c) (And (And a c) b)
  (a : Prop) => (b : Prop) => (c : Prop) => Iff.intro (And (And a b) c) (And (And a c) b) ((d : And (And a b) c) => and_right_comm.match_1 a b c (And (And a b) c => And (And a c) b) d ((e : a) => (f : b) => (g : c) => And.intro (And a c) b (And.intro a c e g) f)) ((h : And (And a c) b) => and_right_comm.match_2 a b c (And (And a c) b => And (And a b) c) h ((i : a) => (j : c) => (k : b) => And.intro (And a b) c (And.intro a b i k) j))
def Eq.mpr := (s0 : Sort(u)) => (s1 : Sort(u)) => (a : Eq Sort(u) s0 s1) => (b : s1) => Eq.rec Sort(u) s1 ((s2 : Sort(u)) => Eq Sort(u) s1 s2 => s2) b s0 (Eq.symm Sort(u) s0 s1 a)
thm congrArg : (s0 : Sort(u)) -> (s1 : Sort(v)) -> (a : s0) -> (b : s0) -> (f0 : s0 -> s1) -> Eq s0 a b -> Eq s1 (f0 a) (f0 b)
  (s0 : Sort(u)) => (s1 : Sort(v)) => (a : s0) => (b : s0) => (f0 : s0 -> s1) => (c : Eq s0 a b) => Eq.rec s0 a ((d : s0) => Eq s0 a d => Eq s1 (f0 a) (f0 d)) (rfl s1 (f0 a)) b c
thm and_rotate : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff (And a (And b c)) (And b (And c a))
  (a : Prop) => (b : Prop) => (c : Prop) => Eq.mpr (Iff (And a (And b c)) (And b (And c a))) (Iff (And b (And a c)) (And b (And c a))) (id (Eq Prop (Iff (And a (And b c)) (And b (And c a))) (Iff (And b (And a c)) (And b (And c a)))) (congrArg Prop Prop (And a (And b c)) (And b (And a c)) ((d : Prop) => Iff d (And b (And c a))) (propext (And a (And b c)) (And b (And a c)) (and_left_comm a b c)))) (Eq.mpr (Iff (And b (And a c)) (And b (And c a))) (Iff (And b (And c a)) (And b (And c a))) (id (Eq Prop (Iff (And b (And a c)) (And b (And c a))) (Iff (And b (And c a)) (And b (And c a)))) (congrArg Prop Prop (And a c) (And c a) ((e : Prop) => Iff (And b e) (And b (And c a))) (propext (And a c) (And c a) (and_comm a c)))) (Iff.rfl (And b (And c a))))
def and_assoc.match_1 := (a : Prop) => (b : Prop) => (c : Prop) => (f0 : And (And a b) c -> Prop) => (d : And (And a b) c) => (f1 : (e : a) -> (f : b) -> (g : c) -> f0 (And.intro (And a b) c (And.intro a b e f) g)) => And.casesOn (And a b) c ((h : And (And a b) c) => f0 h) d ((i : And a b) => (j : c) => And.casesOn a b ((k : And a b) => f0 (And.intro (And a b) c k j)) i ((l : a) => (m : b) => f1 l m j))
def and_assoc.match_2 := (a : Prop) => (b : Prop) => (c : Prop) => (f0 : And a (And b c) -> Prop) => (d : And a (And b c)) => (f1 : (e : a) -> (f : b) -> (g : c) -> f0 (And.intro a (And b c) e (And.intro b c f g))) => And.casesOn a (And b c) ((h : And a (And b c)) => f0 h) d ((i : a) => (j : And b c) => And.casesOn b c ((k : And b c) => f0 (And.intro a (And b c) i k)) j ((l : b) => (m : c) => f1 i l m))
thm and_assoc : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff (And (And a b) c) (And a (And b c))
  (a : Prop) => (b : Prop) => (c : Prop) => Iff.intro (And (And a b) c) (And a (And b c)) ((d : And (And a b) c) => and_assoc.match_1 a b c (And (And a b) c => And a (And b c)) d ((e : a) => (f : b) => (g : c) => And.intro a (And b c) e (And.intro b c f g))) ((h : And a (And b c)) => and_assoc.match_2 a b c (And a (And b c) => And (And a b) c) h ((i : a) => (j : b) => (k : c) => And.intro (And a b) c (And.intro a b i j) k))
thm and_and_and_comm : (a : Prop) -> (b : Prop) -> (c : Prop) -> (d : Prop) -> Iff (And (And a b) (And c d)) (And (And a c) (And b d))
  (a : Prop) => (b : Prop) => (c : Prop) => (d : Prop) => Eq.mpr (Iff (And (And a b) (And c d)) (And (And a c) (And b d))) (Iff (And (And (And a b) c) d) (And (And a c) (And b d))) (id (Eq Prop (Iff (And (And a b) (And c d)) (And (And a c) (And b d))) (Iff (And (And (And a b) c) d) (And (And a c) (And b d)))) (congrArg Prop Prop (And (And a b) (And c d)) (And (And (And a b) c) d) ((e : Prop) => Iff e (And (And a c) (And b d))) (Eq.symm Prop (And (And (And a b) c) d) (And (And a b) (And c d)) (propext (And (And (And a b) c) d) (And (And a b) (And c d)) (and_assoc (And a b) c d))))) (Eq.mpr (Iff (And (And (And a b) c) d) (And (And a c) (And b d))) (Iff (And (And (And a c) b) d) (And (And a c) (And b d))) (id (Eq Prop (Iff (And (And (And a b) c) d) (And (And a c) (And b d))) (Iff (And (And (And a c) b) d) (And (And a c) (And b d)))) (congrArg Prop Prop (And (And a b) c) (And (And a c) b) ((f : Prop) => Iff (And f d) (And (And a c) (And b d))) (propext (And (And a b) c) (And (And a c) b) (and_right_comm a b c)))) (Eq.mpr (Iff (And (And (And a c) b) d) (And (And a c) (And b d))) (Iff (And (And a c) (And b d)) (And (And a c) (And b d))) (id (Eq Prop (Iff (And (And (And a c) b) d) (And (And a c) (And b d))) (Iff (And (And a c) (And b d)) (And (And a c) (And b d)))) (congrArg Prop Prop (And (And (And a c) b) d) (And (And a c) (And b d)) ((g : Prop) => Iff g (And (And a c) (And b d))) (propext (And (And (And a c) b) d) (And (And a c) (And b d)) (and_assoc (And a c) b d)))) (Iff.rfl (And (And a c) (And b d)))))
thm and_and_left : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff (And a (And b c)) (And (And a b) (And a c))
  (a : Prop) => (b : Prop) => (c : Prop) => Eq.mpr (Iff (And a (And b c)) (And (And a b) (And a c))) (Iff (And a (And b c)) (And (And a a) (And b c))) (id (Eq Prop (Iff (And a (And b c)) (And (And a b) (And a c))) (Iff (And a (And b c)) (And (And a a) (And b c)))) (congrArg Prop Prop (And (And a b) (And a c)) (And (And a a) (And b c)) ((d : Prop) => Iff (And a (And b c)) d) (propext (And (And a b) (And a c)) (And (And a a) (And b c)) (and_and_and_comm a b a c)))) (Eq.mpr (Iff (And a (And b c)) (And (And a a) (And b c))) (Iff (And a (And b c)) (And a (And b c))) (id (Eq Prop (Iff (And a (And b c)) (And (And a a) (And b c))) (Iff (And a (And b c)) (And a (And b c)))) (congrArg Prop Prop (And a a) a ((e : Prop) => Iff (And a (And b c)) (And e (And b c))) (and_self a))) (Iff.rfl (And a (And b c))))
thm and_and_right : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff (And (And a b) c) (And (And a c) (And b c))
  (a : Prop) => (b : Prop) => (c : Prop) => Eq.mpr (Iff (And (And a b) c) (And (And a c) (And b c))) (Iff (And (And a b) c) (And (And a b) (And c c))) (id (Eq Prop (Iff (And (And a b) c) (And (And a c) (And b c))) (Iff (And (And a b) c) (And (And a b) (And c c)))) (congrArg Prop Prop (And (And a c) (And b c)) (And (And a b) (And c c)) ((d : Prop) => Iff (And (And a b) c) d) (propext (And (And a c) (And b c)) (And (And a b) (And c c)) (and_and_and_comm a c b c)))) (Eq.mpr (Iff (And (And a b) c) (And (And a b) (And c c))) (Iff (And (And a b) c) (And (And a b) c)) (id (Eq Prop (Iff (And (And a b) c) (And (And a b) (And c c))) (Iff (And (And a b) c) (And (And a b) c))) (congrArg Prop Prop (And c c) c ((e : Prop) => Iff (And (And a b) c) (And (And a b) e)) (and_self c))) (Iff.rfl (And (And a b) c)))
thm and_iff_left : (a : Prop) -> (b : Prop) -> a -> Iff (And b a) b
  (a : Prop) => (b : Prop) => (c : a) => Iff.intro (And b a) b (And.left b a) ((d : b) => And.intro b a d c)
thm and_iff_right : (a : Prop) -> (b : Prop) -> a -> Iff (And a b) b
  (a : Prop) => (b : Prop) => (c : a) => Iff.intro (And a b) b (And.right a b) ((d : b) => And.intro a b c d)
def Or.rec : (a : Prop) -> (b : Prop) -> (f0 : Or a b -> Prop) -> ((c : a) -> f0 (Or.inl a b c)) -> ((d : b) -> f0 (Or.inr a b d)) -> (e : Or a b) -> f0 e
def Or.casesOn := (a : Prop) => (b : Prop) => (f0 : Or a b -> Prop) => (c : Or a b) => (f1 : (d : a) -> f0 (Or.inl a b d)) => (f2 : (e : b) -> f0 (Or.inr a b e)) => Or.rec a b f0 ((f : a) => f1 f) ((g : b) => f2 g) c
def or_self.match_1 := (a : Prop) => (f0 : Or a a -> Prop) => (b : Or a a) => (f1 : (c : a) -> f0 (Or.inl a a c)) => (f2 : (d : a) -> f0 (Or.inr a a d)) => Or.casesOn a a ((e : Or a a) => f0 e) b ((f : a) => f1 f) ((g : a) => f2 g)
thm or_self : (a : Prop) -> Eq Prop (Or a a) a
  (a : Prop) => propext (Or a a) a (Iff.intro (Or a a) a ((b : Or a a) => or_self.match_1 a (Or a a => a) b ((c : a) => c) ((d : a) => d)) (Or.inl a a))
thm or_self_iff : (a : Prop) -> Iff (Or a a) a
  (a : Prop) => Eq.rec Prop a ((b : Prop) => Eq Prop a b => Iff b a) (Iff.rfl a) (Or a a) (Eq.symm Prop (Or a a) a (or_self a))
def Or.elim.match_1 := (a : Prop) => (b : Prop) => (f0 : Or a b -> Prop) => (c : Or a b) => (f1 : (d : a) -> f0 (Or.inl a b d)) => (f2 : (e : b) -> f0 (Or.inr a b e)) => Or.casesOn a b ((f : Or a b) => f0 f) c ((g : a) => f1 g) ((h : b) => f2 h)
thm Or.elim : (a : Prop) -> (b : Prop) -> (c : Prop) -> Or a b -> (a -> c) -> (b -> c) -> c
  (a : Prop) => (b : Prop) => (c : Prop) => (d : Or a b) => (f0 : a -> c) => (f1 : b -> c) => Or.elim.match_1 a b (Or a b => c) d ((e : a) => f0 e) ((f : b) => f1 f)
thm not_or_intro : (a : Prop) -> (b : Prop) -> Not a -> Not b -> Not (Or a b)
  (a : Prop) => (b : Prop) => (c : Not a) => (d : Not b) => (e : Or a b) => Or.elim a b False e c d
thm Or.imp : (a : Prop) -> (b : Prop) -> (c : Prop) -> (d : Prop) -> (a -> b) -> (c -> d) -> Or a c -> Or b d
  (a : Prop) => (b : Prop) => (c : Prop) => (d : Prop) => (f0 : a -> b) => (f1 : c -> d) => (e : Or a c) => Or.elim a c (Or b d) e (Function.comp a b (Or b d) (Or.inl b d) f0) (Function.comp c d (Or b d) (Or.inr b d) f1)
thm or_congr : (a : Prop) -> (b : Prop) -> (c : Prop) -> (d : Prop) -> Iff a b -> Iff c d -> Iff (Or a c) (Or b d)
  (a : Prop) => (b : Prop) => (c : Prop) => (d : Prop) => (e : Iff a b) => (f : Iff c d) => Iff.intro (Or a c) (Or b d) (Or.imp a b c d (Iff.mp a b e) (Iff.mp c d f)) (Or.imp b a d c (Iff.mpr a b e) (Iff.mpr c d f))
thm or_congr_left : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff a b -> Iff (Or a c) (Or b c)
  (a : Prop) => (b : Prop) => (c : Prop) => (d : Iff a b) => or_congr a b c c d (Iff.rfl c)
thm or_congr_right : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff a b -> Iff (Or c a) (Or c b)
  (a : Prop) => (b : Prop) => (c : Prop) => (d : Iff a b) => or_congr c c a b (Iff.rfl c) d
thm Or.imp_right : (a : Prop) -> (b : Prop) -> (c : Prop) -> (a -> b) -> Or c a -> Or c b
  (a : Prop) => (b : Prop) => (c : Prop) => (f0 : a -> b) => Or.imp c c a b (id c) f0
thm Or.imp_left : (a : Prop) -> (b : Prop) -> (c : Prop) -> (a -> b) -> Or a c -> Or b c
  (a : Prop) => (b : Prop) => (c : Prop) => (f0 : a -> b) => Or.imp a b c c f0 (id c)
thm or_assoc : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff (Or (Or a b) c) (Or a (Or b c))
  (a : Prop) => (b : Prop) => (c : Prop) => Iff.intro (Or (Or a b) c) (Or a (Or b c)) ((d : Or (Or a b) c) => Or.rec (Or a b) c (Or (Or a b) c => Or a (Or b c)) (Or.imp_right b (Or b c) a (Or.inl b c)) (Function.comp c (Or b c) (Or a (Or b c)) (Or.inr a (Or b c)) (Or.inr b c)) d) ((e : Or a (Or b c)) => Or.rec a (Or b c) (Or a (Or b c) => Or (Or a b) c) (Function.comp a (Or a b) (Or (Or a b) c) (Or.inl (Or a b) c) (Or.inl a b)) (Or.imp_left b (Or a b) c (Or.inr a b)) e)
thm Or.symm : (a : Prop) -> (b : Prop) -> Or a b -> Or b a
  (a : Prop) => (b : Prop) => (c : Or a b) => Or.rec a b (Or a b => Or b a) (Or.inr b a) (Or.inl b a) c
thm Or.comm : (a : Prop) -> (b : Prop) -> Iff (Or a b) (Or b a)
  (a : Prop) => (b : Prop) => Iff.intro (Or a b) (Or b a) (Or.symm a b) (Or.symm b a)
thm or_comm : (a : Prop) -> (b : Prop) -> Iff (Or a b) (Or b a)
  (a : Prop) => (b : Prop) => Or.comm a b
thm or_left_comm : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff (Or a (Or b c)) (Or b (Or a c))
  (a : Prop) => (b : Prop) => (c : Prop) => Eq.mpr (Iff (Or a (Or b c)) (Or b (Or a c))) (Iff (Or (Or a b) c) (Or b (Or a c))) (id (Eq Prop (Iff (Or a (Or b c)) (Or b (Or a c))) (Iff (Or (Or a b) c) (Or b (Or a c)))) (congrArg Prop Prop (Or a (Or b c)) (Or (Or a b) c) ((d : Prop) => Iff d (Or b (Or a c))) (Eq.symm Prop (Or (Or a b) c) (Or a (Or b c)) (propext (Or (Or a b) c) (Or a (Or b c)) (or_assoc a b c))))) (Eq.mpr (Iff (Or (Or a b) c) (Or b (Or a c))) (Iff (Or (Or a b) c) (Or (Or b a) c)) (id (Eq Prop (Iff (Or (Or a b) c) (Or b (Or a c))) (Iff (Or (Or a b) c) (Or (Or b a) c))) (congrArg Prop Prop (Or b (Or a c)) (Or (Or b a) c) ((e : Prop) => Iff (Or (Or a b) c) e) (Eq.symm Prop (Or (Or b a) c) (Or b (Or a c)) (propext (Or (Or b a) c) (Or b (Or a c)) (or_assoc b a c))))) (Eq.mpr (Iff (Or (Or a b) c) (Or (Or b a) c)) (Iff (Or (Or b a) c) (Or (Or b a) c)) (id (Eq Prop (Iff (Or (Or a b) c) (Or (Or b a) c)) (Iff (Or (Or b a) c) (Or (Or b a) c))) (congrArg Prop Prop (Or a b) (Or b a) ((f : Prop) => Iff (Or f c) (Or (Or b a) c)) (propext (Or a b) (Or b a) (or_comm a b)))) (Iff.rfl (Or (Or b a) c))))
thm or_right_comm : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff (Or (Or a b) c) (Or (Or a c) b)
  (a : Prop) => (b : Prop) => (c : Prop) => Eq.mpr (Iff (Or (Or a b) c) (Or (Or a c) b)) (Iff (Or a (Or b c)) (Or (Or a c) b)) (id (Eq Prop (Iff (Or (Or a b) c) (Or (Or a c) b)) (Iff (Or a (Or b c)) (Or (Or a c) b))) (congrArg Prop Prop (Or (Or a b) c) (Or a (Or b c)) ((d : Prop) => Iff d (Or (Or a c) b)) (propext (Or (Or a b) c) (Or a (Or b c)) (or_assoc a b c)))) (Eq.mpr (Iff (Or a (Or b c)) (Or (Or a c) b)) (Iff (Or a (Or b c)) (Or a (Or c b))) (id (Eq Prop (Iff (Or a (Or b c)) (Or (Or a c) b)) (Iff (Or a (Or b c)) (Or a (Or c b)))) (congrArg Prop Prop (Or (Or a c) b) (Or a (Or c b)) ((e : Prop) => Iff (Or a (Or b c)) e) (propext (Or (Or a c) b) (Or a (Or c b)) (or_assoc a c b)))) (Eq.mpr (Iff (Or a (Or b c)) (Or a (Or c b))) (Iff (Or a (Or c b)) (Or a (Or c b))) (id (Eq Prop (Iff (Or a (Or b c)) (Or a (Or c b))) (Iff (Or a (Or c b)) (Or a (Or c b)))) (congrArg Prop Prop (Or b c) (Or c b) ((f : Prop) => Iff (Or a f) (Or a (Or c b))) (propext (Or b c) (Or c b) (or_comm b c)))) (Iff.rfl (Or a (Or c b)))))
thm or_or_or_comm : (a : Prop) -> (b : Prop) -> (c : Prop) -> (d : Prop) -> Iff (Or (Or a b) (Or c d)) (Or (Or a c) (Or b d))
  (a : Prop) => (b : Prop) => (c : Prop) => (d : Prop) => Eq.mpr (Iff (Or (Or a b) (Or c d)) (Or (Or a c) (Or b d))) (Iff (Or (Or (Or a b) c) d) (Or (Or a c) (Or b d))) (id (Eq Prop (Iff (Or (Or a b) (Or c d)) (Or (Or a c) (Or b d))) (Iff (Or (Or (Or a b) c) d) (Or (Or a c) (Or b d)))) (congrArg Prop Prop (Or (Or a b) (Or c d)) (Or (Or (Or a b) c) d) ((e : Prop) => Iff e (Or (Or a c) (Or b d))) (Eq.symm Prop (Or (Or (Or a b) c) d) (Or (Or a b) (Or c d)) (propext (Or (Or (Or a b) c) d) (Or (Or a b) (Or c d)) (or_assoc (Or a b) c d))))) (Eq.mpr (Iff (Or (Or (Or a b) c) d) (Or (Or a c) (Or b d))) (Iff (Or (Or (Or a c) b) d) (Or (Or a c) (Or b d))) (id (Eq Prop (Iff (Or (Or (Or a b) c) d) (Or (Or a c) (Or b d))) (Iff (Or (Or (Or a c) b) d) (Or (Or a c) (Or b d)))) (congrArg Prop Prop (Or (Or a b) c) (Or (Or a c) b) ((f : Prop) => Iff (Or f d) (Or (Or a c) (Or b d))) (propext (Or (Or a b) c) (Or (Or a c) b) (or_right_comm a b c)))) (Eq.mpr (Iff (Or (Or (Or a c) b) d) (Or (Or a c) (Or b d))) (Iff (Or (Or a c) (Or b d)) (Or (Or a c) (Or b d))) (id (Eq Prop (Iff (Or (Or (Or a c) b) d) (Or (Or a c) (Or b d))) (Iff (Or (Or a c) (Or b d)) (Or (Or a c) (Or b d)))) (congrArg Prop Prop (Or (Or (Or a c) b) d) (Or (Or a c) (Or b d)) ((g : Prop) => Iff g (Or (Or a c) (Or b d))) (propext (Or (Or (Or a c) b) d) (Or (Or a c) (Or b d)) (or_assoc (Or a c) b d)))) (Iff.rfl (Or (Or a c) (Or b d)))))
thm or_or_distrib_left : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff (Or a (Or b c)) (Or (Or a b) (Or a c))
  (a : Prop) => (b : Prop) => (c : Prop) => Eq.mpr (Iff (Or a (Or b c)) (Or (Or a b) (Or a c))) (Iff (Or a (Or b c)) (Or (Or a a) (Or b c))) (id (Eq Prop (Iff (Or a (Or b c)) (Or (Or a b) (Or a c))) (Iff (Or a (Or b c)) (Or (Or a a) (Or b c)))) (congrArg Prop Prop (Or (Or a b) (Or a c)) (Or (Or a a) (Or b c)) ((d : Prop) => Iff (Or a (Or b c)) d) (propext (Or (Or a b) (Or a c)) (Or (Or a a) (Or b c)) (or_or_or_comm a b a c)))) (Eq.mpr (Iff (Or a (Or b c)) (Or (Or a a) (Or b c))) (Iff (Or a (Or b c)) (Or a (Or b c))) (id (Eq Prop (Iff (Or a (Or b c)) (Or (Or a a) (Or b c))) (Iff (Or a (Or b c)) (Or a (Or b c)))) (congrArg Prop Prop (Or a a) a ((e : Prop) => Iff (Or a (Or b c)) (Or e (Or b c))) (or_self a))) (Iff.rfl (Or a (Or b c))))
thm or_or_distrib_right : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff (Or (Or a b) c) (Or (Or a c) (Or b c))
  (a : Prop) => (b : Prop) => (c : Prop) => Eq.mpr (Iff (Or (Or a b) c) (Or (Or a c) (Or b c))) (Iff (Or (Or a b) c) (Or (Or a b) (Or c c))) (id (Eq Prop (Iff (Or (Or a b) c) (Or (Or a c) (Or b c))) (Iff (Or (Or a b) c) (Or (Or a b) (Or c c)))) (congrArg Prop Prop (Or (Or a c) (Or b c)) (Or (Or a b) (Or c c)) ((d : Prop) => Iff (Or (Or a b) c) d) (propext (Or (Or a c) (Or b c)) (Or (Or a b) (Or c c)) (or_or_or_comm a c b c)))) (Eq.mpr (Iff (Or (Or a b) c) (Or (Or a b) (Or c c))) (Iff (Or (Or a b) c) (Or (Or a b) c)) (id (Eq Prop (Iff (Or (Or a b) c) (Or (Or a b) (Or c c))) (Iff (Or (Or a b) c) (Or (Or a b) c))) (congrArg Prop Prop (Or c c) c ((e : Prop) => Iff (Or (Or a b) c) (Or (Or a b) e)) (or_self c))) (Iff.rfl (Or (Or a b) c)))
def True : Prop
def True.intro : True
thm trivial : True
  True.intro
thm of_eq_true : (a : Prop) -> Eq Prop a True -> a
  (a : Prop) => (b : Eq Prop a True) => Eq.rec Prop True ((c : Prop) => Eq Prop True c => c) trivial a (Eq.symm Prop a True b)
thm Eq.trans : (s0 : Sort(u)) -> (a : s0) -> (b : s0) -> (c : s0) -> Eq s0 a b -> Eq s0 b c -> Eq s0 a c
  (s0 : Sort(u)) => (a : s0) => (b : s0) => (c : s0) => (d : Eq s0 a b) => (e : Eq s0 b c) => Eq.rec s0 b ((f : s0) => Eq s0 b f => Eq s0 a f) d c e
thm Init.PropLemmas._auxLemma.3 : (a : Prop) -> (b : Prop) -> Eq Prop (Or a b) (Or b a)
  (a : Prop) => (b : Prop) => propext (Or a b) (Or b a) (Or.comm a b)
thm Init.PropLemmas._auxLemma.2 : (a : Prop) -> (b : Prop) -> (c : Prop) -> Eq Prop (Or a (Or b c)) (Or b (Or a c))
  (a : Prop) => (b : Prop) => (c : Prop) => propext (Or a (Or b c)) (Or b (Or a c)) (or_left_comm a b c)
thm eq_true : (a : Prop) -> a -> Eq Prop a True
  (a : Prop) => (b : a) => propext a True (Iff.intro a True (a => trivial) (True => b))
thm iff_self : (a : Prop) -> Eq Prop (Iff a a) True
  (a : Prop) => eq_true (Iff a a) (Iff.rfl a)
thm or_rotate : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff (Or a (Or b c)) (Or b (Or c a))
  (a : Prop) => (b : Prop) => (c : Prop) => of_eq_true (Iff (Or a (Or b c)) (Or b (Or c a))) (Eq.trans Prop (Iff (Or a (Or b c)) (Or b (Or c a))) (Iff (Or a (Or b c)) (Or a (Or b c))) True (congrArg Prop Prop (Or b (Or c a)) (Or a (Or b c)) (Iff (Or a (Or b c))) (Eq.trans Prop (Or b (Or c a)) (Or b (Or a c)) (Or a (Or b c)) (congrArg Prop Prop (Or c a) (Or a c) (Or b) (Init.PropLemmas._auxLemma.3 c a)) (Init.PropLemmas._auxLemma.2 b a c))) (iff_self (Or a (Or b c))))
thm or_iff_left_of_imp : (a : Prop) -> (b : Prop) -> (a -> b) -> Iff (Or b a) b
  (a : Prop) => (b : Prop) => (f0 : a -> b) => Iff.intro (Or b a) b ((c : Or b a) => Or.rec b a (Or b a => b) (id b) f0 c) (Or.inl b a)
thm or_iff_left_iff_imp : (a : Prop) -> (b : Prop) -> Iff (Iff (Or a b) a) (b -> a)
  (a : Prop) => (b : Prop) => Iff.intro (Iff (Or a b) a) (b -> a) ((c : Iff (Or a b) a) => Function.comp b (Or a b) a (Iff.mp (Or a b) a c) (Or.inr a b)) (or_iff_left_of_imp b a)
thm or_iff_left : (a : Prop) -> (b : Prop) -> Not a -> Iff (Or b a) b
  (a : Prop) => (b : Prop) => (c : Not a) => Iff.mpr (Iff (Or b a) b) (a -> b) (or_iff_left_iff_imp b a) (Not.elim a b c)
thm or_iff_right_iff_imp : (a : Prop) -> (b : Prop) -> Iff (Iff (Or a b) b) (a -> b)
  (a : Prop) => (b : Prop) => Eq.mpr (Iff (Iff (Or a b) b) (a -> b)) (Iff (Iff (Or b a) b) (a -> b)) (id (Eq Prop (Iff (Iff (Or a b) b) (a -> b)) (Iff (Iff (Or b a) b) (a -> b))) (congrArg Prop Prop (Or a b) (Or b a) ((c : Prop) => Iff (Iff c b) (a -> b)) (propext (Or a b) (Or b a) (or_comm a b)))) (Eq.mpr (Iff (Iff (Or b a) b) (a -> b)) (Iff (a -> b) (a -> b)) (id (Eq Prop (Iff (Iff (Or b a) b) (a -> b)) (Iff (a -> b) (a -> b))) (congrArg Prop Prop (Iff (Or b a) b) (a -> b) ((d : Prop) => Iff d (a -> b)) (propext (Iff (Or b a) b) (a -> b) (or_iff_left_iff_imp b a)))) (Iff.rfl (a -> b)))
thm or_iff_right : (a : Prop) -> (b : Prop) -> Not a -> Iff (Or a b) b
  (a : Prop) => (b : Prop) => (c : Not a) => Iff.mpr (Iff (Or a b) b) (a -> b) (or_iff_right_iff_imp a b) (Not.elim a b c)
def not_imp_of_and_not.match_1 := (a : Prop) => (b : Prop) => (f0 : And a (Not b) -> (a -> b) -> Prop) => (c : And a (Not b)) => (f1 : a -> b) => (f2 : (d : a) -> (e : Not b) -> (f3 : a -> b) -> f0 (And.intro a (Not b) d e) f3) => And.casesOn a (Not b) ((f : And a (Not b)) => f0 f f1) c ((g : a) => (h : Not b) => f2 g h f1)
thm not_imp_of_and_not : (a : Prop) -> (b : Prop) -> And a (Not b) -> Not (a -> b)
  (a : Prop) => (b : Prop) => (c : And a (Not b)) => (f0 : a -> b) => not_imp_of_and_not.match_1 a b (And a (Not b) => (a -> b) => False) c f0 ((d : a) => (e : Not b) => (f1 : a -> b) => e (f1 d))
thm imp_and : (a : Prop) -> (b : Prop) -> (s0 : Sort(u_1)) -> Iff (s0 -> And a b) (And (s0 -> a) (s0 -> b))
  (a : Prop) => (b : Prop) => (s0 : Sort(u_1)) => Iff.intro (s0 -> And a b) (And (s0 -> a) (s0 -> b)) ((f0 : s0 -> And a b) => And.intro ((c : s0) -> a) ((d : s0) -> b) ((e : s0) => And.left a b (f0 e)) ((f : s0) => And.right a b (f0 f))) ((g : And (s0 -> a) (s0 -> b)) => (h : s0) => And.intro a b (And.left (s0 -> a) (s0 -> b) g h) (And.right (s0 -> a) (s0 -> b) g h))
thm and_imp : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff (And a b -> c) (a -> b -> c)
  (a : Prop) => (b : Prop) => (c : Prop) => Iff.intro (And a b -> c) (a -> b -> c) ((f0 : And a b -> c) => (d : a) => (e : b) => f0 (And.intro a b d e)) ((f1 : a -> b -> c) => (f : And a b) => and_imp.match_1 a b (And a b => c) f ((g : a) => (h : b) => f1 g h))
thm not_and : (a : Prop) -> (b : Prop) -> Iff (Not (And a b)) (a -> Not b)
  (a : Prop) => (b : Prop) => and_imp a b False
def flip := (s0 : Sort(u)) => (s1 : Sort(v)) => (s2 : Sort(w)) => (f0 : (a : s0) -> (b : s1) -> s2) => (c : s1) => (d : s0) => f0 d c
thm imp.swap : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff (a -> b -> c) (b -> a -> c)
  (a : Prop) => (b : Prop) => (c : Prop) => Iff.intro (a -> b -> c) (b -> a -> c) (flip a b c) (flip b a c)
thm imp_not_comm : (a : Prop) -> (b : Prop) -> Iff (a -> Not b) (b -> Not a)
  (a : Prop) => (b : Prop) => imp.swap a b False
thm not_and' : (a : Prop) -> (b : Prop) -> Iff (Not (And a b)) (b -> Not a)
  (a : Prop) => (b : Prop) => Iff.trans (Not (And a b)) (a -> Not b) (b -> Not a) (not_and a b) (imp_not_comm a b)
def and_or_left.match_1 := (a : Prop) => (b : Prop) => (c : Prop) => (f0 : And a (Or b c) -> Prop) => (d : And a (Or b c)) => (f1 : (e : a) -> (f : Or b c) -> f0 (And.intro a (Or b c) e f)) => And.casesOn a (Or b c) ((g : And a (Or b c)) => f0 g) d ((h : a) => (i : Or b c) => f1 h i)
thm and_or_left : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff (And a (Or b c)) (Or (And a b) (And a c))
  (a : Prop) => (b : Prop) => (c : Prop) => Iff.intro (And a (Or b c)) (Or (And a b) (And a c)) ((d : And a (Or b c)) => and_or_left.match_1 a b c (And a (Or b c) => Or (And a b) (And a c)) d ((e : a) => (f : Or b c) => Or.imp b (And a b) c (And a c) (And.intro a b e) (And.intro a c e) f)) ((g : Or (And a b) (And a c)) => Or.rec (And a b) (And a c) (Or (And a b) (And a c) => And a (Or b c)) (And.imp_right b (Or b c) a (Or.inl b c)) (And.imp_right c (Or b c) a (Or.inr b c)) g)
thm or_and_right : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff (And (Or a b) c) (Or (And a c) (And b c))
  (a : Prop) => (b : Prop) => (c : Prop) => Eq.mpr (Iff (And (Or a b) c) (Or (And a c) (And b c))) (Iff (And c (Or a b)) (Or (And a c) (And b c))) (id (Eq Prop (Iff (And (Or a b) c) (Or (And a c) (And b c))) (Iff (And c (Or a b)) (Or (And a c) (And b c)))) (congrArg Prop Prop (And (Or a b) c) (And c (Or a b)) ((d : Prop) => Iff d (Or (And a c) (And b c))) (propext (And (Or a b) c) (And c (Or a b)) (and_comm (Or a b) c)))) (Eq.mpr (Iff (And c (Or a b)) (Or (And a c) (And b c))) (Iff (Or (And c a) (And c b)) (Or (And a c) (And b c))) (id (Eq Prop (Iff (And c (Or a b)) (Or (And a c) (And b c))) (Iff (Or (And c a) (And c b)) (Or (And a c) (And b c)))) (congrArg Prop Prop (And c (Or a b)) (Or (And c a) (And c b)) ((e : Prop) => Iff e (Or (And a c) (And b c))) (propext (And c (Or a b)) (Or (And c a) (And c b)) (and_or_left c a b)))) (Eq.mpr (Iff (Or (And c a) (And c b)) (Or (And a c) (And b c))) (Iff (Or (And a c) (And c b)) (Or (And a c) (And b c))) (id (Eq Prop (Iff (Or (And c a) (And c b)) (Or (And a c) (And b c))) (Iff (Or (And a c) (And c b)) (Or (And a c) (And b c)))) (congrArg Prop Prop (And c a) (And a c) ((f : Prop) => Iff (Or f (And c b)) (Or (And a c) (And b c))) (propext (And c a) (And a c) (and_comm c a)))) (Eq.mpr (Iff (Or (And a c) (And c b)) (Or (And a c) (And b c))) (Iff (Or (And a c) (And b c)) (Or (And a c) (And b c))) (id (Eq Prop (Iff (Or (And a c) (And c b)) (Or (And a c) (And b c))) (Iff (Or (And a c) (And b c)) (Or (And a c) (And b c)))) (congrArg Prop Prop (And c b) (And b c) ((g : Prop) => Iff (Or (And a c) g) (Or (And a c) (And b c))) (propext (And c b) (And b c) (and_comm c b)))) (Iff.rfl (Or (And a c) (And b c))))))
thm or_and_left : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff (Or a (And b c)) (And (Or a b) (Or a c))
  (a : Prop) => (b : Prop) => (c : Prop) => Iff.intro (Or a (And b c)) (And (Or a b) (Or a c)) ((d : Or a (And b c)) => Or.rec a (And b c) (Or a (And b c) => And (Or a b) (Or a c)) ((e : a) => And.intro (Or a b) (Or a c) (Or.inl a b e) (Or.inl a c e)) (And.imp b (Or a b) c (Or a c) (Or.inr a b) (Or.inr a c)) d) ((f : And (Or a b) (Or a c)) => And.rec (Or a b) (Or a c) (And (Or a b) (Or a c) => Or a (And b c)) ((g : Or a b) => Or.rec a b (Or a b => (Or a c -> Or a (And b c))) ((h : a) => Or a c => Or.inl a (And b c) h) (Function.comp b (c -> And b c) (Or a c -> Or a (And b c)) (Or.imp_right c (And b c) a) (And.intro b c)) g) f)
thm and_or_right : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff (Or (And a b) c) (And (Or a c) (Or b c))
  (a : Prop) => (b : Prop) => (c : Prop) => Eq.mpr (Iff (Or (And a b) c) (And (Or a c) (Or b c))) (Iff (Or c (And a b)) (And (Or a c) (Or b c))) (id (Eq Prop (Iff (Or (And a b) c) (And (Or a c) (Or b c))) (Iff (Or c (And a b)) (And (Or a c) (Or b c)))) (congrArg Prop Prop (Or (And a b) c) (Or c (And a b)) ((d : Prop) => Iff d (And (Or a c) (Or b c))) (propext (Or (And a b) c) (Or c (And a b)) (or_comm (And a b) c)))) (Eq.mpr (Iff (Or c (And a b)) (And (Or a c) (Or b c))) (Iff (And (Or c a) (Or c b)) (And (Or a c) (Or b c))) (id (Eq Prop (Iff (Or c (And a b)) (And (Or a c) (Or b c))) (Iff (And (Or c a) (Or c b)) (And (Or a c) (Or b c)))) (congrArg Prop Prop (Or c (And a b)) (And (Or c a) (Or c b)) ((e : Prop) => Iff e (And (Or a c) (Or b c))) (propext (Or c (And a b)) (And (Or c a) (Or c b)) (or_and_left c a b)))) (Eq.mpr (Iff (And (Or c a) (Or c b)) (And (Or a c) (Or b c))) (Iff (And (Or a c) (Or c b)) (And (Or a c) (Or b c))) (id (Eq Prop (Iff (And (Or c a) (Or c b)) (And (Or a c) (Or b c))) (Iff (And (Or a c) (Or c b)) (And (Or a c) (Or b c)))) (congrArg Prop Prop (Or c a) (Or a c) ((f : Prop) => Iff (And f (Or c b)) (And (Or a c) (Or b c))) (propext (Or c a) (Or a c) (or_comm c a)))) (Eq.mpr (Iff (And (Or a c) (Or c b)) (And (Or a c) (Or b c))) (Iff (And (Or a c) (Or b c)) (And (Or a c) (Or b c))) (id (Eq Prop (Iff (And (Or a c) (Or c b)) (And (Or a c) (Or b c))) (Iff (And (Or a c) (Or b c)) (And (Or a c) (Or b c)))) (congrArg Prop Prop (Or c b) (Or b c) ((g : Prop) => Iff (And (Or a c) g) (And (Or a c) (Or b c))) (propext (Or c b) (Or b c) (or_comm c b)))) (Iff.rfl (And (Or a c) (Or b c))))))
def or_imp.match_1 := (a : Prop) => (b : Prop) => (c : Prop) => (f0 : And (a -> c) (b -> c) -> Prop) => (d : And (a -> c) (b -> c)) => (f1 : (f2 : a -> c) -> (f3 : b -> c) -> f0 (And.intro (a -> c) (b -> c) f2 f3)) => And.casesOn (a -> c) (b -> c) ((e : And (a -> c) (b -> c)) => f0 e) d ((f4 : a -> c) => (f5 : b -> c) => f1 f4 f5)
thm or_imp : (a : Prop) -> (b : Prop) -> (c : Prop) -> Iff (Or a b -> c) (And (a -> c) (b -> c))
  (a : Prop) => (b : Prop) => (c : Prop) => Iff.intro (Or a b -> c) (And (a -> c) (b -> c)) ((f0 : Or a b -> c) => And.intro (a -> c) (b -> c) (Function.comp a (Or a b) c f0 (Or.inl a b)) (Function.comp b (Or a b) c f0 (Or.inr a b))) ((d : And (a -> c) (b -> c)) => or_imp.match_1 a b c (And (a -> c) (b -> c) => (Or a b -> c)) d ((f1 : a -> c) => (f2 : b -> c) => (e : Or a b) => Or.rec a b (Or a b => c) f1 f2 e))
thm not_and_of_not_or_not : (a : Prop) -> (b : Prop) -> Or (Not a) (Not b) -> Not (And a b)
  (a : Prop) => (b : Prop) => (c : Or (Not a) (Not b)) => Or.elim (Not a) (Not b) (Not (And a b)) c (mt (And a b) a ((d : And a b) => And.left a b d)) (mt (And a b) b ((e : And a b) => And.right a b e))
def Ne := (s0 : Sort(u)) => (a : s0) => (b : s0) => Not (Eq s0 a b)
thm ne_of_apply_ne : (s0 : Sort(u_1)) -> (s1 : Sort(u_2)) -> (f0 : s0 -> s1) -> (a : s0) -> (b : s0) -> Ne s1 (f0 a) (f0 b) -> Ne s0 a b
  (s0 : Sort(u_1)) => (s1 : Sort(u_2)) => (f0 : s0 -> s1) => (a : s0) => (b : s0) => mt (Eq s0 a b) (Eq s1 (f0 a) (f0 b)) (congrArg s0 s1 a b f0)
def Decidable : Prop -> Sort(0 + 1)
def ite : (s0 : Sort(u)) -> (a : Prop) -> Decidable a -> s0 -> s0 -> s0
def Decidable.isFalse : (a : Prop) -> Not a -> Decidable a
def Decidable.isTrue : (a : Prop) -> a -> Decidable a
def Decidable.rec : (a : Prop) -> (f0 : Decidable a -> Sort(u)) -> ((b : Not a) -> f0 (Decidable.isFalse a b)) -> ((c : a) -> f0 (Decidable.isTrue a c)) -> (d : Decidable a) -> f0 d
def Decidable.casesOn := (a : Prop) => (f0 : Decidable a -> Sort(u)) => (b : Decidable a) => (f1 : (c : Not a) -> f0 (Decidable.isFalse a c)) => (f2 : (d : a) -> f0 (Decidable.isTrue a d)) => Decidable.rec a f0 ((e : Not a) => f1 e) ((f : a) => f2 f) b
def Eq.ndrec := (s0 : Sort(u2)) => (a : s0) => (f0 : s0 -> Sort(u1)) => (b : f0 a) => (c : s0) => (d : Eq s0 a c) => Eq.rec s0 a ((e : s0) => Eq s0 a e => f0 e) b c d
thm congr : (s0 : Sort(u)) -> (s1 : Sort(v)) -> (f0 : s0 -> s1) -> (f1 : s0 -> s1) -> (a : s0) -> (b : s0) -> Eq (s0 -> s1) f0 f1 -> Eq s0 a b -> Eq s1 (f0 a) (f1 b)
  (s0 : Sort(u)) => (s1 : Sort(v)) => (f0 : s0 -> s1) => (f1 : s0 -> s1) => (a : s0) => (b : s0) => (c : Eq (s0 -> s1) f0 f1) => (d : Eq s0 a b) => Eq.rec ((e : s0) -> s1) f0 ((f2 : (f : s0) -> s1) => Eq (s0 -> s1) f0 f2 => Eq s1 (f0 a) (f2 b)) (Eq.rec s0 a ((g : s0) => Eq s0 a g => Eq s1 (f0 a) (f0 g)) (rfl s1 (f0 a)) b d) f1 c
thm not_false : Not False
  id False
def instDecidableFalse := Decidable.isFalse False not_false
def Decidable.byCases.match_1 := (a : Prop) => (f0 : Decidable a -> Sort(u_1)) => (b : Decidable a) => (f1 : (c : a) -> f0 (Decidable.isTrue a c)) => (f2 : (d : Not a) -> f0 (Decidable.isFalse a d)) => Decidable.casesOn a ((e : Decidable a) => f0 e) b ((f : Not a) => f2 f) ((g : a) => f1 g)
def Decidable.byCases := (a : Prop) => (s0 : Sort(u)) => (b : Decidable a) => (f0 : a -> s0) => (f1 : Not a -> s0) => Decidable.byCases.match_1 a (Decidable a => s0) b ((c : a) => f0 c) ((d : Not a) => f1 d)
thm Decidable.em : (a : Prop) -> Decidable a -> Or a (Not a)
  (a : Prop) => (b : Decidable a) => Decidable.byCases a (Or a (Not a)) b (Or.inl a (Not a)) (Or.inr a (Not a))
def if_pos : (a : Prop) -> (b : Decidable a) -> (c : a) -> (s0 : Sort(u)) -> (d : s0) -> (e : s0) -> Eq s0 (ite s0 a b d e) d
def if_neg : (a : Prop) -> (b : Decidable a) -> Not a -> (s0 : Sort(u)) -> (c : s0) -> (d : s0) -> Eq s0 (ite s0 a b c d) d
thm ite_congr : (s0 : Sort(u_1)) -> (a : Prop) -> (b : Prop) -> (c : s0) -> (d : s0) -> (e : s0) -> (f : s0) -> (g : Decidable a) -> (h : Decidable b) -> Eq Prop a b -> (b -> Eq s0 c e) -> (Not b -> Eq s0 d f) -> Eq s0 (ite s0 a g c d) (ite s0 b h e f)
  (s0 : Sort(u_1)) => (a : Prop) => (b : Prop) => (c : s0) => (d : s0) => (e : s0) => (f : s0) => (g : Decidable a) => (h : Decidable b) => (i : Eq Prop a b) => (f0 : b -> Eq s0 c e) => (f1 : Not b -> Eq s0 d f) => Or.casesOn b (Not b) ((j : Or b (Not b)) => (Eq (Or b (Not b)) (Decidable.em b h) j -> Eq s0 (ite s0 a g c d) (ite s0 b h e f))) (Decidable.em b h) ((k : b) => Eq (Or b (Not b)) (Decidable.em b h) (Or.inl b (Not b) k) => Eq.mpr (Eq s0 (ite s0 a g c d) (ite s0 b h e f)) (Eq s0 (ite s0 a g c d) e) (id (Eq Prop (Eq s0 (ite s0 a g c d) (ite s0 b h e f)) (Eq s0 (ite s0 a g c d) e)) (congrArg s0 Prop (ite s0 b h e f) e ((l : s0) => Eq s0 (ite s0 a g c d) l) (if_pos b h k s0 e f))) (Eq.ndrec Prop b ((m : Prop) => ((n : Decidable m) -> Eq s0 (ite s0 m n c d) e)) ((o : Decidable b) => Eq.mpr (Eq s0 (ite s0 b o c d) e) (Eq s0 c e) (id (Eq Prop (Eq s0 (ite s0 b o c d) e) (Eq s0 c e)) (congrArg s0 Prop (ite s0 b o c d) c ((p : s0) => Eq s0 p e) (if_pos b o k s0 c d))) (f0 k)) a (Eq.symm Prop a b i) g)) ((q : Not b) => Eq (Or b (Not b)) (Decidable.em b h) (Or.inr b (Not b) q) => Eq.mpr (Eq s0 (ite s0 a g c d) (ite s0 b h e f)) (Eq s0 (ite s0 a g c d) f) (id (Eq Prop (Eq s0 (ite s0 a g c d) (ite s0 b h e f)) (Eq s0 (ite s0 a g c d) f)) (congrArg s0 Prop (ite s0 b h e f) f ((r : s0) => Eq s0 (ite s0 a g c d) r) (if_neg b h q s0 e f))) (Eq.ndrec Prop b ((s : Prop) => ((t : Decidable s) -> Eq s0 (ite s0 s t c d) f)) ((u : Decidable b) => Eq.mpr (Eq s0 (ite s0 b u c d) f) (Eq s0 d f) (id (Eq Prop (Eq s0 (ite s0 b u c d) f) (Eq s0 d f)) (congrArg s0 Prop (ite s0 b u c d) d ((v : s0) => Eq s0 v f) (if_neg b u q s0 c d))) (f1 q)) a (Eq.symm Prop a b i) g)) (Eq.refl (Or b (Not b)) (Decidable.em b h))
thm eq_self : (s0 : Sort(u_1)) -> (a : s0) -> Eq Prop (Eq s0 a a) True
  (s0 : Sort(u_1)) => (a : s0) => eq_true (Eq s0 a a) (rfl s0 a)
thm ite_cond_eq_false : (s0 : Sort(u)) -> (a : Prop) -> (b : Decidable a) -> (c : s0) -> (d : s0) -> Eq Prop a False -> Eq s0 (ite s0 a b c d) d
  (s0 : Sort(u)) => (a : Prop) => (b : Decidable a) => (c : s0) => (d : s0) => (e : Eq Prop a False) => of_eq_true (Eq s0 (ite s0 a b c d) d) (Eq.trans Prop (Eq s0 (ite s0 a b c d) d) (Eq s0 (ite s0 False instDecidableFalse c d) d) True (congrArg s0 Prop (ite s0 a b c d) (ite s0 False instDecidableFalse c d) ((f : s0) => Eq s0 f d) (ite_congr s0 a False c d c d b instDecidableFalse e (False => Eq.refl s0 c) (Not False => Eq.refl s0 d))) (eq_self s0 d))
def False.elim := (s0 : Sort(u)) => (a : False) => False.rec ((b : False) => s0) a
thm eq_false : (a : Prop) -> Not a -> Eq Prop a False
  (a : Prop) => (b : Not a) => propext a False (Iff.intro a False ((c : a) => absurd a False c b) ((d : False) => False.elim a d))
thm not_false_eq_true : Eq Prop (Not False) True
  eq_true (Not False) (False.elim False)
thm true_and : (a : Prop) -> Eq Prop (And True a) a
  (a : Prop) => propext (And True a) a (Iff.intro (And True a) a ((b : And True a) => And.right True a b) ((c : a) => And.intro True a trivial c))
def instDecidableTrue := Decidable.isTrue True trivial
thm ite_cond_eq_true : (s0 : Sort(u)) -> (a : Prop) -> (b : Decidable a) -> (c : s0) -> (d : s0) -> Eq Prop a True -> Eq s0 (ite s0 a b c d) c
  (s0 : Sort(u)) => (a : Prop) => (b : Decidable a) => (c : s0) => (d : s0) => (e : Eq Prop a True) => of_eq_true (Eq s0 (ite s0 a b c d) c) (Eq.trans Prop (Eq s0 (ite s0 a b c d) c) (Eq s0 (ite s0 True instDecidableTrue c d) c) True (congrArg s0 Prop (ite s0 a b c d) (ite s0 True instDecidableTrue c d) ((f : s0) => Eq s0 f c) (ite_congr s0 a True c d c d b instDecidableTrue e (True => Eq.refl s0 c) (Not True => Eq.refl s0 d))) (eq_self s0 c))
def Bool : Sort(0 + 1)
def Bool.false : Bool
def Bool.true : Bool
def Decidable.decide := (a : Prop) => (b : Decidable a) => Decidable.casesOn a (Decidable a => Bool) b (Not a => Bool.false) (a => Bool.true)
def of_decide_eq_true.match_1 := (a : Prop) => (f0 : Decidable a -> Prop) => (b : Decidable a) => (f1 : (c : a) -> f0 (Decidable.isTrue a c)) => (f2 : (d : Not a) -> f0 (Decidable.isFalse a d)) => Decidable.casesOn a ((e : Decidable a) => f0 e) b ((f : Not a) => f2 f) ((g : a) => f1 g)
def Bool.rec : (f0 : (a : Bool) -> Sort(u)) -> f0 Bool.false -> f0 Bool.true -> (b : Bool) -> f0 b
def Bool.casesOn := (f0 : (a : Bool) -> Sort(u)) => (b : Bool) => (c : f0 Bool.false) => (d : f0 Bool.true) => Bool.rec f0 c d b
def ne_true_of_eq_false.match_1 := (f0 : (a : Bool) -> (b : Eq Bool a Bool.false) -> Prop) => (c : Bool) => (d : Eq Bool c Bool.false) => (f1 : (e : Eq Bool Bool.true Bool.false) -> f0 Bool.true e) => (f2 : (f : Eq Bool Bool.false Bool.false) -> f0 Bool.false f) => Bool.casesOn ((g : Bool) => ((h : Eq Bool g Bool.false) -> f0 g h)) c ((i : Eq Bool Bool.false Bool.false) => f2 i) ((j : Eq Bool Bool.true Bool.false) => f1 j) d
def Bool.noConfusionType := (s0 : Sort(u)) => (a : Bool) => (b : Bool) => Bool.casesOn ((c : Bool) => Sort(u)) a (Bool.casesOn ((d : Bool) => Sort(u)) b (s0 -> s0) s0) (Bool.casesOn ((e : Bool) => Sort(u)) b s0 (s0 -> s0))
def Bool.noConfusion := (s0 : Sort(u)) => (a : Bool) => (b : Bool) => (c : Eq Bool a b) => Eq.ndrec Bool a ((d : Bool) => (Eq Bool a d -> Bool.noConfusionType s0 a d)) (Eq Bool a a => Bool.casesOn ((e : Bool) => Bool.noConfusionType s0 e e) a ((f : s0) => f) ((g : s0) => g)) b c c
thm ne_true_of_eq_false : (a : Bool) -> Eq Bool a Bool.false -> Not (Eq Bool a Bool.true)
  (a : Bool) => (b : Eq Bool a Bool.false) => ne_true_of_eq_false.match_1 ((c : Bool) => (d : Eq Bool c Bool.false) => Not (Eq Bool c Bool.true)) a b ((e : Eq Bool Bool.true Bool.false) => Bool.noConfusion (Not (Eq Bool Bool.true Bool.true)) Bool.true Bool.false e) (Eq Bool Bool.false Bool.false => (f : Eq Bool Bool.false Bool.true) => Bool.noConfusion False Bool.false Bool.true f)
def decide_eq_false.match_1 := (a : Prop) => (f0 : Decidable a -> Not a -> Prop) => (b : Decidable a) => (c : Not a) => (f1 : (d : a) -> (e : Not a) -> f0 (Decidable.isTrue a d) e) => (f2 : (f : Not a) -> (g : Not a) -> f0 (Decidable.isFalse a f) g) => Decidable.casesOn a ((h : Decidable a) => f0 h c) b ((i : Not a) => f2 i c) ((j : a) => f1 j c)
thm decide_eq_false : (a : Prop) -> (b : Decidable a) -> Not a -> Eq Bool (Decidable.decide a b) Bool.false
  (a : Prop) => (b : Decidable a) => (c : Not a) => decide_eq_false.match_1 a ((d : Decidable a) => (e : Not a) => Eq Bool (Decidable.decide a d) Bool.false) b c ((f : a) => (g : Not a) => absurd a (Eq Bool (Decidable.decide a (Decidable.isTrue a f)) Bool.false) f g) ((h : Not a) => (i : Not a) => rfl Bool (Decidable.decide a (Decidable.isFalse a h)))
thm of_decide_eq_true : (a : Prop) -> (b : Decidable a) -> Eq Bool (Decidable.decide a b) Bool.true -> a
  (a : Prop) => (b : Decidable a) => (c : Eq Bool (Decidable.decide a b) Bool.true) => of_decide_eq_true.match_1 a (Decidable a => a) b ((d : a) => d) ((e : Not a) => absurd (Eq Bool (Decidable.decide a b) Bool.true) a c (ne_true_of_eq_false (Decidable.decide a b) (decide_eq_false a b e)))
def instDecidableEqOfIff.match_1 := (a : Prop) => (b : Prop) => (f0 : Decidable (Iff a b) -> Sort(u_1)) => (c : Decidable (Iff a b)) => (f1 : (d : Iff a b) -> f0 (Decidable.isTrue (Iff a b) d)) => (f2 : (e : Not (Iff a b)) -> f0 (Decidable.isFalse (Iff a b) e)) => Decidable.casesOn (Iff a b) ((f : Decidable (Iff a b)) => f0 f) c ((g : Not (Iff a b)) => f2 g) ((h : Iff a b) => f1 h)
thm instDecidableEqOfIff.proof_1 : (a : Prop) -> (b : Prop) -> Not (Iff a b) -> Eq Prop a b -> False
  (a : Prop) => (b : Prop) => (c : Not (Iff a b)) => (d : Eq Prop a b) => c (Eq.rec Prop a ((e : Prop) => Eq Prop a e => Iff a e) (Iff.rfl a) b d)
def instDecidableEqOfIff := (a : Prop) => (b : Prop) => (c : Decidable (Iff a b)) => instDecidableEqOfIff.match_1 a b (Decidable (Iff a b) => Decidable (Eq Prop a b)) c ((d : Iff a b) => Decidable.isTrue (Eq Prop a b) (propext a b d)) ((e : Not (Iff a b)) => Decidable.isFalse (Eq Prop a b) (instDecidableEqOfIff.proof_1 a b e))
def dite := (s0 : Sort(u)) => (a : Prop) => (b : Decidable a) => (f0 : a -> s0) => (f1 : Not a -> s0) => Decidable.casesOn a (Decidable a => s0) b f1 f0
thm instDecidableIff.proof_1 : (a : Prop) -> (b : Prop) -> a -> b -> Iff a b
  (a : Prop) => (b : Prop) => (c : a) => (d : b) => Iff.intro a b (a => d) (b => c)
thm instDecidableIff.proof_2 : (a : Prop) -> (b : Prop) -> a -> Not b -> Iff a b -> False
  (a : Prop) => (b : Prop) => (c : a) => (d : Not b) => (e : Iff a b) => d (Iff.mp a b e c)
thm instDecidableIff.proof_3 : (a : Prop) -> (b : Prop) -> Not a -> b -> Iff a b -> False
  (a : Prop) => (b : Prop) => (c : Not a) => (d : b) => (e : Iff a b) => c (Iff.mpr a b e d)
thm instDecidableIff.proof_4 : (a : Prop) -> (b : Prop) -> Not a -> Not b -> Iff a b
  (a : Prop) => (b : Prop) => (c : Not a) => (d : Not b) => Iff.intro a b ((e : a) => absurd a b e c) ((f : b) => absurd b a f d)
def instDecidableIff := (a : Prop) => (b : Prop) => (c : Decidable a) => (d : Decidable b) => dite (Decidable (Iff a b)) a c ((e : a) => dite (Decidable (Iff a b)) b d ((f : b) => Decidable.isTrue (Iff a b) (instDecidableIff.proof_1 a b e f)) ((g : Not b) => Decidable.isFalse (Iff a b) (instDecidableIff.proof_2 a b e g))) ((h : Not a) => dite (Decidable (Iff a b)) b d ((i : b) => Decidable.isFalse (Iff a b) (instDecidableIff.proof_3 a b h i)) ((j : Not b) => Decidable.isTrue (Iff a b) (instDecidableIff.proof_4 a b h j)))
def instDecidableAnd.match_1 := (a : Prop) => (f0 : Decidable a -> Sort(u_1)) => (b : Decidable a) => (f1 : (c : a) -> f0 (Decidable.isTrue a c)) => (f2 : (d : Not a) -> f0 (Decidable.isFalse a d)) => Decidable.casesOn a ((e : Decidable a) => f0 e) b ((f : Not a) => f2 f) ((g : a) => f1 g)
def instDecidableNot := (a : Prop) => (b : Decidable a) => instDecidableAnd.match_1 a (Decidable a => Decidable (Not a)) b ((c : a) => Decidable.isFalse (Not a) (absurd a False c)) ((d : Not a) => Decidable.isTrue (Not a) d)
thm not_true_eq_false : Eq Prop (Not True) False
  of_decide_eq_true (Eq Prop (Not True) False) (instDecidableEqOfIff (Not True) False (instDecidableIff (Not True) False (instDecidableNot True instDecidableTrue) instDecidableFalse)) (id (Eq Bool (Decidable.decide (Eq Prop (Not True) False) (instDecidableEqOfIff (Not True) False (instDecidableIff (Not True) False (instDecidableNot True instDecidableTrue) instDecidableFalse))) Bool.true) (Eq.refl Bool Bool.true))
thm false_and : (a : Prop) -> Eq Prop (And False a) False
  (a : Prop) => eq_false (And False a) ((b : And False a) => And.left False a b)
thm if_false_left : (a : Prop) -> (b : Prop) -> (c : Decidable a) -> Iff (ite Prop a c False b) (And (Not a) b)
  (a : Prop) => (b : Prop) => (c : Decidable a) => Decidable.casesOn a ((d : Decidable a) => (Eq (Decidable a) c d -> Iff (ite Prop a c False b) (And (Not a) b))) c ((e : Not a) => (f : Eq (Decidable a) c (Decidable.isFalse a e)) => Eq.ndrec (Decidable a) (Decidable.isFalse a e) ((g : Decidable a) => Iff (ite Prop a g False b) (And (Not a) b)) (of_eq_true (Iff (ite Prop a (Decidable.isFalse a e) False b) (And (Not a) b)) (Eq.trans Prop (Iff (ite Prop a (Decidable.isFalse a e) False b) (And (Not a) b)) (Iff b b) True (congr Prop Prop (Iff (ite Prop a (Decidable.isFalse a e) False b)) (Iff b) (And (Not a) b) b (congrArg Prop ((h : Prop) -> Prop) (ite Prop a (Decidable.isFalse a e) False b) b Iff (ite_cond_eq_false Prop a (Decidable.isFalse a e) False b (eq_false a e))) (Eq.trans Prop (And (Not a) b) (And True b) b (congrArg Prop Prop (Not a) True ((i : Prop) => And i b) (Eq.trans Prop (Not a) (Not False) True (congrArg Prop Prop a False Not (eq_false a e)) not_false_eq_true)) (true_and b))) (iff_self b))) c (Eq.symm (Decidable a) c (Decidable.isFalse a e) f)) ((j : a) => (k : Eq (Decidable a) c (Decidable.isTrue a j)) => Eq.ndrec (Decidable a) (Decidable.isTrue a j) ((l : Decidable a) => Iff (ite Prop a l False b) (And (Not a) b)) (of_eq_true (Iff (ite Prop a (Decidable.isTrue a j) False b) (And (Not a) b)) (Eq.trans Prop (Iff (ite Prop a (Decidable.isTrue a j) False b) (And (Not a) b)) (Iff False False) True (congr Prop Prop (Iff (ite Prop a (Decidable.isTrue a j) False b)) (Iff False) (And (Not a) b) False (congrArg Prop ((m : Prop) -> Prop) (ite Prop a (Decidable.isTrue a j) False b) False Iff (ite_cond_eq_true Prop a (Decidable.isTrue a j) False b (eq_true a j))) (Eq.trans Prop (And (Not a) b) (And False b) False (congrArg Prop Prop (Not a) False ((n : Prop) => And n b) (Eq.trans Prop (Not a) (Not True) False (congrArg Prop Prop a True Not (eq_true a j)) not_true_eq_false)) (false_and b))) (iff_self False))) c (Eq.symm (Decidable a) c (Decidable.isTrue a j) k)) (Eq.refl (Decidable a) c)
thm if_false_right : (a : Prop) -> (b : Prop) -> (c : Decidable a) -> Iff (ite Prop a c b False) (And a b)
  (a : Prop) => (b : Prop) => (c : Decidable a) => Decidable.casesOn a ((d : Decidable a) => (Eq (Decidable a) c d -> Iff (ite Prop a c b False) (And a b))) c ((e : Not a) => (f : Eq (Decidable a) c (Decidable.isFalse a e)) => Eq.ndrec (Decidable a) (Decidable.isFalse a e) ((g : Decidable a) => Iff (ite Prop a g b False) (And a b)) (of_eq_true (Iff (ite Prop a (Decidable.isFalse a e) b False) (And a b)) (Eq.trans Prop (Iff (ite Prop a (Decidable.isFalse a e) b False) (And a b)) (Iff False False) True (congr Prop Prop (Iff (ite Prop a (Decidable.isFalse a e) b False)) (Iff False) (And a b) False (congrArg Prop ((h : Prop) -> Prop) (ite Prop a (Decidable.isFalse a e) b False) False Iff (ite_cond_eq_false Prop a (Decidable.isFalse a e) b False (eq_false a e))) (Eq.trans Prop (And a b) (And False b) False (congrArg Prop Prop a False ((i : Prop) => And i b) (eq_false a e)) (false_and b))) (iff_self False))) c (Eq.symm (Decidable a) c (Decidable.isFalse a e) f)) ((j : a) => (k : Eq (Decidable a) c (Decidable.isTrue a j)) => Eq.ndrec (Decidable a) (Decidable.isTrue a j) ((l : Decidable a) => Iff (ite Prop a l b False) (And a b)) (of_eq_true (Iff (ite Prop a (Decidable.isTrue a j) b False) (And a b)) (Eq.trans Prop (Iff (ite Prop a (Decidable.isTrue a j) b False) (And a b)) (Iff b b) True (congr Prop Prop (Iff (ite Prop a (Decidable.isTrue a j) b False)) (Iff b) (And a b) b (congrArg Prop ((m : Prop) -> Prop) (ite Prop a (Decidable.isTrue a j) b False) b Iff (ite_cond_eq_true Prop a (Decidable.isTrue a j) b False (eq_true a j))) (Eq.trans Prop (And a b) (And True b) b (congrArg Prop Prop a True ((n : Prop) => And n b) (eq_true a j)) (true_and b))) (iff_self b))) c (Eq.symm (Decidable a) c (Decidable.isTrue a j) k)) (Eq.refl (Decidable a) c)
thm implies_congr : (s0 : Sort(u)) -> (s1 : Sort(u)) -> (s2 : Sort(v)) -> (s3 : Sort(v)) -> Eq Sort(u) s0 s1 -> Eq Sort(v) s2 s3 -> Eq Sort(IMax(u,v)) (s0 -> s2) (s1 -> s3)
  (s0 : Sort(u)) => (s1 : Sort(u)) => (s2 : Sort(v)) => (s3 : Sort(v)) => (a : Eq Sort(u) s0 s1) => (b : Eq Sort(v) s2 s3) => Eq.rec Sort(u) s0 ((s4 : Sort(u)) => Eq Sort(u) s0 s4 => Eq Sort(IMax(u,v)) (s0 -> s2) (s4 -> s3)) (Eq.rec Sort(v) s2 ((s5 : Sort(v)) => Eq Sort(v) s2 s5 => Eq Sort(IMax(u,v)) (s0 -> s2) (s0 -> s5)) (rfl Sort(IMax(u,v)) (s0 -> s2)) s3 b) s1 a
thm true_implies : (a : Prop) -> Eq Prop (True -> a) a
  (a : Prop) => propext (True -> a) a (Iff.intro (True -> a) a ((f0 : True -> a) => f0 trivial) ((b : a) => True => b))
thm false_implies : (a : Prop) -> Eq Prop (False -> a) True
  (a : Prop) => eq_true (False -> a) (False.elim a)
thm if_true_left : (a : Prop) -> (b : Prop) -> (c : Decidable a) -> Iff (ite Prop a c True b) (Not a -> b)
  (a : Prop) => (b : Prop) => (c : Decidable a) => Decidable.casesOn a ((d : Decidable a) => (Eq (Decidable a) c d -> Iff (ite Prop a c True b) (Not a -> b))) c ((e : Not a) => (f : Eq (Decidable a) c (Decidable.isFalse a e)) => Eq.ndrec (Decidable a) (Decidable.isFalse a e) ((g : Decidable a) => Iff (ite Prop a g True b) (Not a -> b)) (of_eq_true (Iff (ite Prop a (Decidable.isFalse a e) True b) (Not a -> b)) (Eq.trans Prop (Iff (ite Prop a (Decidable.isFalse a e) True b) (Not a -> b)) (Iff b b) True (congr Prop Prop (Iff (ite Prop a (Decidable.isFalse a e) True b)) (Iff b) (Not a -> b) b (congrArg Prop ((h : Prop) -> Prop) (ite Prop a (Decidable.isFalse a e) True b) b Iff (ite_cond_eq_false Prop a (Decidable.isFalse a e) True b (eq_false a e))) (Eq.trans Prop (Not a -> b) (True -> b) b (implies_congr (Not a) True b b (Eq.trans Prop (Not a) (Not False) True (congrArg Prop Prop a False Not (eq_false a e)) not_false_eq_true) (Eq.refl Prop b)) (true_implies b))) (iff_self b))) c (Eq.symm (Decidable a) c (Decidable.isFalse a e) f)) ((i : a) => (j : Eq (Decidable a) c (Decidable.isTrue a i)) => Eq.ndrec (Decidable a) (Decidable.isTrue a i) ((k : Decidable a) => Iff (ite Prop a k True b) (Not a -> b)) (of_eq_true (Iff (ite Prop a (Decidable.isTrue a i) True b) (Not a -> b)) (Eq.trans Prop (Iff (ite Prop a (Decidable.isTrue a i) True b) (Not a -> b)) (Iff True True) True (congr Prop Prop (Iff (ite Prop a (Decidable.isTrue a i) True b)) (Iff True) (Not a -> b) True (congrArg Prop ((l : Prop) -> Prop) (ite Prop a (Decidable.isTrue a i) True b) True Iff (ite_cond_eq_true Prop a (Decidable.isTrue a i) True b (eq_true a i))) (Eq.trans Prop (Not a -> b) (False -> b) True (implies_congr (Not a) False b b (Eq.trans Prop (Not a) (Not True) False (congrArg Prop Prop a True Not (eq_true a i)) not_true_eq_false) (Eq.refl Prop b)) (false_implies b))) (iff_self True))) c (Eq.symm (Decidable a) c (Decidable.isTrue a i) j)) (Eq.refl (Decidable a) c)
thm if_true_right : (a : Prop) -> (b : Prop) -> (c : Decidable a) -> Iff (ite Prop a c b True) (a -> b)
  (a : Prop) => (b : Prop) => (c : Decidable a) => Decidable.casesOn a ((d : Decidable a) => (Eq (Decidable a) c d -> Iff (ite Prop a c b True) (a -> b))) c ((e : Not a) => (f : Eq (Decidable a) c (Decidable.isFalse a e)) => Eq.ndrec (Decidable a) (Decidable.isFalse a e) ((g : Decidable a) => Iff (ite Prop a g b True) (a -> b)) (of_eq_true (Iff (ite Prop a (Decidable.isFalse a e) b True) (a -> b)) (Eq.trans Prop (Iff (ite Prop a (Decidable.isFalse a e) b True) (a -> b)) (Iff True True) True (congr Prop Prop (Iff (ite Prop a (Decidable.isFalse a e) b True)) (Iff True) (a -> b) True (congrArg Prop ((h : Prop) -> Prop) (ite Prop a (Decidable.isFalse a e) b True) True Iff (ite_cond_eq_false Prop a (Decidable.isFalse a e) b True (eq_false a e))) (Eq.trans Prop (a -> b) (False -> b) True (implies_congr a False b b (eq_false a e) (Eq.refl Prop b)) (false_implies b))) (iff_self True))) c (Eq.symm (Decidable a) c (Decidable.isFalse a e) f)) ((i : a) => (j : Eq (Decidable a) c (Decidable.isTrue a i)) => Eq.ndrec (Decidable a) (Decidable.isTrue a i) ((k : Decidable a) => Iff (ite Prop a k b True) (a -> b)) (of_eq_true (Iff (ite Prop a (Decidable.isTrue a i) b True) (a -> b)) (Eq.trans Prop (Iff (ite Prop a (Decidable.isTrue a i) b True) (a -> b)) (Iff b b) True (congr Prop Prop (Iff (ite Prop a (Decidable.isTrue a i) b True)) (Iff b) (a -> b) b (congrArg Prop ((l : Prop) -> Prop) (ite Prop a (Decidable.isTrue a i) b True) b Iff (ite_cond_eq_true Prop a (Decidable.isTrue a i) b True (eq_true a i))) (Eq.trans Prop (a -> b) (True -> b) b (implies_congr a True b b (eq_true a i) (Eq.refl Prop b)) (true_implies b))) (iff_self b))) c (Eq.symm (Decidable a) c (Decidable.isTrue a i) j)) (Eq.refl (Decidable a) c)
thm ite_then_self : (a : Prop) -> (b : Prop) -> (c : Decidable a) -> Iff (ite Prop a c a b) (Not a -> b)
  (a : Prop) => (b : Prop) => (c : Decidable a) => Decidable.casesOn a ((d : Decidable a) => (Eq (Decidable a) c d -> Iff (ite Prop a c a b) (Not a -> b))) c ((e : Not a) => (f : Eq (Decidable a) c (Decidable.isFalse a e)) => Eq.ndrec (Decidable a) (Decidable.isFalse a e) ((g : Decidable a) => Iff (ite Prop a g a b) (Not a -> b)) (of_eq_true (Iff (ite Prop a (Decidable.isFalse a e) a b) (Not a -> b)) (Eq.trans Prop (Iff (ite Prop a (Decidable.isFalse a e) a b) (Not a -> b)) (Iff b b) True (congr Prop Prop (Iff (ite Prop a (Decidable.isFalse a e) a b)) (Iff b) (Not a -> b) b (congrArg Prop ((h : Prop) -> Prop) (ite Prop a (Decidable.isFalse a e) a b) b Iff (ite_cond_eq_false Prop a (Decidable.isFalse a e) a b (eq_false a e))) (Eq.trans Prop (Not a -> b) (True -> b) b (implies_congr (Not a) True b b (Eq.trans Prop (Not a) (Not False) True (congrArg Prop Prop a False Not (eq_false a e)) not_false_eq_true) (Eq.refl Prop b)) (true_implies b))) (iff_self b))) c (Eq.symm (Decidable a) c (Decidable.isFalse a e) f)) ((i : a) => (j : Eq (Decidable a) c (Decidable.isTrue a i)) => Eq.ndrec (Decidable a) (Decidable.isTrue a i) ((k : Decidable a) => Iff (ite Prop a k a b) (Not a -> b)) (of_eq_true (Iff (ite Prop a (Decidable.isTrue a i) a b) (Not a -> b)) (Eq.trans Prop (Iff (ite Prop a (Decidable.isTrue a i) a b) (Not a -> b)) (Iff True True) True (congr Prop Prop (Iff (ite Prop a (Decidable.isTrue a i) a b)) (Iff True) (Not a -> b) True (congrArg Prop ((l : Prop) -> Prop) (ite Prop a (Decidable.isTrue a i) a b) True Iff (Eq.trans Prop (ite Prop a (Decidable.isTrue a i) a b) a True (ite_cond_eq_true Prop a (Decidable.isTrue a i) a b (eq_true a i)) (eq_true a i))) (Eq.trans Prop (Not a -> b) (False -> b) True (implies_congr (Not a) False b b (Eq.trans Prop (Not a) (Not True) False (congrArg Prop Prop a True Not (eq_true a i)) not_true_eq_false) (Eq.refl Prop b)) (false_implies b))) (iff_self True))) c (Eq.symm (Decidable a) c (Decidable.isTrue a i) j)) (Eq.refl (Decidable a) c)
thm ite_true_same : (a : Prop) -> (b : Prop) -> (c : Decidable a) -> Iff (ite Prop a c a b) (Not a -> b)
  (a : Prop) => (b : Prop) => (c : Decidable a) => ite_then_self a b c
thm ite_else_self : (a : Prop) -> (b : Prop) -> (c : Decidable a) -> Iff (ite Prop a c b a) (And a b)
  (a : Prop) => (b : Prop) => (c : Decidable a) => Decidable.casesOn a ((d : Decidable a) => (Eq (Decidable a) c d -> Iff (ite Prop a c b a) (And a b))) c ((e : Not a) => (f : Eq (Decidable a) c (Decidable.isFalse a e)) => Eq.ndrec (Decidable a) (Decidable.isFalse a e) ((g : Decidable a) => Iff (ite Prop a g b a) (And a b)) (of_eq_true (Iff (ite Prop a (Decidable.isFalse a e) b a) (And a b)) (Eq.trans Prop (Iff (ite Prop a (Decidable.isFalse a e) b a) (And a b)) (Iff False False) True (congr Prop Prop (Iff (ite Prop a (Decidable.isFalse a e) b a)) (Iff False) (And a b) False (congrArg Prop ((h : Prop) -> Prop) (ite Prop a (Decidable.isFalse a e) b a) False Iff (Eq.trans Prop (ite Prop a (Decidable.isFalse a e) b a) a False (ite_cond_eq_false Prop a (Decidable.isFalse a e) b a (eq_false a e)) (eq_false a e))) (Eq.trans Prop (And a b) (And False b) False (congrArg Prop Prop a False ((i : Prop) => And i b) (eq_false a e)) (false_and b))) (iff_self False))) c (Eq.symm (Decidable a) c (Decidable.isFalse a e) f)) ((j : a) => (k : Eq (Decidable a) c (Decidable.isTrue a j)) => Eq.ndrec (Decidable a) (Decidable.isTrue a j) ((l : Decidable a) => Iff (ite Prop a l b a) (And a b)) (of_eq_true (Iff (ite Prop a (Decidable.isTrue a j) b a) (And a b)) (Eq.trans Prop (Iff (ite Prop a (Decidable.isTrue a j) b a) (And a b)) (Iff b b) True (congr Prop Prop (Iff (ite Prop a (Decidable.isTrue a j) b a)) (Iff b) (And a b) b (congrArg Prop ((m : Prop) -> Prop) (ite Prop a (Decidable.isTrue a j) b a) b Iff (ite_cond_eq_true Prop a (Decidable.isTrue a j) b a (eq_true a j))) (Eq.trans Prop (And a b) (And True b) b (congrArg Prop Prop a True ((n : Prop) => And n b) (eq_true a j)) (true_and b))) (iff_self b))) c (Eq.symm (Decidable a) c (Decidable.isTrue a j) k)) (Eq.refl (Decidable a) c)
thm ite_false_same : (a : Prop) -> (b : Prop) -> (c : Decidable a) -> Iff (ite Prop a c b a) (And a b)
  (a : Prop) => (b : Prop) => (c : Decidable a) => ite_else_self a b c
thm forall_imp : (s0 : Sort(u_1)) -> (f0 : s0 -> Prop) -> (f1 : s0 -> Prop) -> ((a : s0) -> f0 a -> f1 a) -> ((b : s0) -> f0 b) -> (c : s0) -> f1 c
  (s0 : Sort(u_1)) => (f0 : s0 -> Prop) => (f1 : s0 -> Prop) => (f2 : (a : s0) -> f0 a -> f1 a) => (f3 : (b : s0) -> f0 b) => (c : s0) => f2 c (f3 c)
def Exists : (s0 : Sort(u)) -> (s0 -> Prop) -> Prop
def Exists.intro : (s0 : Sort(u)) -> (f0 : s0 -> Prop) -> (a : s0) -> f0 a -> Exists s0 f0
def Exists.rec : (s0 : Sort(u)) -> (f0 : s0 -> Prop) -> (f1 : Exists s0 f0 -> Prop) -> ((a : s0) -> (b : f0 a) -> f1 (Exists.intro s0 f0 a b)) -> (c : Exists s0 f0) -> f1 c
def Exists.casesOn := (s0 : Sort(u)) => (f0 : s0 -> Prop) => (f1 : Exists s0 f0 -> Prop) => (a : Exists s0 f0) => (f2 : (b : s0) -> (c : f0 b) -> f1 (Exists.intro s0 f0 b c)) => Exists.rec s0 f0 f1 ((d : s0) => (e : f0 d) => f2 d e) a
def forall_exists_index.match_1 := (s0 : Sort(u_1)) => (f0 : s0 -> Prop) => (f1 : Exists s0 ((a : s0) => f0 a) -> Prop) => (b : Exists s0 ((c : s0) => f0 c)) => (f2 : (d : s0) -> (e : f0 d) -> f1 (Exists.intro s0 ((f : s0) => f0 f) d e)) => Exists.casesOn s0 ((g : s0) => f0 g) ((h : Exists s0 ((i : s0) => f0 i)) => f1 h) b ((j : s0) => (k : f0 j) => f2 j k)
thm Exists.imp : (s0 : Sort(u_1)) -> (f0 : s0 -> Prop) -> (f1 : s0 -> Prop) -> ((a : s0) -> f0 a -> f1 a) -> Exists s0 ((b : s0) => f0 b) -> Exists s0 ((c : s0) => f1 c)
  (s0 : Sort(u_1)) => (f0 : s0 -> Prop) => (f1 : s0 -> Prop) => (f2 : (a : s0) -> f0 a -> f1 a) => (b : Exists s0 ((c : s0) => f0 c)) => forall_exists_index.match_1 s0 f0 (Exists s0 ((d : s0) => f0 d) => Exists s0 ((e : s0) => f1 e)) b ((f : s0) => (g : f0 f) => Exists.intro s0 ((h : s0) => f1 h) f (f2 f g))
thm Exists.imp' : (s0 : Sort(u_2)) -> (f0 : s0 -> Prop) -> (s1 : Sort(u_1)) -> (f1 : s1 -> Prop) -> (f2 : s0 -> s1) -> ((a : s0) -> f0 a -> f1 (f2 a)) -> Exists s0 ((b : s0) => f0 b) -> Exists s1 ((c : s1) => f1 c)
  (s0 : Sort(u_2)) => (f0 : s0 -> Prop) => (s1 : Sort(u_1)) => (f1 : s1 -> Prop) => (f2 : s0 -> s1) => (f3 : (a : s0) -> f0 a -> f1 (f2 a)) => (b : Exists s0 ((c : s0) => f0 c)) => forall_exists_index.match_1 s0 f0 (Exists s0 ((d : s0) => f0 d) => Exists s1 ((e : s1) => f1 e)) b ((f : s0) => (g : f0 f) => Exists.intro s1 ((h : s1) => f1 h) (f2 f) (f3 f g))
thm forall_exists_index : (s0 : Sort(u_1)) -> (f0 : s0 -> Prop) -> (f1 : Exists s0 ((a : s0) => f0 a) -> Prop) -> Iff ((b : Exists s0 ((c : s0) => f0 c)) -> f1 b) ((d : s0) -> (e : f0 d) -> f1 (Exists.intro s0 ((f : s0) => f0 f) d e))
  (s0 : Sort(u_1)) => (f0 : s0 -> Prop) => (f1 : Exists s0 ((a : s0) => f0 a) -> Prop) => Iff.intro ((b : Exists s0 ((c : s0) => f0 c)) -> f1 b) ((d : s0) -> (e : f0 d) -> f1 (Exists.intro s0 ((f : s0) => f0 f) d e)) ((f2 : (g : Exists s0 ((h : s0) => f0 h)) -> f1 g) => (i : s0) => (j : f0 i) => f2 (Exists.intro s0 ((k : s0) => f0 k) i j)) ((f3 : (l : s0) -> (m : f0 l) -> f1 (Exists.intro s0 ((n : s0) => f0 n) l m)) => (o : Exists s0 ((p : s0) => f0 p)) => forall_exists_index.match_1 s0 f0 ((q : Exists s0 ((r : s0) => f0 r)) => f1 q) o ((s : s0) => (t : f0 s) => f3 s t))
thm exists_imp : (s0 : Sort(u_1)) -> (f0 : s0 -> Prop) -> (a : Prop) -> Iff (Exists s0 ((b : s0) => f0 b) -> a) ((c : s0) -> f0 c -> a)
  (s0 : Sort(u_1)) => (f0 : s0 -> Prop) => (a : Prop) => forall_exists_index s0 f0 (Exists s0 ((b : s0) => f0 b) => a)
thm Init.PropLemmas._auxLemma.15 : (s0 : Sort(u_1)) -> (f0 : s0 -> Prop) -> (f1 : Exists s0 ((a : s0) => f0 a) -> Prop) -> Eq Prop ((b : Exists s0 ((c : s0) => f0 c)) -> f1 b) ((d : s0) -> (e : f0 d) -> f1 (Exists.intro s0 ((f : s0) => f0 f) d e))
  (s0 : Sort(u_1)) => (f0 : s0 -> Prop) => (f1 : Exists s0 ((a : s0) => f0 a) -> Prop) => propext ((b : Exists s0 ((c : s0) => f0 c)) -> f1 b) ((d : s0) -> (e : f0 d) -> f1 (Exists.intro s0 ((f : s0) => f0 f) d e)) (forall_exists_index s0 f0 f1)
thm funext : (s0 : Sort(u)) -> (f0 : s0 -> Sort(v)) -> (f1 : (a : s0) -> f0 a) -> (f2 : (b : s0) -> f0 b) -> ((c : s0) -> Eq (f0 c) (f1 c) (f2 c)) -> Eq ((d : s0) -> f0 d) f1 f2
thm forall_congr : (s0 : Sort(u)) -> (f0 : s0 -> Prop) -> (f1 : s0 -> Prop) -> ((a : s0) -> Eq Prop (f0 a) (f1 a)) -> Eq Prop ((b : s0) -> f0 b) ((c : s0) -> f1 c)
  (s0 : Sort(u)) => (f0 : s0 -> Prop) => (f1 : s0 -> Prop) => (f2 : (a : s0) -> Eq Prop (f0 a) (f1 a)) => Eq.rec ((b : s0) -> Prop) f0 ((f3 : (c : s0) -> Prop) => Eq (s0 -> Prop) f0 f3 => Eq Prop ((d : s0) -> f0 d) ((e : s0) -> f3 e)) (rfl Prop ((f : s0) -> f0 f)) f1 (funext s0 ((g : s0) => Prop) f0 f1 f2)
thm exists_imp : (s0 : Sort(u_1)) -> (f0 : s0 -> Prop) -> (a : Prop) -> (f1 : (b : s0) -> f0 b -> Prop) -> Iff (Exists s0 ((c : s0) => Exists (f0 c) ((d : f0 c) => f1 c d)) -> a) ((e : s0) -> (f : f0 e) -> f1 e f -> a)
  (s0 : Sort(u_1)) => (f0 : s0 -> Prop) => (a : Prop) => (f1 : (b : s0) -> f0 b -> Prop) => of_eq_true (Iff (Exists s0 ((c : s0) => Exists (f0 c) ((d : f0 c) => f1 c d)) -> a) ((e : s0) -> (f : f0 e) -> f1 e f -> a)) (Eq.trans Prop (Iff (Exists s0 ((g : s0) => Exists (f0 g) ((h : f0 g) => f1 g h)) -> a) ((i : s0) -> (j : f0 i) -> f1 i j -> a)) (Iff ((k : s0) -> (l : f0 k) -> f1 k l -> a) ((m : s0) -> (n : f0 m) -> f1 m n -> a)) True (congrArg Prop Prop (Exists s0 ((o : s0) => Exists (f0 o) ((p : f0 o) => f1 o p)) -> a) ((q : s0) -> (r : f0 q) -> f1 q r -> a) ((s : Prop) => Iff s ((t : s0) -> (u : f0 t) -> f1 t u -> a)) (Eq.trans Prop (Exists s0 ((v : s0) => Exists (f0 v) ((w : f0 v) => f1 v w)) -> a) ((x : s0) -> Exists (f0 x) ((y : f0 x) => f1 x y) -> a) ((z : s0) -> (A : f0 z) -> f1 z A -> a) (Init.PropLemmas._auxLemma.15 s0 ((B : s0) => Exists (f0 B) ((C : f0 B) => f1 B C)) (Exists s0 ((D : s0) => Exists (f0 D) ((E : f0 D) => f1 D E)) => a)) (forall_congr s0 ((F : s0) => (Exists (f0 F) ((G : f0 F) => f1 F G) -> a)) ((H : s0) => ((I : f0 H) -> f1 H I -> a)) ((J : s0) => Init.PropLemmas._auxLemma.15 (f0 J) (f1 J) (Exists (f0 J) ((K : f0 J) => f1 J K) => a))))) (iff_self ((L : s0) -> (M : f0 L) -> f1 L M -> a)))
def exists_prop_congr.match_1 := (a : Prop) => (f0 : a -> Prop) => (f1 : Exists a f0 -> Prop) => (b : Exists a f0) => (f2 : (c : a) -> (d : f0 c) -> f1 (Exists.intro a f0 c d)) => Exists.casesOn a f0 ((e : Exists a f0) => f1 e) b ((f : a) => (g : f0 f) => f2 f g)
def exists_prop_congr.match_2 := (a : Prop) => (b : Prop) => (f0 : a -> Prop) => (c : Iff a b) => (f1 : Exists b ((d : b) => f0 (Iff.mpr a b c d)) -> Prop) => (e : Exists b ((f : b) => f0 (Iff.mpr a b c f))) => (f2 : (g : b) -> (h : f0 (Iff.mpr a b c g)) -> f1 (Exists.intro b ((i : b) => f0 (Iff.mpr a b c i)) g h)) => Exists.casesOn b ((j : b) => f0 (Iff.mpr a b c j)) ((k : Exists b ((l : b) => f0 (Iff.mpr a b c l))) => f1 k) e ((m : b) => (n : f0 (Iff.mpr a b c m)) => f2 m n)
thm exists_prop_congr : (a : Prop) -> (b : Prop) -> (f0 : a -> Prop) -> (f1 : a -> Prop) -> ((c : a) -> Iff (f0 c) (f1 c)) -> (d : Iff a b) -> Iff (Exists a f0) (Exists b ((e : b) => f1 (Iff.mpr a b d e)))
  (a : Prop) => (b : Prop) => (f0 : a -> Prop) => (f1 : a -> Prop) => (f2 : (c : a) -> Iff (f0 c) (f1 c)) => (d : Iff a b) => Iff.intro (Exists a f0) (Exists b ((e : b) => f1 (Iff.mpr a b d e))) ((f : Exists a f0) => exists_prop_congr.match_1 a f0 (Exists a f0 => Exists b ((g : b) => f1 (Iff.mpr a b d g))) f ((h : a) => (i : f0 h) => Exists.intro b ((j : b) => f1 (Iff.mpr a b d j)) (Iff.mp a b d h) (Iff.mp (f0 (Iff.mpr a b d (Iff.mp a b d h))) (f1 (Iff.mpr a b d (Iff.mp a b d h))) (f2 (Iff.mpr a b d (Iff.mp a b d h))) i))) ((k : Exists b ((l : b) => f1 (Iff.mpr a b d l))) => exists_prop_congr.match_2 a b f1 d (Exists b ((m : b) => f1 (Iff.mpr a b d m)) => Exists a f0) k ((n : b) => (o : f1 (Iff.mpr a b d n)) => Exists.intro a f0 (Iff.mpr a b d n) (Iff.mpr (f0 (Iff.mpr a b d n)) (f1 (Iff.mpr a b d n)) (f2 (Iff.mpr a b d n)) o)))
def Nonempty : Sort(u) -> Prop
def exists_const.match_1 := (a : Prop) => (s0 : Sort(u_1)) => (f0 : Exists s0 (s0 => a) -> Prop) => (b : Exists s0 (s0 => a)) => (f1 : (c : s0) -> (d : a) -> f0 (Exists.intro s0 ((e : s0) => a) c d)) => Exists.casesOn s0 ((f : s0) => a) ((g : Exists s0 ((h : s0) => a)) => f0 g) b ((i : s0) => (j : a) => f1 i j)
def Nonempty.intro : (s0 : Sort(u)) -> s0 -> Nonempty s0
def Nonempty.rec : (s0 : Sort(u)) -> (f0 : Nonempty s0 -> Prop) -> ((a : s0) -> f0 (Nonempty.intro s0 a)) -> (b : Nonempty s0) -> f0 b
def Nonempty.casesOn := (s0 : Sort(u)) => (f0 : Nonempty s0 -> Prop) => (a : Nonempty s0) => (f1 : (b : s0) -> f0 (Nonempty.intro s0 b)) => Nonempty.rec s0 f0 ((c : s0) => f1 c) a
def Nonempty.elim.match_1 := (s0 : Sort(u_1)) => (f0 : Nonempty s0 -> Prop) => (a : Nonempty s0) => (f1 : (b : s0) -> f0 (Nonempty.intro s0 b)) => Nonempty.casesOn s0 ((c : Nonempty s0) => f0 c) a ((d : s0) => f1 d)
thm Nonempty.elim : (s0 : Sort(u)) -> (a : Prop) -> Nonempty s0 -> (s0 -> a) -> a
  (s0 : Sort(u)) => (a : Prop) => (b : Nonempty s0) => (f0 : s0 -> a) => Nonempty.elim.match_1 s0 (Nonempty s0 => a) b ((c : s0) => f0 c)
thm exists_const : (a : Prop) -> (s0 : Sort(u_1)) -> Nonempty s0 -> Iff (Exists s0 (s0 => a)) a
  (a : Prop) => (s0 : Sort(u_1)) => (b : Nonempty s0) => Iff.intro (Exists s0 (s0 => a)) a ((c : Exists s0 (s0 => a)) => exists_const.match_1 a s0 (Exists s0 (s0 => a) => a) c (s0 => (d : a) => d)) (Nonempty.elim s0 (a -> Exists s0 (s0 => a)) b (Exists.intro s0 (s0 => a)))
thm exists_prop_of_true : (a : Prop) -> (f0 : a -> Prop) -> (b : a) -> Iff (Exists a ((c : a) => f0 c)) (f0 b)
  (a : Prop) => (f0 : a -> Prop) => (b : a) => exists_const (f0 b) a (Nonempty.intro a b)
thm forall_congr' : (s0 : Sort(u_1)) -> (f0 : s0 -> Prop) -> (f1 : s0 -> Prop) -> ((a : s0) -> Iff (f0 a) (f1 a)) -> Iff ((b : s0) -> f0 b) ((c : s0) -> f1 c)
  (s0 : Sort(u_1)) => (f0 : s0 -> Prop) => (f1 : s0 -> Prop) => (f2 : (a : s0) -> Iff (f0 a) (f1 a)) => Iff.intro ((b : s0) -> f0 b) ((c : s0) -> f1 c) ((f3 : (d : s0) -> f0 d) => (e : s0) => Iff.mp (f0 e) (f1 e) (f2 e) (f3 e)) ((f4 : (f : s0) -> f1 f) => (g : s0) => Iff.mpr (f0 g) (f1 g) (f2 g) (f4 g))
thm exists_congr : (s0 : Sort(u_1)) -> (f0 : s0 -> Prop) -> (f1 : s0 -> Prop) -> ((a : s0) -> Iff (f0 a) (f1 a)) -> Iff (Exists s0 ((b : s0) => f0 b)) (Exists s0 ((c : s0) => f1 c))
  (s0 : Sort(u_1)) => (f0 : s0 -> Prop) => (f1 : s0 -> Prop) => (f2 : (a : s0) -> Iff (f0 a) (f1 a)) => Iff.intro (Exists s0 ((b : s0) => f0 b)) (Exists s0 ((c : s0) => f1 c)) (Exists.imp s0 f0 f1 ((d : s0) => Iff.mp (f0 d) (f1 d) (f2 d))) (Exists.imp s0 f1 f0 ((e : s0) => Iff.mpr (f0 e) (f1 e) (f2 e)))
thm forall_congr : (s0 : Sort(u_1)) -> (f0 : s0 -> Sort(u_2)) -> (f1 : (a : s0) -> f0 a -> Prop) -> (f2 : (b : s0) -> f0 b -> Prop) -> ((c : s0) -> (d : f0 c) -> Iff (f1 c d) (f2 c d)) -> Iff ((e : s0) -> (f : f0 e) -> f1 e f) ((g : s0) -> (h : f0 g) -> f2 g h)
  (s0 : Sort(u_1)) => (f0 : s0 -> Sort(u_2)) => (f1 : (a : s0) -> f0 a -> Prop) => (f2 : (b : s0) -> f0 b -> Prop) => (f3 : (c : s0) -> (d : f0 c) -> Iff (f1 c d) (f2 c d)) => forall_congr' s0 ((e : s0) => ((f : f0 e) -> f1 e f)) ((g : s0) => ((h : f0 g) -> f2 g h)) ((i : s0) => forall_congr' (f0 i) (f1 i) (f2 i) (f3 i))
thm exists_congr : (s0 : Sort(u_1)) -> (f0 : s0 -> Sort(u_2)) -> (f1 : (a : s0) -> f0 a -> Prop) -> (f2 : (b : s0) -> f0 b -> Prop) -> ((c : s0) -> (d : f0 c) -> Iff (f1 c d) (f2 c d)) -> Iff (Exists s0 ((e : s0) => Exists (f0 e) ((f : f0 e) => f1 e f))) (Exists s0 ((g : s0) => Exists (f0 g) ((h : f0 g) => f2 g h)))
  (s0 : Sort(u_1)) => (f0 : s0 -> Sort(u_2)) => (f1 : (a : s0) -> f0 a -> Prop) => (f2 : (b : s0) -> f0 b -> Prop) => (f3 : (c : s0) -> (d : f0 c) -> Iff (f1 c d) (f2 c d)) => exists_congr s0 ((e : s0) => Exists (f0 e) ((f : f0 e) => f1 e f)) ((g : s0) => Exists (f0 g) ((h : f0 g) => f2 g h)) ((i : s0) => exists_congr (f0 i) (f1 i) (f2 i) (f3 i))
thm forall_congr : (s0 : Sort(u_1)) -> (f0 : s0 -> Sort(u_2)) -> (f1 : (a : s0) -> f0 a -> Sort(u_3)) -> (f2 : (b : s0) -> (c : f0 b) -> f1 b c -> Prop) -> (f3 : (d : s0) -> (e : f0 d) -> f1 d e -> Prop) -> ((f : s0) -> (g : f0 f) -> (h : f1 f g) -> Iff (f2 f g h) (f3 f g h)) -> Iff ((i : s0) -> (j : f0 i) -> (k : f1 i j) -> f2 i j k) ((l : s0) -> (m : f0 l) -> (n : f1 l m) -> f3 l m n)
  (s0 : Sort(u_1)) => (f0 : s0 -> Sort(u_2)) => (f1 : (a : s0) -> f0 a -> Sort(u_3)) => (f2 : (b : s0) -> (c : f0 b) -> f1 b c -> Prop) => (f3 : (d : s0) -> (e : f0 d) -> f1 d e -> Prop) => (f4 : (f : s0) -> (g : f0 f) -> (h : f1 f g) -> Iff (f2 f g h) (f3 f g h)) => forall_congr' s0 ((i : s0) => ((j : f0 i) -> (k : f1 i j) -> f2 i j k)) ((l : s0) => ((m : f0 l) -> (n : f1 l m) -> f3 l m n)) ((o : s0) => forall_congr (f0 o) (f1 o) (f2 o) (f3 o) (f4 o))
thm exists_congr : (s0 : Sort(u_1)) -> (f0 : s0 -> Sort(u_2)) -> (f1 : (a : s0) -> f0 a -> Sort(u_3)) -> (f2 : (b : s0) -> (c : f0 b) -> f1 b c -> Prop) -> (f3 : (d : s0) -> (e : f0 d) -> f1 d e -> Prop) -> ((f : s0) -> (g : f0 f) -> (h : f1 f g) -> Iff (f2 f g h) (f3 f g h)) -> Iff (Exists s0 ((i : s0) => Exists (f0 i) ((j : f0 i) => Exists (f1 i j) ((k : f1 i j) => f2 i j k)))) (Exists s0 ((l : s0) => Exists (f0 l) ((m : f0 l) => Exists (f1 l m) ((n : f1 l m) => f3 l m n))))
  (s0 : Sort(u_1)) => (f0 : s0 -> Sort(u_2)) => (f1 : (a : s0) -> f0 a -> Sort(u_3)) => (f2 : (b : s0) -> (c : f0 b) -> f1 b c -> Prop) => (f3 : (d : s0) -> (e : f0 d) -> f1 d e -> Prop) => (f4 : (f : s0) -> (g : f0 f) -> (h : f1 f g) -> Iff (f2 f g h) (f3 f g h)) => exists_congr s0 ((i : s0) => Exists (f0 i) ((j : f0 i) => Exists (f1 i j) ((k : f1 i j) => f2 i j k))) ((l : s0) => Exists (f0 l) ((m : f0 l) => Exists (f1 l m) ((n : f1 l m) => f3 l m n))) ((o : s0) => exists_congr (f0 o) (f1 o) (f2 o) (f3 o) (f4 o))
thm forall_congr : (s0 : Sort(u_1)) -> (f0 : s0 -> Sort(u_2)) -> (f1 : (a : s0) -> f0 a -> Sort(u_3)) -> (f2 : (b : s0) -> (c : f0 b) -> f1 b c -> Sort(u_4)) -> (f3 : (d : s0) -> (e : f0 d) -> (f : f1 d e) -> f2 d e f -> Prop) -> (f4 : (g : s0) -> (h : f0 g) -> (i : f1 g h) -> f2 g h i -> Prop) -> ((j : s0) -> (k : f0 j) -> (l : f1 j k) -> (m : f2 j k l) -> Iff (f3 j k l m) (f4 j k l m)) -> Iff ((n : s0) -> (o : f0 n) -> (p : f1 n o) -> (q : f2 n o p) -> f3 n o p q) ((r : s0) -> (s : f0 r) -> (t : f1 r s) -> (u : f2 r s t) -> f4 r s t u)
  (s0 : Sort(u_1)) => (f0 : s0 -> Sort(u_2)) => (f1 : (a : s0) -> f0 a -> Sort(u_3)) => (f2 : (b : s0) -> (c : f0 b) -> f1 b c -> Sort(u_4)) => (f3 : (d : s0) -> (e : f0 d) -> (f : f1 d e) -> f2 d e f -> Prop) => (f4 : (g : s0) -> (h : f0 g) -> (i : f1 g h) -> f2 g h i -> Prop) => (f5 : (j : s0) -> (k : f0 j) -> (l : f1 j k) -> (m : f2 j k l) -> Iff (f3 j k l m) (f4 j k l m)) => forall_congr' s0 ((n : s0) => ((o : f0 n) -> (p : f1 n o) -> (q : f2 n o p) -> f3 n o p q)) ((r : s0) => ((s : f0 r) -> (t : f1 r s) -> (u : f2 r s t) -> f4 r s t u)) ((v : s0) => forall_congr (f0 v) (f1 v) (f2 v) (f3 v) (f4 v) (f5 v))
thm exists_congr : (s0 : Sort(u_1)) -> (f0 : s0 -> Sort(u_2)) -> (f1 : (a : s0) -> f0 a -> Sort(u_3)) -> (f2 : (b : s0) -> (c : f0 b) -> f1 b c -> Sort(u_4)) -> (f3 : (d : s0) -> (e : f0 d) -> (f : f1 d e) -> f2 d e f -> Prop) -> (f4 : (g : s0) -> (h : f0 g) -> (i : f1 g h) -> f2 g h i -> Prop) -> ((j : s0) -> (k : f0 j) -> (l : f1 j k) -> (m : f2 j k l) -> Iff (f3 j k l m) (f4 j k l m)) -> Iff (Exists s0 ((n : s0) => Exists (f0 n) ((o : f0 n) => Exists (f1 n o) ((p : f1 n o) => Exists (f2 n o p) ((q : f2 n o p) => f3 n o p q))))) (Exists s0 ((r : s0) => Exists (f0 r) ((s : f0 r) => Exists (f1 r s) ((t : f1 r s) => Exists (f2 r s t) ((u : f2 r s t) => f4 r s t u)))))
  (s0 : Sort(u_1)) => (f0 : s0 -> Sort(u_2)) => (f1 : (a : s0) -> f0 a -> Sort(u_3)) => (f2 : (b : s0) -> (c : f0 b) -> f1 b c -> Sort(u_4)) => (f3 : (d : s0) -> (e : f0 d) -> (f : f1 d e) -> f2 d e f -> Prop) => (f4 : (g : s0) -> (h : f0 g) -> (i : f1 g h) -> f2 g h i -> Prop) => (f5 : (j : s0) -> (k : f0 j) -> (l : f1 j k) -> (m : f2 j k l) -> Iff (f3 j k l m) (f4 j k l m)) => exists_congr s0 ((n : s0) => Exists (f0 n) ((o : f0 n) => Exists (f1 n o) ((p : f1 n o) => Exists (f2 n o p) ((q : f2 n o p) => f3 n o p q)))) ((r : s0) => Exists (f0 r) ((s : f0 r) => Exists (f1 r s) ((t : f1 r s) => Exists (f2 r s t) ((u : f2 r s t) => f4 r s t u)))) ((v : s0) => exists_congr (f0 v) (f1 v) (f2 v) (f3 v) (f4 v) (f5 v))
thm forall_congr : (s0 : Sort(u_1)) -> (f0 : s0 -> Sort(u_2)) -> (f1 : (a : s0) -> f0 a -> Sort(u_3)) -> (f2 : (b : s0) -> (c : f0 b) -> f1 b c -> Sort(u_4)) -> (f3 : (d : s0) -> (e : f0 d) -> (f : f1 d e) -> f2 d e f -> Sort(u_5)) -> (f4 : (g : s0) -> (h : f0 g) -> (i : f1 g h) -> (j : f2 g h i) -> f3 g h i j -> Prop) -> (f5 : (k : s0) -> (l : f0 k) -> (m : f1 k l) -> (n : f2 k l m) -> f3 k l m n -> Prop) -> ((o : s0) -> (p : f0 o) -> (q : f1 o p) -> (r : f2 o p q) -> (s : f3 o p q r) -> Iff (f4 o p q r s) (f5 o p q r s)) -> Iff ((t : s0) -> (u : f0 t) -> (v : f1 t u) -> (w : f2 t u v) -> (x : f3 t u v w) -> f4 t u v w x) ((y : s0) -> (z : f0 y) -> (A : f1 y z) -> (B : f2 y z A) -> (C : f3 y z A B) -> f5 y z A B C)
  (s0 : Sort(u_1)) => (f0 : s0 -> Sort(u_2)) => (f1 : (a : s0) -> f0 a -> Sort(u_3)) => (f2 : (b : s0) -> (c : f0 b) -> f1 b c -> Sort(u_4)) => (f3 : (d : s0) -> (e : f0 d) -> (f : f1 d e) -> f2 d e f -> Sort(u_5)) => (f4 : (g : s0) -> (h : f0 g) -> (i : f1 g h) -> (j : f2 g h i) -> f3 g h i j -> Prop) => (f5 : (k : s0) -> (l : f0 k) -> (m : f1 k l) -> (n : f2 k l m) -> f3 k l m n -> Prop) => (f6 : (o : s0) -> (p : f0 o) -> (q : f1 o p) -> (r : f2 o p q) -> (s : f3 o p q r) -> Iff (f4 o p q r s) (f5 o p q r s)) => forall_congr' s0 ((t : s0) => ((u : f0 t) -> (v : f1 t u) -> (w : f2 t u v) -> (x : f3 t u v w) -> f4 t u v w x)) ((y : s0) => ((z : f0 y) -> (A : f1 y z) -> (B : f2 y z A) -> (C : f3 y z A B) -> f5 y z A B C)) ((D : s0) => forall_congr (f0 D) (f1 D) (f2 D) (f3 D) (f4 D) (f5 D) (f6 D))
thm exists_congr : (s0 : Sort(u_1)) -> (f0 : s0 -> Sort(u_2)) -> (f1 : (a : s0) -> f0 a -> Sort(u_3)) -> (f2 : (b : s0) -> (c : f0 b) -> f1 b c -> Sort(u_4)) -> (f3 : (d : s0) -> (e : f0 d) -> (f : f1 d e) -> f2 d e f -> Sort(u_5)) -> (f4 : (g : s0) -> (h : f0 g) -> (i : f1 g h) -> (j : f2 g h i) -> f3 g h i j -> Prop) -> (f5 : (k : s0) -> (l : f0 k) -> (m : f1 k l) -> (n : f2 k l m) -> f3 k l m n -> Prop) -> ((o : s0) -> (p : f0 o) -> (q : f1 o p) -> (r : f2 o p q) -> (s : f3 o p q r) -> Iff (f4 o p q r s) (f5 o p q r s)) -> Iff (Exists s0 ((t : s0) => Exists (f0 t) ((u : f0 t) => Exists (f1 t u) ((v : f1 t u) => Exists (f2 t u v) ((w : f2 t u v) => Exists (f3 t u v w) ((x : f3 t u v w) => f4 t u v w x)))))) (Exists s0 ((y : s0) => Exists (f0 y) ((z : f0 y) => Exists (f1 y z) ((A : f1 y z) => Exists (f2 y z A) ((B : f2 y z A) => Exists (f3 y z A B) ((C : f3 y z A B) => f5 y z A B C))))))
  (s0 : Sort(u_1)) => (f0 : s0 -> Sort(u_2)) => (f1 : (a : s0) -> f0 a -> Sort(u_3)) => (f2 : (b : s0) -> (c : f0 b) -> f1 b c -> Sort(u_4)) => (f3 : (d : s0) -> (e : f0 d) -> (f : f1 d e) -> f2 d e f -> Sort(u_5)) => (f4 : (g : s0) -> (h : f0 g) -> (i : f1 g h) -> (j : f2 g h i) -> f3 g h i j -> Prop) => (f5 : (k : s0) -> (l : f0 k) -> (m : f1 k l) -> (n : f2 k l m) -> f3 k l m n -> Prop) => (f6 : (o : s0) -> (p : f0 o) -> (q : f1 o p) -> (r : f2 o p q) -> (s : f3 o p q r) -> Iff (f4 o p q r s) (f5 o p q r s)) => exists_congr s0 ((t : s0) => Exists (f0 t) ((u : f0 t) => Exists (f1 t u) ((v : f1 t u) => Exists (f2 t u v) ((w : f2 t u v) => Exists (f3 t u v w) ((x : f3 t u v w) => f4 t u v w x))))) ((y : s0) => Exists (f0 y) ((z : f0 y) => Exists (f1 y z) ((A : f1 y z) => Exists (f2 y z A) ((B : f2 y z A) => Exists (f3 y z A B) ((C : f3 y z A B) => f5 y z A B C))))) ((D : s0) => exists_congr (f0 D) (f1 D) (f2 D) (f3 D) (f4 D) (f5 D) (f6 D))
thm not_exists : (s0 : Sort(u_1)) -> (f0 : s0 -> Prop) -> Iff (Not (Exists s0 ((a : s0) => f0 a))) ((b : s0) -> Not (f0 b))
  (s0 : Sort(u_1)) => (f0 : s0 -> Prop) => exists_imp s0 f0 False
thm forall_not_of_not_exists : (s0 : Sort(u_1)) -> (f0 : s0 -> Prop) -> Not (Exists s0 ((a : s0) => f0 a)) -> (b : s0) -> Not (f0 b)
  (s0 : Sort(u_1)) => (f0 : s0 -> Prop) => (a : Not (Exists s0 ((b : s0) => f0 b))) => Iff.mp (Not (Exists s0 ((c : s0) => f0 c))) ((d : s0) -> Not (f0 d)) (not_exists s0 f0) a
thm not_exists_of_forall_not : (s0 : Sort(u_1)) -> (f0 : s0 -> Prop) -> ((a : s0) -> Not (f0 a)) -> Not (Exists s0 ((b : s0) => f0 b))
  (s0 : Sort(u_1)) => (f0 : s0 -> Prop) => (f1 : (a : s0) -> Not (f0 a)) => Iff.mpr (Not (Exists s0 ((b : s0) => f0 b))) ((c : s0) -> Not (f0 c)) (not_exists s0 f0) f1
def forall_and.match_1 := (s0 : Sort(u_1)) => (f0 : s0 -> Prop) => (f1 : s0 -> Prop) => (f2 : And ((a : s0) -> f0 a) ((b : s0) -> f1 b) -> Prop) => (c : And ((d : s0) -> f0 d) ((e : s0) -> f1 e)) => (f3 : (f4 : (f : s0) -> f0 f) -> (f5 : (g : s0) -> f1 g) -> f2 (And.intro ((h : s0) -> f0 h) ((i : s0) -> f1 i) f4 f5)) => And.casesOn ((j : s0) -> f0 j) ((k : s0) -> f1 k) ((l : And ((m : s0) -> f0 m) ((n : s0) -> f1 n)) => f2 l) c ((f6 : (o : s0) -> f0 o) => (f7 : (p : s0) -> f1 p) => f3 f6 f7)
thm forall_and : (s0 : Sort(u_1)) -> (f0 : s0 -> Prop) -> (f1 : s0 -> Prop) -> Iff ((a : s0) -> And (f0 a) (f1 a)) (And ((b : s0) -> f0 b) ((c : s0) -> f1 c))
  (s0 : Sort(u_1)) => (f0 : s0 -> Prop) => (f1 : s0 -> Prop) => Iff.intro ((a : s0) -> And (f0 a) (f1 a)) (And ((b : s0) -> f0 b) ((c : s0) -> f1 c)) ((f2 : (d : s0) -> And (f0 d) (f1 d)) => And.intro ((e : s0) -> f0 e) ((f : s0) -> f1 f) ((g : s0) => And.left (f0 g) (f1 g) (f2 g)) ((h : s0) => And.right (f0 h) (f1 h) (f2 h))) ((i : And ((j : s0) -> f0 j) ((k : s0) -> f1 k)) => (l : s0) => forall_and.match_1 s0 f0 f1 (And ((m : s0) -> f0 m) ((n : s0) -> f1 n) => And (f0 l) (f1 l)) i ((f3 : (o : s0) -> f0 o) => (f4 : (p : s0) -> f1 p) => And.intro (f0 l) (f1 l) (f3 l) (f4 l)))
def exists_or.match_1 := (s0 : Sort(u_1)) => (f0 : s0 -> Prop) => (f1 : s0 -> Prop) => (f2 : Exists s0 ((a : s0) => Or (f0 a) (f1 a)) -> Prop) => (b : Exists s0 ((c : s0) => Or (f0 c) (f1 c))) => (f3 : (d : s0) -> (e : f0 d) -> f2 (Exists.intro s0 ((f : s0) => Or (f0 f) (f1 f)) d (Or.inl (f0 d) (f1 d) e))) => (f4 : (g : s0) -> (h : f1 g) -> f2 (Exists.intro s0 ((i : s0) => Or (f0 i) (f1 i)) g (Or.inr (f0 g) (f1 g) h))) => Exists.casesOn s0 ((j : s0) => Or (f0 j) (f1 j)) ((k : Exists s0 ((l : s0) => Or (f0 l) (f1 l))) => f2 k) b ((m : s0) => (n : Or (f0 m) (f1 m)) => Or.casesOn (f0 m) (f1 m) ((o : Or (f0 m) (f1 m)) => f2 (Exists.intro s0 ((p : s0) => Or (f0 p) (f1 p)) m o)) n ((q : f0 m) => f3 m q) ((r : f1 m) => f4 m r))
def exists_or.match_2 := (s0 : Sort(u_1)) => (f0 : s0 -> Prop) => (f1 : s0 -> Prop) => (f2 : Or (Exists s0 ((a : s0) => f0 a)) (Exists s0 ((b : s0) => f1 b)) -> Prop) => (c : Or (Exists s0 ((d : s0) => f0 d)) (Exists s0 ((e : s0) => f1 e))) => (f3 : (f : s0) -> (g : f0 f) -> f2 (Or.inl (Exists s0 ((h : s0) => f0 h)) (Exists s0 ((i : s0) => f1 i)) (Exists.intro s0 ((j : s0) => f0 j) f g))) => (f4 : (k : s0) -> (l : f1 k) -> f2 (Or.inr (Exists s0 ((m : s0) => f0 m)) (Exists s0 ((n : s0) => f1 n)) (Exists.intro s0 ((o : s0) => f1 o) k l))) => Or.casesOn (Exists s0 ((p : s0) => f0 p)) (Exists s0 ((q : s0) => f1 q)) ((r : Or (Exists s0 ((s : s0) => f0 s)) (Exists s0 ((t : s0) => f1 t))) => f2 r) c ((u : Exists s0 ((v : s0) => f0 v)) => Exists.casesOn s0 ((w : s0) => f0 w) ((x : Exists s0 ((y : s0) => f0 y)) => f2 (Or.inl (Exists s0 ((z : s0) => f0 z)) (Exists s0 ((A : s0) => f1 A)) x)) u ((B : s0) => (C : f0 B) => f3 B C)) ((D : Exists s0 ((E : s0) => f1 E)) => Exists.casesOn s0 ((F : s0) => f1 F) ((G : Exists s0 ((H : s0) => f1 H)) => f2 (Or.inr (Exists s0 ((I : s0) => f0 I)) (Exists s0 ((J : s0) => f1 J)) G)) D ((K : s0) => (L : f1 K) => f4 K L))
thm exists_or : (s0 : Sort(u_1)) -> (f0 : s0 -> Prop) -> (f1 : s0 -> Prop) -> Iff (Exists s0 ((a : s0) => Or (f0 a) (f1 a))) (Or (Exists s0 ((b : s0) => f0 b)) (Exists s0 ((c : s0) => f1 c)))
  (s0 : Sort(u_1)) => (f0 : s0 -> Prop) => (f1 : s0 -> Prop) => Iff.intro (Exists s0 ((a : s0) => Or (f0 a) (f1 a))) (Or (Exists s0 ((b : s0) => f0 b)) (Exists s0 ((c : s0) => f1 c))) ((d : Exists s0 ((e : s0) => Or (f0 e) (f1 e))) => exists_or.match_1 s0 f0 f1 (Exists s0 ((f : s0) => Or (f0 f) (f1 f)) => Or (Exists s0 ((g : s0) => f0 g)) (Exists s0 ((h : s0) => f1 h))) d ((i : s0) => (j : f0 i) => Or.inl (Exists s0 ((k : s0) => f0 k)) (Exists s0 ((l : s0) => f1 l)) (Exists.intro s0 ((m : s0) => f0 m) i j)) ((n : s0) => (o : f1 n) => Or.inr (Exists s0 ((p : s0) => f0 p)) (Exists s0 ((q : s0) => f1 q)) (Exists.intro s0 ((r : s0) => f1 r) n o))) ((s : Or (Exists s0 ((t : s0) => f0 t)) (Exists s0 ((u : s0) => f1 u))) => exists_or.match_2 s0 f0 f1 (Or (Exists s0 ((v : s0) => f0 v)) (Exists s0 ((w : s0) => f1 w)) => Exists s0 ((x : s0) => Or (f0 x) (f1 x))) s ((y : s0) => (z : f0 y) => Exists.intro s0 ((A : s0) => Or (f0 A) (f1 A)) y (Or.inl (f0 y) (f1 y) z)) ((B : s0) => (C : f1 B) => Exists.intro s0 ((D : s0) => Or (f0 D) (f1 D)) B (Or.inr (f0 B) (f1 B) C)))
thm Exists.nonempty : (s0 : Sort(u_1)) -> (f0 : s0 -> Prop) -> Exists s0 ((a : s0) => f0 a) -> Nonempty s0
  (s0 : Sort(u_1)) => (f0 : s0 -> Prop) => (a : Exists s0 ((b : s0) => f0 b)) => forall_exists_index.match_1 s0 f0 (Exists s0 ((c : s0) => f0 c) => Nonempty s0) a ((d : s0) => f0 d => Nonempty.intro s0 d)
def not_forall_of_exists_not.match_1 := (s0 : Sort(u_1)) => (f0 : s0 -> Prop) => (f1 : Exists s0 ((a : s0) => Not (f0 a)) -> ((b : s0) -> f0 b) -> Prop) => (c : Exists s0 ((d : s0) => Not (f0 d))) => (f2 : (e : s0) -> f0 e) => (f3 : (f : s0) -> (g : Not (f0 f)) -> (f4 : (h : s0) -> f0 h) -> f1 (Exists.intro s0 ((i : s0) => Not (f0 i)) f g) f4) => Exists.casesOn s0 ((j : s0) => Not (f0 j)) ((k : Exists s0 ((l : s0) => Not (f0 l))) => f1 k f2) c ((m : s0) => (n : Not (f0 m)) => f3 m n f2)
thm not_forall_of_exists_not : (s0 : Sort(u_1)) -> (f0 : s0 -> Prop) -> Exists s0 ((a : s0) => Not (f0 a)) -> Not ((b : s0) -> f0 b)
  (s0 : Sort(u_1)) => (f0 : s0 -> Prop) => (a : Exists s0 ((b : s0) => Not (f0 b))) => (f1 : (c : s0) -> f0 c) => not_forall_of_exists_not.match_1 s0 f0 (Exists s0 ((d : s0) => Not (f0 d)) => ((e : s0) -> f0 e) => False) a f1 ((f : s0) => (g : Not (f0 f)) => (f2 : (h : s0) -> f0 h) => g (f2 f))
def exists_prop'.match_1 := (s0 : Sort(u_1)) => (a : Prop) => (f0 : Exists s0 (s0 => a) -> Prop) => (b : Exists s0 (s0 => a)) => (f1 : (c : s0) -> (d : a) -> f0 (Exists.intro s0 (s0 => a) c d)) => Exists.casesOn s0 ((e : s0) => a) ((f : Exists s0 ((g : s0) => a)) => f0 f) b ((h : s0) => (i : a) => f1 h i)
def exists_prop'.match_2 := (s0 : Sort(u_1)) => (a : Prop) => (f0 : And (Nonempty s0) a -> Prop) => (b : And (Nonempty s0) a) => (f1 : (c : s0) -> (d : a) -> f0 (And.intro (Nonempty s0) a (Nonempty.intro s0 c) d)) => And.casesOn (Nonempty s0) a ((e : And (Nonempty s0) a) => f0 e) b ((f : Nonempty s0) => (g : a) => Nonempty.casesOn s0 ((h : Nonempty s0) => f0 (And.intro (Nonempty s0) a h g)) f ((i : s0) => f1 i g))
thm exists_prop' : (s0 : Sort(u_1)) -> (a : Prop) -> Iff (Exists s0 (s0 => a)) (And (Nonempty s0) a)
  (s0 : Sort(u_1)) => (a : Prop) => Iff.intro (Exists s0 (s0 => a)) (And (Nonempty s0) a) ((b : Exists s0 (s0 => a)) => exists_prop'.match_1 s0 a (Exists s0 ((c : s0) => a) => And (Nonempty s0) a) b ((d : s0) => (e : a) => And.intro (Nonempty s0) a (Nonempty.intro s0 d) e)) ((f : And (Nonempty s0) a) => exists_prop'.match_2 s0 a (And (Nonempty s0) a => Exists s0 (s0 => a)) f ((g : s0) => (h : a) => Exists.intro s0 (s0 => a) g h))
thm forall_const : (a : Prop) -> (s0 : Sort(u_1)) -> Nonempty s0 -> Iff (s0 -> a) a
  (a : Prop) => (s0 : Sort(u_1)) => (b : Nonempty s0) => Iff.intro (s0 -> a) a (Nonempty.elim s0 a b) ((c : a) => (d : s0) => c)
thm forall_prop_of_true : (a : Prop) -> (f0 : a -> Prop) -> (b : a) -> Iff ((c : a) -> f0 c) (f0 b)
  (a : Prop) => (f0 : a -> Prop) => (b : a) => forall_const (f0 b) a (Nonempty.intro a b)
thm forall_comm : (s0 : Sort(u_2)) -> (s1 : Sort(u_1)) -> (f0 : (a : s0) -> (b : s1) -> Prop) -> Iff ((c : s0) -> (d : s1) -> f0 c d) ((e : s1) -> (f : s0) -> f0 f e)
  (s0 : Sort(u_2)) => (s1 : Sort(u_1)) => (f0 : (a : s0) -> (b : s1) -> Prop) => Iff.intro ((c : s0) -> (d : s1) -> f0 c d) ((e : s1) -> (f : s0) -> f0 f e) ((f1 : (g : s0) -> (h : s1) -> f0 g h) => (i : s1) => (j : s0) => f1 j i) ((f2 : (k : s1) -> (l : s0) -> f0 l k) => (m : s0) => (n : s1) => f2 n m)
def exists_comm.match_1 := (s0 : Sort(u_1)) => (s1 : Sort(u_2)) => (f0 : s0 -> s1 -> Prop) => (f1 : Exists s0 ((a : s0) => Exists s1 ((b : s1) => f0 a b)) -> Prop) => (c : Exists s0 ((d : s0) => Exists s1 ((e : s1) => f0 d e))) => (f2 : (f : s0) -> (g : s1) -> (h : f0 f g) -> f1 (Exists.intro s0 ((i : s0) => Exists s1 ((j : s1) => f0 i j)) f (Exists.intro s1 ((k : s1) => f0 f k) g h))) => Exists.casesOn s0 ((l : s0) => Exists s1 ((m : s1) => f0 l m)) ((n : Exists s0 ((o : s0) => Exists s1 ((p : s1) => f0 o p))) => f1 n) c ((q : s0) => (r : Exists s1 ((s : s1) => f0 q s)) => Exists.casesOn s1 ((t : s1) => f0 q t) ((u : Exists s1 ((v : s1) => f0 q v)) => f1 (Exists.intro s0 ((w : s0) => Exists s1 ((x : s1) => f0 w x)) q u)) r ((y : s1) => (z : f0 q y) => f2 q y z))
def exists_comm.match_2 := (s0 : Sort(u_2)) => (s1 : Sort(u_1)) => (f0 : (a : s0) -> (b : s1) -> Prop) => (f1 : Exists s1 ((c : s1) => Exists s0 ((d : s0) => f0 d c)) -> Prop) => (e : Exists s1 ((f : s1) => Exists s0 ((g : s0) => f0 g f))) => (f2 : (h : s1) -> (i : s0) -> (j : f0 i h) -> f1 (Exists.intro s1 ((k : s1) => Exists s0 ((l : s0) => f0 l k)) h (Exists.intro s0 ((m : s0) => f0 m h) i j))) => Exists.casesOn s1 ((n : s1) => Exists s0 ((o : s0) => f0 o n)) ((p : Exists s1 ((q : s1) => Exists s0 ((r : s0) => f0 r q))) => f1 p) e ((s : s1) => (t : Exists s0 ((u : s0) => f0 u s)) => Exists.casesOn s0 ((v : s0) => f0 v s) ((w : Exists s0 ((x : s0) => f0 x s)) => f1 (Exists.intro s1 ((y : s1) => Exists s0 ((z : s0) => f0 z y)) s w)) t ((A : s0) => (B : f0 A s) => f2 s A B))
thm exists_comm : (s0 : Sort(u_2)) -> (s1 : Sort(u_1)) -> (f0 : (a : s0) -> (b : s1) -> Prop) -> Iff (Exists s0 ((c : s0) => Exists s1 ((d : s1) => f0 c d))) (Exists s1 ((e : s1) => Exists s0 ((f : s0) => f0 f e)))
  (s0 : Sort(u_2)) => (s1 : Sort(u_1)) => (f0 : (a : s0) -> (b : s1) -> Prop) => Iff.intro (Exists s0 ((c : s0) => Exists s1 ((d : s1) => f0 c d))) (Exists s1 ((e : s1) => Exists s0 ((f : s0) => f0 f e))) ((g : Exists s0 ((h : s0) => Exists s1 ((i : s1) => f0 h i))) => exists_comm.match_1 s0 s1 f0 (Exists s0 ((j : s0) => Exists s1 ((k : s1) => f0 j k)) => Exists s1 ((l : s1) => Exists s0 ((m : s0) => f0 m l))) g ((n : s0) => (o : s1) => (p : f0 n o) => Exists.intro s1 ((q : s1) => Exists s0 ((r : s0) => f0 r q)) o (Exists.intro s0 ((s : s0) => f0 s o) n p))) ((t : Exists s1 ((u : s1) => Exists s0 ((v : s0) => f0 v u))) => exists_comm.match_2 s0 s1 f0 (Exists s1 ((w : s1) => Exists s0 ((x : s0) => f0 x w)) => Exists s0 ((y : s0) => Exists s1 ((z : s1) => f0 y z))) t ((A : s1) => (B : s0) => (C : f0 B A) => Exists.intro s0 ((D : s0) => Exists s1 ((E : s1) => f0 D E)) B (Exists.intro s1 ((F : s1) => f0 B F) A C)))
thm iff_true_intro : (a : Prop) -> a -> Iff a True
  (a : Prop) => (b : a) => iff_of_true a True b trivial
thm forall_prop_of_false : (a : Prop) -> (f0 : a -> Prop) -> Not a -> Iff ((b : a) -> f0 b) True
  (a : Prop) => (f0 : a -> Prop) => (b : Not a) => iff_true_intro ((c : a) -> f0 c) ((d : a) => Not.elim a (f0 d) b d)
def Membership : Sort(u + 1) -> Sort(v + 1) -> Sort(Max(u + 1, v + 1))
def Membership.mem : (s0 : Sort(u + 1)) -> (s1 : Sort(v + 1)) -> Membership s0 s1 -> s1 -> s0 -> Prop
thm ne_of_mem_of_not_mem : (s0 : Sort(u_1 + 1)) -> (s1 : Sort(u_2 + 1)) -> (a : Membership s0 s1) -> (b : s1) -> (c : s0) -> (d : s0) -> Membership.mem s0 s1 a b c -> Not (Membership.mem s0 s1 a b d) -> Ne s0 c d
  (s0 : Sort(u_1 + 1)) => (s1 : Sort(u_2 + 1)) => (a : Membership s0 s1) => (b : s1) => (c : s0) => (d : s0) => (e : Membership.mem s0 s1 a b c) => mt (Eq s0 c d) (Membership.mem s0 s1 a b d) ((f : Eq s0 c d) => Eq.rec s0 c ((g : s0) => Eq s0 c g => Membership.mem s0 s1 a b g) e d f)
thm ne_of_mem_of_not_mem' : (s0 : Sort(u_1 + 1)) -> (s1 : Sort(u_2 + 1)) -> (a : Membership s0 s1) -> (b : s1) -> (c : s1) -> (d : s0) -> Membership.mem s0 s1 a b d -> Not (Membership.mem s0 s1 a c d) -> Ne s1 b c
  (s0 : Sort(u_1 + 1)) => (s1 : Sort(u_2 + 1)) => (a : Membership s0 s1) => (b : s1) => (c : s1) => (d : s0) => (e : Membership.mem s0 s1 a b d) => mt (Eq s1 b c) (Membership.mem s0 s1 a c d) ((f : Eq s1 b c) => Eq.rec s1 b ((g : s1) => Eq s1 b g => Membership.mem s0 s1 a g d) e c f)
def False.casesOn := (f0 : (a : False) -> Sort(u)) => (b : False) => False.rec f0 b
def or_false.match_1 := (a : Prop) => (f0 : Or a False -> Prop) => (b : Or a False) => (f1 : (c : a) -> f0 (Or.inl a False c)) => Or.casesOn a False ((d : Or a False) => f0 d) b ((e : a) => f1 e) ((f : False) => False.casesOn ((g : False) => f0 (Or.inr a False g)) f)
thm or_false : (a : Prop) -> Eq Prop (Or a False) a
  (a : Prop) => propext (Or a False) a (Iff.intro (Or a False) a ((b : Or a False) => or_false.match_1 a (Or a False => a) b ((c : a) => c)) (Or.inl a False))
thm or_true : (a : Prop) -> Eq Prop (Or a True) True
  (a : Prop) => eq_true (Or a True) (Or.inr a True trivial)
thm Decidable.not_or_self : (a : Prop) -> Decidable a -> Or (Not a) a
  (a : Prop) => (b : Decidable a) => Decidable.casesOn a ((c : Decidable a) => (Eq (Decidable a) b c -> Or (Not a) a)) b ((d : Not a) => Eq (Decidable a) b (Decidable.isFalse a d) => of_eq_true (Or (Not a) a) (Eq.trans Prop (Or (Not a) a) (Or True False) True (congr Prop Prop (Or (Not a)) (Or True) a False (congrArg Prop ((e : Prop) -> Prop) (Not a) True Or (Eq.trans Prop (Not a) (Not False) True (congrArg Prop Prop a False Not (eq_false a d)) not_false_eq_true)) (eq_false a d)) (or_false True))) ((f : a) => Eq (Decidable a) b (Decidable.isTrue a f) => of_eq_true (Or (Not a) a) (Eq.trans Prop (Or (Not a) a) (Or False True) True (congr Prop Prop (Or (Not a)) (Or False) a True (congrArg Prop ((g : Prop) -> Prop) (Not a) False Or (Eq.trans Prop (Not a) (Not True) False (congrArg Prop Prop a True Not (eq_true a f)) not_true_eq_false)) (eq_true a f)) (or_true False))) (Eq.refl (Decidable a) b)
thm Decidable.byContradiction : (a : Prop) -> Decidable a -> (Not a -> False) -> a
  (a : Prop) => (b : Decidable a) => (f0 : Not a -> False) => Decidable.byCases a a b (id a) ((c : Not a) => False.elim a (f0 c))
thm Decidable.of_not_not : (a : Prop) -> Decidable a -> Not (Not a) -> a
  (a : Prop) => (b : Decidable a) => (c : Not (Not a)) => Decidable.byContradiction a b ((d : Not a) => absurd (Not a) False d c)
thm Decidable.by_contra : (a : Prop) -> Decidable a -> (Not a -> False) -> a
  (a : Prop) => (b : Decidable a) => Decidable.of_not_not a b
def decide_eq_true.match_1 := (a : Prop) => (f0 : Decidable a -> a -> Prop) => (b : Decidable a) => (c : a) => (f1 : (d : a) -> (e : a) -> f0 (Decidable.isTrue a d) e) => (f2 : (f : Not a) -> (g : a) -> f0 (Decidable.isFalse a f) g) => Decidable.casesOn a ((h : Decidable a) => f0 h c) b ((i : Not a) => f2 i c) ((j : a) => f1 j c)
thm decide_eq_true : (a : Prop) -> (b : Decidable a) -> a -> Eq Bool (Decidable.decide a b) Bool.true
  (a : Prop) => (b : Decidable a) => (c : a) => decide_eq_true.match_1 a ((d : Decidable a) => (e : a) => Eq Bool (Decidable.decide a d) Bool.true) b c ((f : a) => (g : a) => rfl Bool (Decidable.decide a (Decidable.isTrue a f))) ((h : Not a) => (i : a) => absurd a (Eq Bool (Decidable.decide a (Decidable.isFalse a h)) Bool.true) i h)
thm decide_eq_true_eq : (a : Prop) -> (b : Decidable a) -> Eq Prop (Eq Bool (Decidable.decide a b) Bool.true) a
  (a : Prop) => (b : Decidable a) => propext (Eq Bool (Decidable.decide a b) Bool.true) a (Iff.intro (Eq Bool (Decidable.decide a b) Bool.true) a (of_decide_eq_true a b) (decide_eq_true a b))
thm decide_eq_true_iff : (a : Prop) -> (b : Decidable a) -> Iff (Eq Bool (Decidable.decide a b) Bool.true) a
  (a : Prop) => (b : Decidable a) => of_eq_true (Iff (Eq Bool (Decidable.decide a b) Bool.true) a) (Eq.trans Prop (Iff (Eq Bool (Decidable.decide a b) Bool.true) a) (Iff a a) True (congrArg Prop Prop (Eq Bool (Decidable.decide a b) Bool.true) a ((c : Prop) => Iff c a) (decide_eq_true_eq a b)) (iff_self a))
thm not_not_of_not_imp : (a : Prop) -> (b : Prop) -> Not (a -> b) -> Not (Not a)
  (a : Prop) => (b : Prop) => mt (Not a) (a -> b) (Not.elim a b)
thm Decidable.of_not_imp : (a : Prop) -> (b : Prop) -> Decidable a -> Not (a -> b) -> a
  (a : Prop) => (b : Prop) => (c : Decidable a) => (d : Not (a -> b)) => Decidable.byContradiction a c (not_not_of_not_imp a b d)
thm Decidable.not_imp_symm : (a : Prop) -> (b : Prop) -> Decidable a -> (Not a -> b) -> Not b -> a
  (a : Prop) => (b : Prop) => (c : Decidable a) => (f0 : (d : Not a) -> b) => (e : Not b) => Decidable.byContradiction a c (Function.comp (Not a) b False e f0)
thm Decidable.not_imp_comm : (a : Prop) -> (b : Prop) -> Decidable a -> Decidable b -> Iff (Not a -> b) (Not b -> a)
  (a : Prop) => (b : Prop) => (c : Decidable a) => (d : Decidable b) => Iff.intro (Not a -> b) (Not b -> a) (Decidable.not_imp_symm a b c) (Decidable.not_imp_symm b a d)
def letFun := (s0 : Sort(u)) => (f0 : s0 -> Sort(v)) => (a : s0) => (f1 : (b : s0) -> f0 b) => f1 a
thm imp_not_self : (a : Prop) -> Iff (a -> Not a) (Not a)
  (a : Prop) => Iff.intro (a -> Not a) (Not a) ((f0 : a -> Not a) => (b : a) => f0 b b) ((c : Not a) => (d : a) => c)
def Eq.mp := (s0 : Sort(u)) => (s1 : Sort(u)) => (a : Eq Sort(u) s0 s1) => (b : s0) => Eq.rec Sort(u) s0 ((s2 : Sort(u)) => Eq Sort(u) s0 s2 => s2) b s1 a
thm not_not_intro : (a : Prop) -> a -> Not (Not a)
  (a : Prop) => (b : a) => (c : Not a) => c b
thm Decidable.not_not : (a : Prop) -> Decidable a -> Iff (Not (Not a)) a
  (a : Prop) => (b : Decidable a) => Iff.intro (Not (Not a)) a (Decidable.of_not_not a b) (not_not_intro a)
thm Decidable.not_imp_self : (a : Prop) -> Decidable a -> Iff (Not a -> a) a
  (a : Prop) => (b : Decidable a) => letFun (Iff (Not a -> Not (Not a)) (Not (Not a))) ((c : Iff (Not a -> Not (Not a)) (Not (Not a))) => Iff (Not a -> a) a) (imp_not_self (Not a)) ((d : Iff (Not a -> Not (Not a)) (Not (Not a))) => Eq.mp (Iff (Not a -> Not (Not a)) (Not (Not a))) (Iff (Not a -> a) a) (congrArg Prop Prop (Not (Not a)) a ((e : Prop) => Iff (Not a -> e) e) (propext (Not (Not a)) a (Decidable.not_not a b))) d)
thm Or.resolve_left : (a : Prop) -> (b : Prop) -> Or a b -> Not a -> b
  (a : Prop) => (b : Prop) => (c : Or a b) => (d : Not a) => Or.elim a b b c ((e : a) => absurd a b e d) (id b)
thm Decidable.or_iff_not_imp_left : (a : Prop) -> (b : Prop) -> Decidable a -> Iff (Or a b) (Not a -> b)
  (a : Prop) => (b : Prop) => (c : Decidable a) => Iff.intro (Or a b) (Not a -> b) (Or.resolve_left a b) ((f0 : Not a -> b) => dite (Or a b) a c (Or.inl a b) (Function.comp (Not a) b (Or a b) (Or.inr a b) f0))
thm Decidable.or_iff_not_imp_right : (a : Prop) -> (b : Prop) -> Decidable a -> Iff (Or b a) (Not a -> b)
  (a : Prop) => (b : Prop) => (c : Decidable a) => Iff.trans (Or b a) (Or a b) (Not a -> b) (or_comm b a) (Decidable.or_iff_not_imp_left a b c)
thm Decidable.not_imp_not : (a : Prop) -> (b : Prop) -> Decidable a -> Iff (Not a -> Not b) (b -> a)
  (a : Prop) => (b : Prop) => (c : Decidable a) => Iff.intro (Not a -> Not b) (b -> a) ((f0 : Not a -> Not b) => (d : b) => Decidable.byContradiction a c ((e : Not a) => f0 e d)) (mt b a)
thm Decidable.not_or_of_imp : (a : Prop) -> (b : Prop) -> Decidable a -> (a -> b) -> Or (Not a) b
  (a : Prop) => (b : Prop) => (c : Decidable a) => (f0 : a -> b) => dite (Or (Not a) b) a c ((d : a) => Or.inr (Not a) b (f0 d)) ((e : Not a) => Or.inl (Not a) b e)
thm Or.neg_resolve_left : (a : Prop) -> (b : Prop) -> Or (Not a) b -> a -> b
  (a : Prop) => (b : Prop) => (c : Or (Not a) b) => (d : a) => Or.elim (Not a) b b c (absurd a b d) (id b)
thm Decidable.imp_iff_not_or : (a : Prop) -> (b : Prop) -> Decidable a -> Iff (a -> b) (Or (Not a) b)
  (a : Prop) => (b : Prop) => (c : Decidable a) => Iff.intro (a -> b) (Or (Not a) b) (Decidable.not_or_of_imp a b c) (Or.neg_resolve_left a b)
thm Decidable.imp_iff_or_not : (a : Prop) -> (b : Prop) -> Decidable a -> Iff (a -> b) (Or b (Not a))
  (a : Prop) => (b : Prop) => (c : Decidable a) => Iff.trans (a -> b) (Or (Not a) b) (Or b (Not a)) (Decidable.imp_iff_not_or a b c) (or_comm (Not a) b)
thm imp_iff_right : (a : Prop) -> (b : Prop) -> b -> Iff (b -> a) a
  (a : Prop) => (b : Prop) => (c : b) => Iff.intro (b -> a) a ((f0 : b -> a) => f0 c) ((d : a) => (e : b) => d)
thm false_imp_iff : (a : Prop) -> Iff (False -> a) True
  (a : Prop) => iff_true_intro (False -> a) (False.elim a)
thm true_or : (a : Prop) -> Eq Prop (Or True a) True
  (a : Prop) => eq_true (Or True a) (Or.inl True a trivial)
thm Decidable.imp_or : (a : Prop) -> (b : Prop) -> (c : Prop) -> Decidable a -> Iff (a -> Or b c) (Or (a -> b) (a -> c))
  (a : Prop) => (b : Prop) => (c : Prop) => (d : Decidable a) => dite (Iff ((e : a) -> Or b c) (Or ((f : a) -> b) ((g : a) -> c))) a d ((h : a) => Eq.mpr (Iff (a -> Or b c) (Or (a -> b) (a -> c))) (Iff (Or b c) (Or (a -> b) (a -> c))) (id (Eq Prop (Iff (a -> Or b c) (Or (a -> b) (a -> c))) (Iff (Or b c) (Or (a -> b) (a -> c)))) (congrArg Prop Prop (a -> Or b c) (Or b c) ((i : Prop) => Iff i (Or (a -> b) (a -> c))) (propext (a -> Or b c) (Or b c) (imp_iff_right (Or b c) a h)))) (Eq.mpr (Iff (Or b c) (Or (a -> b) (a -> c))) (Iff (Or b c) (Or b (a -> c))) (id (Eq Prop (Iff (Or b c) (Or (a -> b) (a -> c))) (Iff (Or b c) (Or b (a -> c)))) (congrArg Prop Prop (a -> b) b ((j : Prop) => Iff (Or b c) (Or j (a -> c))) (propext (a -> b) b (imp_iff_right b a h)))) (Eq.mpr (Iff (Or b c) (Or b (a -> c))) (Iff (Or b c) (Or b c)) (id (Eq Prop (Iff (Or b c) (Or b (a -> c))) (Iff (Or b c) (Or b c))) (congrArg Prop Prop (a -> c) c ((k : Prop) => Iff (Or b c) (Or b k)) (propext (a -> c) c (imp_iff_right c a h)))) (Iff.rfl (Or b c))))) ((l : Not a) => Eq.mpr (Iff (a -> Or b c) (Or (a -> b) (a -> c))) (Iff (False -> Or b c) (Or (False -> b) (False -> c))) (id (Eq Prop (Iff (a -> Or b c) (Or (a -> b) (a -> c))) (Iff (False -> Or b c) (Or (False -> b) (False -> c)))) (congrArg Prop Prop a False ((m : Prop) => Iff (m -> Or b c) (Or (m -> b) (m -> c))) (propext a False (iff_false_intro a l)))) (Eq.mpr (Iff (False -> Or b c) (Or (False -> b) (False -> c))) (Iff True (Or (False -> b) (False -> c))) (id (Eq Prop (Iff (False -> Or b c) (Or (False -> b) (False -> c))) (Iff True (Or (False -> b) (False -> c)))) (congrArg Prop Prop (False -> Or b c) True ((n : Prop) => Iff n (Or (False -> b) (False -> c))) (propext (False -> Or b c) True (false_imp_iff (Or b c))))) (Eq.mpr (Iff True (Or (False -> b) (False -> c))) (Iff True (Or True (False -> c))) (id (Eq Prop (Iff True (Or (False -> b) (False -> c))) (Iff True (Or True (False -> c)))) (congrArg Prop Prop (False -> b) True ((o : Prop) => Iff True (Or o (False -> c))) (propext (False -> b) True (false_imp_iff b)))) (Eq.mpr (Iff True (Or True (False -> c))) (Iff True True) (id (Eq Prop (Iff True (Or True (False -> c))) (Iff True True)) (congrArg Prop Prop (Or True (False -> c)) True ((p : Prop) => Iff True p) (true_or (False -> c)))) (Iff.rfl True)))))
thm implies_true : (s0 : Sort(u)) -> Eq Prop (s0 -> True) True
  (s0 : Sort(u)) => eq_true (s0 -> True) (s0 => trivial)
def false_or.match_1 := (a : Prop) => (f0 : Or False a -> Prop) => (b : Or False a) => (f1 : (c : a) -> f0 (Or.inr False a c)) => Or.casesOn False a ((d : Or False a) => f0 d) b ((e : False) => False.casesOn ((f : False) => f0 (Or.inl False a f)) e) ((g : a) => f1 g)
thm false_or : (a : Prop) -> Eq Prop (Or False a) a
  (a : Prop) => propext (Or False a) a (Iff.intro (Or False a) a ((b : Or False a) => false_or.match_1 a (Or False a => a) b ((c : a) => c)) (Or.inr False a))
thm Iff.symm : (a : Prop) -> (b : Prop) -> Iff a b -> Iff b a
  (a : Prop) => (b : Prop) => (c : Iff a b) => Iff.intro b a (Iff.mpr a b c) (Iff.mp a b c)
thm or_iff_right_of_imp : (a : Prop) -> (b : Prop) -> (a -> b) -> Iff (Or a b) b
  (a : Prop) => (b : Prop) => (f0 : a -> b) => Iff.intro (Or a b) b ((c : Or a b) => Or.rec a b (Or a b => b) f0 (id b) c) (Or.inr a b)
thm Decidable.imp_or' : (a : Prop) -> (s0 : Sort(u_1)) -> (b : Prop) -> Decidable a -> Iff (s0 -> Or a b) (Or (s0 -> a) (s0 -> b))
  (a : Prop) => (s0 : Sort(u_1)) => (b : Prop) => (c : Decidable a) => dite (Iff (s0 -> Or a b) (Or (s0 -> a) (s0 -> b))) a c ((d : a) => of_eq_true (Iff ((e : s0) -> Or a b) (Or ((f : s0) -> a) ((g : s0) -> b))) (Eq.trans Prop (Iff ((h : s0) -> Or a b) (Or ((i : s0) -> a) ((j : s0) -> b))) (Iff True True) True (congr Prop Prop (Iff ((k : s0) -> Or a b)) (Iff True) (Or ((l : s0) -> a) ((m : s0) -> b)) True (congrArg Prop ((n : Prop) -> Prop) ((o : s0) -> Or a b) True Iff (Eq.trans Prop ((p : s0) -> Or a b) ((q : s0) -> True) True (implies_congr s0 s0 (Or a b) True (Eq.refl Sort(u_1) s0) (Eq.trans Prop (Or a b) (Or True b) True (congrArg Prop Prop a True ((r : Prop) => Or r b) (eq_true a d)) (true_or b))) (implies_true s0))) (Eq.trans Prop (Or ((s : s0) -> a) ((t : s0) -> b)) (Or True ((u : s0) -> b)) True (congrArg Prop Prop ((v : s0) -> a) True ((w : Prop) => Or w ((x : s0) -> b)) (Eq.trans Prop ((y : s0) -> a) ((z : s0) -> True) True (implies_congr s0 s0 a True (Eq.refl Sort(u_1) s0) (eq_true a d)) (implies_true s0))) (true_or ((A : s0) -> b)))) (iff_self True))) ((B : Not a) => Eq.mpr (Iff ((C : s0) -> Or a b) (Or ((D : s0) -> a) ((E : s0) -> b))) (Iff ((F : s0) -> Or False b) (Or ((G : s0) -> False) ((H : s0) -> b))) (id (Eq Prop (Iff ((I : s0) -> Or a b) (Or ((J : s0) -> a) ((K : s0) -> b))) (Iff ((L : s0) -> Or False b) (Or ((M : s0) -> False) ((N : s0) -> b)))) (congrArg Prop Prop a False ((O : Prop) => Iff ((P : s0) -> Or O b) (Or ((Q : s0) -> O) ((R : s0) -> b))) (eq_false a B))) (Eq.mpr (Iff ((S : s0) -> Or False b) (Or ((T : s0) -> False) ((U : s0) -> b))) (Iff ((V : s0) -> b) (Or ((W : s0) -> False) ((X : s0) -> b))) (id (Eq Prop (Iff ((Y : s0) -> Or False b) (Or ((Z : s0) -> False) ((x0 : s0) -> b))) (Iff ((x1 : s0) -> b) (Or ((x2 : s0) -> False) ((x3 : s0) -> b)))) (congrArg Prop Prop (Or False b) b ((x4 : Prop) => Iff ((x5 : s0) -> x4) (Or ((x6 : s0) -> False) ((x7 : s0) -> b))) (false_or b))) (Iff.symm (Or ((x8 : s0) -> False) ((x9 : s0) -> b)) ((x10 : s0) -> b) (or_iff_right_of_imp ((x11 : s0) -> False) ((x12 : s0) -> b) ((f0 : (x13 : s0) -> False) => (x14 : s0) => False.elim b (f0 x14))))))
thm not_of_not_imp : (a : Prop) -> (b : Prop) -> Not (b -> a) -> Not a
  (a : Prop) => (b : Prop) => mt a (b -> a) ((c : a) => (d : b) => c)
thm Decidable.not_imp_iff_and_not : (a : Prop) -> (b : Prop) -> Decidable a -> Iff (Not (a -> b)) (And a (Not b))
  (a : Prop) => (b : Prop) => (c : Decidable a) => Iff.intro (Not (a -> b)) (And a (Not b)) ((d : Not (a -> b)) => And.intro a (Not b) (Decidable.of_not_imp a b c d) (not_of_not_imp b a d)) (not_imp_of_and_not a b)
thm Decidable.peirce : (a : Prop) -> (b : Prop) -> Decidable a -> ((a -> b) -> a) -> a
  (a : Prop) => (b : Prop) => (c : Decidable a) => dite ((((d : a) -> b) -> a) -> a) a c ((e : a) => (f0 : (a -> b) -> a) => e) ((f : Not a) => (f1 : (a -> b) -> a) => f1 (Not.elim a b f))
thm peirce' : (a : Prop) -> ((b : Prop) -> (a -> b) -> a) -> a
  (a : Prop) => (f0 : (b : Prop) -> (a -> b) -> a) => f0 a (id a)
thm iff_iff_implies_and_implies : (a : Prop) -> (b : Prop) -> Iff (Iff a b) (And (a -> b) (b -> a))
  (a : Prop) => (b : Prop) => Iff.intro (Iff a b) (And (a -> b) (b -> a)) ((c : Iff a b) => And.intro (a -> b) (b -> a) (Iff.mp a b c) (Iff.mpr a b c)) ((d : And (a -> b) (b -> a)) => Iff.intro a b (And.left (a -> b) (b -> a) d) (And.right (a -> b) (b -> a) d))
thm iff_def : (a : Prop) -> (b : Prop) -> Iff (Iff a b) (And (a -> b) (b -> a))
  (a : Prop) => (b : Prop) => iff_iff_implies_and_implies a b
thm iff_def' : (a : Prop) -> (b : Prop) -> Iff (Iff a b) (And (b -> a) (a -> b))
  (a : Prop) => (b : Prop) => Iff.trans (Iff a b) (And (a -> b) (b -> a)) (And (b -> a) (a -> b)) (iff_def a b) (And.comm (a -> b) (b -> a))
thm Decidable.not_iff_not : (a : Prop) -> (b : Prop) -> Decidable a -> Decidable b -> Iff (Iff (Not a) (Not b)) (Iff a b)
  (a : Prop) => (b : Prop) => (c : Decidable a) => (d : Decidable b) => Eq.mpr (Iff (Iff (Not a) (Not b)) (Iff a b)) (Iff (And (Not a -> Not b) (Not b -> Not a)) (Iff a b)) (id (Eq Prop (Iff (Iff (Not a) (Not b)) (Iff a b)) (Iff (And (Not a -> Not b) (Not b -> Not a)) (Iff a b))) (congrArg Prop Prop (Iff (Not a) (Not b)) (And (Not a -> Not b) (Not b -> Not a)) ((e : Prop) => Iff e (Iff a b)) (propext (Iff (Not a) (Not b)) (And (Not a -> Not b) (Not b -> Not a)) (iff_def (Not a) (Not b))))) (Eq.mpr (Iff (And (Not a -> Not b) (Not b -> Not a)) (Iff a b)) (Iff (And (Not a -> Not b) (Not b -> Not a)) (And (b -> a) (a -> b))) (id (Eq Prop (Iff (And (Not a -> Not b) (Not b -> Not a)) (Iff a b)) (Iff (And (Not a -> Not b) (Not b -> Not a)) (And (b -> a) (a -> b)))) (congrArg Prop Prop (Iff a b) (And (b -> a) (a -> b)) ((f : Prop) => Iff (And (Not a -> Not b) (Not b -> Not a)) f) (propext (Iff a b) (And (b -> a) (a -> b)) (iff_def' a b)))) (and_congr (Not a -> Not b) (b -> a) (Not b -> Not a) (a -> b) (Decidable.not_imp_not a b c) (Decidable.not_imp_not b a d)))
thm Decidable.not_iff_comm : (a : Prop) -> (b : Prop) -> Decidable a -> Decidable b -> Iff (Iff (Not a) b) (Iff (Not b) a)
  (a : Prop) => (b : Prop) => (c : Decidable a) => (d : Decidable b) => Eq.mpr (Iff (Iff (Not a) b) (Iff (Not b) a)) (Iff (And (Not a -> b) (b -> Not a)) (Iff (Not b) a)) (id (Eq Prop (Iff (Iff (Not a) b) (Iff (Not b) a)) (Iff (And (Not a -> b) (b -> Not a)) (Iff (Not b) a))) (congrArg Prop Prop (Iff (Not a) b) (And (Not a -> b) (b -> Not a)) ((e : Prop) => Iff e (Iff (Not b) a)) (propext (Iff (Not a) b) (And (Not a -> b) (b -> Not a)) (iff_def (Not a) b)))) (Eq.mpr (Iff (And (Not a -> b) (b -> Not a)) (Iff (Not b) a)) (Iff (And (Not a -> b) (b -> Not a)) (And (Not b -> a) (a -> Not b))) (id (Eq Prop (Iff (And (Not a -> b) (b -> Not a)) (Iff (Not b) a)) (Iff (And (Not a -> b) (b -> Not a)) (And (Not b -> a) (a -> Not b)))) (congrArg Prop Prop (Iff (Not b) a) (And (Not b -> a) (a -> Not b)) ((f : Prop) => Iff (And (Not a -> b) (b -> Not a)) f) (propext (Iff (Not b) a) (And (Not b -> a) (a -> Not b)) (iff_def (Not b) a)))) (and_congr (Not a -> b) (Not b -> a) (b -> Not a) (a -> Not b) (Decidable.not_imp_comm a b c d) (imp_not_comm b a)))
thm Iff.comm : (a : Prop) -> (b : Prop) -> Iff (Iff a b) (Iff b a)
  (a : Prop) => (b : Prop) => Iff.intro (Iff a b) (Iff b a) (Iff.symm a b) (Iff.symm b a)
thm iff_true_left : (a : Prop) -> (b : Prop) -> a -> Iff (Iff a b) b
  (a : Prop) => (b : Prop) => (c : a) => Iff.intro (Iff a b) b ((d : Iff a b) => Iff.mp a b d c) (iff_of_true a b c)
thm iff_true_right : (a : Prop) -> (b : Prop) -> a -> Iff (Iff b a) b
  (a : Prop) => (b : Prop) => (c : a) => Iff.trans (Iff b a) (Iff a b) b (Iff.comm b a) (iff_true_left a b c)
thm iff_false_left : (a : Prop) -> (b : Prop) -> Not a -> Iff (Iff a b) (Not b)
  (a : Prop) => (b : Prop) => (c : Not a) => Iff.intro (Iff a b) (Not b) ((d : Iff a b) => mt b a (Iff.mpr a b d) c) (iff_of_false a b c)
thm iff_false_right : (a : Prop) -> (b : Prop) -> Not a -> Iff (Iff b a) (Not b)
  (a : Prop) => (b : Prop) => (c : Not a) => Iff.trans (Iff b a) (Iff a b) (Not b) (Iff.comm b a) (iff_false_left a b c)
thm Decidable.not_iff : (a : Prop) -> (b : Prop) -> Decidable a -> Iff (Not (Iff b a)) (Iff (Not b) a)
  (a : Prop) => (b : Prop) => (c : Decidable a) => dite (Iff (Not (Iff b a)) (Iff (Not b) a)) a c ((d : a) => Eq.mpr (Iff (Not (Iff b a)) (Iff (Not b) a)) (Iff (Not b) (Iff (Not b) a)) (id (Eq Prop (Iff (Not (Iff b a)) (Iff (Not b) a)) (Iff (Not b) (Iff (Not b) a))) (congrArg Prop Prop (Iff b a) b ((e : Prop) => Iff (Not e) (Iff (Not b) a)) (propext (Iff b a) b (iff_true_right a b d)))) (Eq.mpr (Iff (Not b) (Iff (Not b) a)) (Iff (Not b) (Not b)) (id (Eq Prop (Iff (Not b) (Iff (Not b) a)) (Iff (Not b) (Not b))) (congrArg Prop Prop (Iff (Not b) a) (Not b) ((f : Prop) => Iff (Not b) f) (propext (Iff (Not b) a) (Not b) (iff_true_right a (Not b) d)))) (Iff.rfl (Not b)))) ((g : Not a) => Eq.mpr (Iff (Not (Iff b a)) (Iff (Not b) a)) (Iff (Not (Not b)) (Iff (Not b) a)) (id (Eq Prop (Iff (Not (Iff b a)) (Iff (Not b) a)) (Iff (Not (Not b)) (Iff (Not b) a))) (congrArg Prop Prop (Iff b a) (Not b) ((h : Prop) => Iff (Not h) (Iff (Not b) a)) (propext (Iff b a) (Not b) (iff_false_right a b g)))) (Eq.mpr (Iff (Not (Not b)) (Iff (Not b) a)) (Iff (Not (Not b)) (Not (Not b))) (id (Eq Prop (Iff (Not (Not b)) (Iff (Not b) a)) (Iff (Not (Not b)) (Not (Not b)))) (congrArg Prop Prop (Iff (Not b) a) (Not (Not b)) ((i : Prop) => Iff (Not (Not b)) i) (propext (Iff (Not b) a) (Not (Not b)) (iff_false_right a (Not b) g)))) (Iff.rfl (Not (Not b)))))
thm Decidable.iff_not_comm : (a : Prop) -> (b : Prop) -> Decidable a -> Decidable b -> Iff (Iff a (Not b)) (Iff b (Not a))
  (a : Prop) => (b : Prop) => (c : Decidable a) => (d : Decidable b) => Eq.mpr (Iff (Iff a (Not b)) (Iff b (Not a))) (Iff (And (a -> Not b) (Not b -> a)) (Iff b (Not a))) (id (Eq Prop (Iff (Iff a (Not b)) (Iff b (Not a))) (Iff (And (a -> Not b) (Not b -> a)) (Iff b (Not a)))) (congrArg Prop Prop (Iff a (Not b)) (And (a -> Not b) (Not b -> a)) ((e : Prop) => Iff e (Iff b (Not a))) (propext (Iff a (Not b)) (And (a -> Not b) (Not b -> a)) (iff_def a (Not b))))) (Eq.mpr (Iff (And (a -> Not b) (Not b -> a)) (Iff b (Not a))) (Iff (And (a -> Not b) (Not b -> a)) (And (b -> Not a) (Not a -> b))) (id (Eq Prop (Iff (And (a -> Not b) (Not b -> a)) (Iff b (Not a))) (Iff (And (a -> Not b) (Not b -> a)) (And (b -> Not a) (Not a -> b)))) (congrArg Prop Prop (Iff b (Not a)) (And (b -> Not a) (Not a -> b)) ((f : Prop) => Iff (And (a -> Not b) (Not b -> a)) f) (propext (Iff b (Not a)) (And (b -> Not a) (Not a -> b)) (iff_def b (Not a))))) (and_congr (a -> Not b) (b -> Not a) (Not b -> a) (Not a -> b) (imp_not_comm a b) (Decidable.not_imp_comm b a d c)))
thm Decidable.iff_iff_and_or_not_and_not : (a : Prop) -> (b : Prop) -> Decidable b -> Iff (Iff a b) (Or (And a b) (And (Not a) (Not b)))
  (a : Prop) => (b : Prop) => (c : Decidable b) => Iff.intro (Iff a b) (Or (And a b) (And (Not a) (Not b))) ((d : Iff a b) => dite (Or (And a b) (And (Not a) (Not b))) b c ((e : b) => Or.inl (And a b) (And (Not a) (Not b)) (And.intro a b (Iff.mpr a b d e) e)) ((f : Not b) => Or.inr (And a b) (And (Not a) (Not b)) (And.intro (Not a) (Not b) (mt a b (Iff.mp a b d) f) f))) ((g : Or (And a b) (And (Not a) (Not b))) => Or.rec (And a b) (And (Not a) (Not b)) (Or (And a b) (And (Not a) (Not b)) => Iff a b) ((h : And a b) => And.rec a b (And a b => Iff a b) (iff_of_true a b) h) ((i : And (Not a) (Not b)) => And.rec (Not a) (Not b) (And (Not a) (Not b) => Iff a b) (iff_of_false a b) i) g)
thm Init.PropLemmas._auxLemma.54 : (a : Prop) -> (b : Prop) -> Decidable a -> Eq Prop (a -> b) (Or (Not a) b)
  (a : Prop) => (b : Prop) => (c : Decidable a) => propext (a -> b) (Or (Not a) b) (Decidable.imp_iff_not_or a b c)
thm Decidable.iff_iff_not_or_and_or_not : (a : Prop) -> (b : Prop) -> Decidable a -> Decidable b -> Iff (Iff a b) (And (Or (Not a) b) (Or a (Not b)))
  (a : Prop) => (b : Prop) => (c : Decidable a) => (d : Decidable b) => Eq.mpr (Iff (Iff a b) (And (Or (Not a) b) (Or a (Not b)))) (Iff (And (a -> b) (b -> a)) (And (Or (Not a) b) (Or a (Not b)))) (id (Eq Prop (Iff (Iff a b) (And (Or (Not a) b) (Or a (Not b)))) (Iff (And (a -> b) (b -> a)) (And (Or (Not a) b) (Or a (Not b))))) (congrArg Prop Prop (Iff a b) (And (a -> b) (b -> a)) ((e : Prop) => Iff e (And (Or (Not a) b) (Or a (Not b)))) (propext (Iff a b) (And (a -> b) (b -> a)) (iff_iff_implies_and_implies a b)))) (of_eq_true (Iff (And (a -> b) (b -> a)) (And (Or (Not a) b) (Or a (Not b)))) (Eq.trans Prop (Iff (And (a -> b) (b -> a)) (And (Or (Not a) b) (Or a (Not b)))) (Iff (And (Or b (Not a)) (Or a (Not b))) (And (Or b (Not a)) (Or a (Not b)))) True (congr Prop Prop (Iff (And (a -> b) (b -> a))) (Iff (And (Or b (Not a)) (Or a (Not b)))) (And (Or (Not a) b) (Or a (Not b))) (And (Or b (Not a)) (Or a (Not b))) (congrArg Prop ((f : Prop) -> Prop) (And (a -> b) (b -> a)) (And (Or b (Not a)) (Or a (Not b))) Iff (congr Prop Prop (And (a -> b)) (And (Or b (Not a))) (b -> a) (Or a (Not b)) (congrArg Prop ((g : Prop) -> Prop) (a -> b) (Or b (Not a)) And (Eq.trans Prop (a -> b) (Or (Not a) b) (Or b (Not a)) (Init.PropLemmas._auxLemma.54 a b c) (Init.PropLemmas._auxLemma.3 (Not a) b))) (Eq.trans Prop (b -> a) (Or (Not b) a) (Or a (Not b)) (Init.PropLemmas._auxLemma.54 b a d) (Init.PropLemmas._auxLemma.3 (Not b) a)))) (congrArg Prop Prop (Or (Not a) b) (Or b (Not a)) ((h : Prop) => And h (Or a (Not b))) (Init.PropLemmas._auxLemma.3 (Not a) b))) (iff_self (And (Or b (Not a)) (Or a (Not b))))))
def Decidable.not_and_not_right.match_1 := (a : Prop) => (b : Prop) => (f0 : And b (Not a) -> Prop) => (c : And b (Not a)) => (f1 : (d : b) -> (e : Not a) -> f0 (And.intro b (Not a) d e)) => And.casesOn b (Not a) ((f : And b (Not a)) => f0 f) c ((g : b) => (h : Not a) => f1 g h)
thm Decidable.not_and_not_right : (a : Prop) -> (b : Prop) -> Decidable a -> Iff (Not (And b (Not a))) (b -> a)
  (a : Prop) => (b : Prop) => (c : Decidable a) => Iff.intro (Not (And b (Not a))) (b -> a) ((d : Not (And b (Not a))) => (e : b) => Decidable.not_imp_symm a (And b (Not a)) c (And.intro b (Not a) e) d) ((f0 : b -> a) => (f : And b (Not a)) => Decidable.not_and_not_right.match_1 a b (And b (Not a) => False) f ((g : b) => (h : Not a) => h (f0 g)))
thm Decidable.not_and_iff_or_not_not : (a : Prop) -> (b : Prop) -> Decidable a -> Iff (Not (And a b)) (Or (Not a) (Not b))
  (a : Prop) => (b : Prop) => (c : Decidable a) => Iff.intro (Not (And a b)) (Or (Not a) (Not b)) ((d : Not (And a b)) => dite (Or (Not a) (Not b)) a c ((e : a) => Or.inr (Not a) (Not b) ((f : b) => d (And.intro a b e f))) ((g : Not a) => Or.inl (Not a) (Not b) g)) (not_and_of_not_or_not a b)
thm Decidable.not_and_iff_or_not_not' : (a : Prop) -> (b : Prop) -> Decidable a -> Iff (Not (And b a)) (Or (Not b) (Not a))
  (a : Prop) => (b : Prop) => (c : Decidable a) => Iff.intro (Not (And b a)) (Or (Not b) (Not a)) ((d : Not (And b a)) => dite (Or (Not b) (Not a)) a c ((e : a) => Or.inl (Not b) (Not a) ((f : b) => d (And.intro b a f e))) ((g : Not a) => Or.inr (Not b) (Not a) g)) (not_and_of_not_or_not b a)
thm not_or : (a : Prop) -> (b : Prop) -> Iff (Not (Or a b)) (And (Not a) (Not b))
  (a : Prop) => (b : Prop) => or_imp a b False
thm instDecidableOr.proof_1 : (a : Prop) -> (b : Prop) -> Not a -> Not b -> Or a b -> False
  (a : Prop) => (b : Prop) => (c : Not a) => (d : Not b) => (e : Or a b) => Or.elim.match_1 a b (Or a b => False) e ((f : a) => c f) ((g : b) => d g)
def instDecidableOr := (a : Prop) => (b : Prop) => (c : Decidable a) => (d : Decidable b) => instDecidableAnd.match_1 a (Decidable a => Decidable (Or a b)) c ((e : a) => Decidable.isTrue (Or a b) (Or.inl a b e)) ((f : Not a) => instDecidableAnd.match_1 b (Decidable b => Decidable (Or a b)) d ((g : b) => Decidable.isTrue (Or a b) (Or.inr a b g)) ((h : Not b) => Decidable.isFalse (Or a b) (instDecidableOr.proof_1 a b f h)))
thm Decidable.or_iff_not_and_not : (a : Prop) -> (b : Prop) -> Decidable a -> Decidable b -> Iff (Or a b) (Not (And (Not a) (Not b)))
  (a : Prop) => (b : Prop) => (c : Decidable a) => (d : Decidable b) => Eq.mpr (Iff (Or a b) (Not (And (Not a) (Not b)))) (Iff (Or a b) (Not (Not (Or a b)))) (id (Eq Prop (Iff (Or a b) (Not (And (Not a) (Not b)))) (Iff (Or a b) (Not (Not (Or a b))))) (congrArg Prop Prop (And (Not a) (Not b)) (Not (Or a b)) ((e : Prop) => Iff (Or a b) (Not e)) (Eq.symm Prop (Not (Or a b)) (And (Not a) (Not b)) (propext (Not (Or a b)) (And (Not a) (Not b)) (not_or a b))))) (Eq.mpr (Iff (Or a b) (Not (Not (Or a b)))) (Iff (Or a b) (Or a b)) (id (Eq Prop (Iff (Or a b) (Not (Not (Or a b)))) (Iff (Or a b) (Or a b))) (congrArg Prop Prop (Not (Not (Or a b))) (Or a b) ((f : Prop) => Iff (Or a b) f) (propext (Not (Not (Or a b))) (Or a b) (Decidable.not_not (Or a b) (instDecidableOr a b c d))))) (Iff.rfl (Or a b)))
thm instDecidableAnd.proof_1 : (a : Prop) -> (b : Prop) -> Not b -> And a b -> False
  (a : Prop) => (b : Prop) => (c : Not b) => (d : And a b) => c (And.right a b d)
thm instDecidableAnd.proof_2 : (a : Prop) -> (b : Prop) -> Not a -> And a b -> False
  (a : Prop) => (b : Prop) => (c : Not a) => (d : And a b) => c (And.left a b d)
def instDecidableAnd := (a : Prop) => (b : Prop) => (c : Decidable a) => (d : Decidable b) => instDecidableAnd.match_1 a (Decidable a => Decidable (And a b)) c ((e : a) => instDecidableAnd.match_1 b (Decidable b => Decidable (And a b)) d ((f : b) => Decidable.isTrue (And a b) (And.intro a b e f)) ((g : Not b) => Decidable.isFalse (And a b) (instDecidableAnd.proof_1 a b g))) ((h : Not a) => Decidable.isFalse (And a b) (instDecidableAnd.proof_2 a b h))
thm Decidable.and_iff_not_or_not : (a : Prop) -> (b : Prop) -> Decidable a -> Decidable b -> Iff (And a b) (Not (Or (Not a) (Not b)))
  (a : Prop) => (b : Prop) => (c : Decidable a) => (d : Decidable b) => Eq.mpr (Iff (And a b) (Not (Or (Not a) (Not b)))) (Iff (And a b) (Not (Not (And a b)))) (id (Eq Prop (Iff (And a b) (Not (Or (Not a) (Not b)))) (Iff (And a b) (Not (Not (And a b))))) (congrArg Prop Prop (Or (Not a) (Not b)) (Not (And a b)) ((e : Prop) => Iff (And a b) (Not e)) (Eq.symm Prop (Not (And a b)) (Or (Not a) (Not b)) (propext (Not (And a b)) (Or (Not a) (Not b)) (Decidable.not_and_iff_or_not_not a b c))))) (Eq.mpr (Iff (And a b) (Not (Not (And a b)))) (Iff (And a b) (And a b)) (id (Eq Prop (Iff (And a b) (Not (Not (And a b)))) (Iff (And a b) (And a b))) (congrArg Prop Prop (Not (Not (And a b))) (And a b) ((f : Prop) => Iff (And a b) f) (propext (Not (Not (And a b))) (And a b) (Decidable.not_not (And a b) (instDecidableAnd a b c d))))) (Iff.rfl (And a b)))
thm Decidable.imp_iff_right_iff : (a : Prop) -> (b : Prop) -> Decidable a -> Iff (Iff (a -> b) b) (Or a b)
  (a : Prop) => (b : Prop) => (c : Decidable a) => Iff.intro (Iff ((d : a) -> b) b) (Or a b) ((e : Iff ((f : a) -> b) b) => Or.imp_right (Not a) b a ((g : Not a) => Iff.mp ((h : a) -> b) b e ((i : a) => False.elim b (g i))) (Decidable.em a c)) ((j : Or a b) => Or.elim a b (Iff (a -> b) b) j (imp_iff_right b a) ((k : b) => iff_of_true ((l : a) -> b) b ((m : a) => k) k))
thm Decidable.imp_iff_left_iff : (a : Prop) -> (b : Prop) -> Decidable a -> Iff (Iff b (a -> b)) (Or a b)
  (a : Prop) => (b : Prop) => (c : Decidable a) => Eq.rec Prop (Iff (a -> b) b) ((d : Prop) => Eq Prop (Iff (a -> b) b) d => Iff d (Or a b)) (Decidable.imp_iff_right_iff a b c) (Iff b (a -> b)) (propext (Iff (a -> b) b) (Iff b (a -> b)) (Iff.comm (a -> b) b))
thm true_imp_iff : (a : Prop) -> Iff (True -> a) a
  (a : Prop) => imp_iff_right a True True.intro
thm Init.PropLemmas._auxLemma.55 : (a : Prop) -> Eq Prop (True -> a) a
  (a : Prop) => propext (True -> a) a (true_imp_iff a)
thm Init.PropLemmas._auxLemma.56 : (a : Prop) -> Eq Prop (False -> a) True
  (a : Prop) => propext (False -> a) True (false_imp_iff a)
thm Decidable.and_or_imp : (a : Prop) -> (b : Prop) -> (c : Prop) -> Decidable a -> Iff (Or (And a b) (a -> c)) (a -> Or b c)
  (a : Prop) => (b : Prop) => (c : Prop) => (d : Decidable a) => dite (Iff (Or (And a b) ((e : a) -> c)) ((f : a) -> Or b c)) a d ((g : a) => of_eq_true (Iff (Or (And a b) (a -> c)) (a -> Or b c)) (Eq.trans Prop (Iff (Or (And a b) (a -> c)) (a -> Or b c)) (Iff (Or b c) (Or b c)) True (congr Prop Prop (Iff (Or (And a b) (a -> c))) (Iff (Or b c)) (a -> Or b c) (Or b c) (congrArg Prop ((h : Prop) -> Prop) (Or (And a b) (a -> c)) (Or b c) Iff (congr Prop Prop (Or (And a b)) (Or b) (a -> c) c (congrArg Prop ((i : Prop) -> Prop) (And a b) b Or (Eq.trans Prop (And a b) (And True b) b (congrArg Prop Prop a True ((j : Prop) => And j b) (eq_true a g)) (true_and b))) (Eq.trans Prop (a -> c) (True -> c) c (implies_congr a True c c (eq_true a g) (Eq.refl Prop c)) (Init.PropLemmas._auxLemma.55 c)))) (Eq.trans Prop (a -> Or b c) (True -> Or b c) (Or b c) (implies_congr a True (Or b c) (Or b c) (eq_true a g) (Eq.refl Prop (Or b c))) (Init.PropLemmas._auxLemma.55 (Or b c)))) (iff_self (Or b c)))) ((k : Not a) => of_eq_true (Iff (Or (And a b) (a -> c)) (a -> Or b c)) (Eq.trans Prop (Iff (Or (And a b) (a -> c)) (a -> Or b c)) (Iff True True) True (congr Prop Prop (Iff (Or (And a b) (a -> c))) (Iff True) (a -> Or b c) True (congrArg Prop ((l : Prop) -> Prop) (Or (And a b) (a -> c)) True Iff (Eq.trans Prop (Or (And a b) (a -> c)) (Or False True) True (congr Prop Prop (Or (And a b)) (Or False) (a -> c) True (congrArg Prop ((m : Prop) -> Prop) (And a b) False Or (Eq.trans Prop (And a b) (And False b) False (congrArg Prop Prop a False ((n : Prop) => And n b) (eq_false a k)) (false_and b))) (Eq.trans Prop (a -> c) (False -> c) True (implies_congr a False c c (eq_false a k) (Eq.refl Prop c)) (Init.PropLemmas._auxLemma.56 c))) (false_or True))) (Eq.trans Prop (a -> Or b c) (False -> Or b c) True (implies_congr a False (Or b c) (Or b c) (eq_false a k) (Eq.refl Prop (Or b c))) (Init.PropLemmas._auxLemma.56 (Or b c)))) (iff_self True)))
thm imp_congr_right : (a : Prop) -> (b : Prop) -> (c : Prop) -> (a -> Iff b c) -> Iff (a -> b) (a -> c)
  (a : Prop) => (b : Prop) => (c : Prop) => (f0 : a -> Iff b c) => Iff.intro (a -> b) (a -> c) ((f1 : a -> b) => (d : a) => Iff.mp b c (f0 d) (f1 d)) ((f2 : a -> c) => (e : a) => Iff.mpr b c (f0 e) (f2 e))
thm Decidable.or_congr_left' : (a : Prop) -> (b : Prop) -> (c : Prop) -> Decidable a -> (Not a -> Iff b c) -> Iff (Or b a) (Or c a)
  (a : Prop) => (b : Prop) => (c : Prop) => (d : Decidable a) => (f0 : Not a -> Iff b c) => Eq.mpr (Iff (Or b a) (Or c a)) (Iff (Not a -> b) (Or c a)) (id (Eq Prop (Iff (Or b a) (Or c a)) (Iff (Not a -> b) (Or c a))) (congrArg Prop Prop (Or b a) (Not a -> b) ((e : Prop) => Iff e (Or c a)) (propext (Or b a) (Not a -> b) (Decidable.or_iff_not_imp_right a b d)))) (Eq.mpr (Iff (Not a -> b) (Or c a)) (Iff (Not a -> b) (Not a -> c)) (id (Eq Prop (Iff (Not a -> b) (Or c a)) (Iff (Not a -> b) (Not a -> c))) (congrArg Prop Prop (Or c a) (Not a -> c) ((f : Prop) => Iff (Not a -> b) f) (propext (Or c a) (Not a -> c) (Decidable.or_iff_not_imp_right a c d)))) (imp_congr_right (Not a) b c f0))
thm Decidable.or_congr_right' : (a : Prop) -> (b : Prop) -> (c : Prop) -> Decidable a -> (Not a -> Iff b c) -> Iff (Or a b) (Or a c)
  (a : Prop) => (b : Prop) => (c : Prop) => (d : Decidable a) => (f0 : Not a -> Iff b c) => Eq.mpr (Iff (Or a b) (Or a c)) (Iff (Not a -> b) (Or a c)) (id (Eq Prop (Iff (Or a b) (Or a c)) (Iff (Not a -> b) (Or a c))) (congrArg Prop Prop (Or a b) (Not a -> b) ((e : Prop) => Iff e (Or a c)) (propext (Or a b) (Not a -> b) (Decidable.or_iff_not_imp_left a b d)))) (Eq.mpr (Iff (Not a -> b) (Or a c)) (Iff (Not a -> b) (Not a -> c)) (id (Eq Prop (Iff (Not a -> b) (Or a c)) (Iff (Not a -> b) (Not a -> c))) (congrArg Prop Prop (Or a c) (Not a -> c) ((f : Prop) => Iff (Not a -> b) f) (propext (Or a c) (Not a -> c) (Decidable.or_iff_not_imp_left a c d)))) (imp_congr_right (Not a) b c f0))
thm Eq.mpr_prop : (a : Prop) -> (b : Prop) -> Eq Prop a b -> b -> a
  (a : Prop) => (b : Prop) => (c : Eq Prop a b) => (d : b) => Eq.rec Prop b ((e : Prop) => Eq Prop b e => e) d a (Eq.symm Prop a b c)
thm Eq.mpr_not : (a : Prop) -> (b : Prop) -> Eq Prop a b -> Not b -> Not a
  (a : Prop) => (b : Prop) => (c : Eq Prop a b) => (d : Not b) => Eq.rec Prop b ((e : Prop) => Eq Prop b e => Not e) d a (Eq.symm Prop a b c)
def if_pos.match_1 := (a : Prop) => (f0 : Decidable a -> Prop) => (b : Decidable a) => (f1 : (c : a) -> f0 (Decidable.isTrue a c)) => (f2 : (d : Not a) -> f0 (Decidable.isFalse a d)) => Decidable.casesOn a ((e : Decidable a) => f0 e) b ((f : Not a) => f2 f) ((g : a) => f1 g)
thm dif_pos : (a : Prop) -> (b : Decidable a) -> (c : a) -> (s0 : Sort(u)) -> (f0 : a -> s0) -> (f1 : Not a -> s0) -> Eq s0 (dite s0 a b f0 f1) (f0 c)
  (a : Prop) => (b : Decidable a) => (c : a) => (s0 : Sort(u)) => (f0 : a -> s0) => (f1 : Not a -> s0) => if_pos.match_1 a ((d : Decidable a) => Eq s0 (dite s0 a d f0 f1) (f0 c)) b ((e : a) => rfl s0 (dite s0 a (Decidable.isTrue a e) f0 f1)) ((f : Not a) => absurd a (Eq s0 (dite s0 a (Decidable.isFalse a f) f0 f1) (f0 c)) c f)
thm dif_neg : (a : Prop) -> (b : Decidable a) -> (c : Not a) -> (s0 : Sort(u)) -> (f0 : a -> s0) -> (f1 : Not a -> s0) -> Eq s0 (dite s0 a b f0 f1) (f1 c)
  (a : Prop) => (b : Decidable a) => (c : Not a) => (s0 : Sort(u)) => (f0 : a -> s0) => (f1 : Not a -> s0) => if_pos.match_1 a ((d : Decidable a) => Eq s0 (dite s0 a d f0 f1) (f1 c)) b ((e : a) => absurd a (Eq s0 (dite s0 a (Decidable.isTrue a e) f0 f1) (f1 c)) e c) ((f : Not a) => rfl s0 (dite s0 a (Decidable.isFalse a f) f0 f1))
thm dite_congr : (a : Prop) -> (b : Prop) -> (s0 : Sort(u_1)) -> (c : Decidable a) -> (d : Decidable b) -> (f0 : a -> s0) -> (f1 : b -> s0) -> (f2 : Not a -> s0) -> (f3 : Not b -> s0) -> (e : Eq Prop a b) -> ((f : b) -> Eq s0 (f0 (Eq.mpr_prop a b e f)) (f1 f)) -> ((g : Not b) -> Eq s0 (f2 (Eq.mpr_not a b e g)) (f3 g)) -> Eq s0 (dite s0 a c f0 f2) (dite s0 b d f1 f3)
  (a : Prop) => (b : Prop) => (s0 : Sort(u_1)) => (c : Decidable a) => (d : Decidable b) => (f0 : a -> s0) => (f1 : b -> s0) => (f2 : Not a -> s0) => (f3 : Not b -> s0) => (e : Eq Prop a b) => (f4 : (f : b) -> Eq s0 (f0 (Eq.mpr_prop a b e f)) (f1 f)) => (f5 : (g : Not b) -> Eq s0 (f2 (Eq.mpr_not a b e g)) (f3 g)) => Or.casesOn b (Not b) ((h : Or b (Not b)) => (Eq (Or b (Not b)) (Decidable.em b d) h -> Eq s0 (dite s0 a c f0 f2) (dite s0 b d f1 f3))) (Decidable.em b d) ((i : b) => Eq (Or b (Not b)) (Decidable.em b d) (Or.inl b (Not b) i) => Eq.mpr (Eq s0 (dite s0 a c f0 f2) (dite s0 b d f1 f3)) (Eq s0 (dite s0 a c f0 f2) (f1 i)) (id (Eq Prop (Eq s0 (dite s0 a c f0 f2) (dite s0 b d f1 f3)) (Eq s0 (dite s0 a c f0 f2) (f1 i))) (congrArg s0 Prop (dite s0 b d f1 f3) (f1 i) ((j : s0) => Eq s0 (dite s0 a c f0 f2) j) (dif_pos b d i s0 f1 f3))) (Eq.rec Prop b ((k : Prop) => (l : Eq Prop b k) => ((m : Decidable k) -> (f6 : k -> s0) -> (f7 : Not k -> s0) -> ((n : b) -> Eq s0 (f6 (Eq.mpr_prop k b (Eq.symm Prop b k l) n)) (f1 n)) -> ((o : Not b) -> Eq s0 (f7 (Eq.mpr_not k b (Eq.symm Prop b k l) o)) (f3 o)) -> Eq s0 (dite s0 k m f6 f7) (f1 i))) ((p : Decidable b) => (f8 : b -> s0) => (f9 : Not b -> s0) => (f10 : (q : b) -> Eq s0 (f8 (Eq.mpr_prop b b (Eq.refl Prop b) q)) (f1 q)) => (f11 : (r : Not b) -> Eq s0 (f9 (Eq.mpr_not b b (Eq.refl Prop b) r)) (f3 r)) => Eq.mpr (Eq s0 (dite s0 b p f8 f9) (f1 i)) (Eq s0 (f8 i) (f1 i)) (id (Eq Prop (Eq s0 (dite s0 b p f8 f9) (f1 i)) (Eq s0 (f8 i) (f1 i))) (congrArg s0 Prop (dite s0 b p f8 f9) (f8 i) ((s : s0) => Eq s0 s (f1 i)) (dif_pos b p i s0 f8 f9))) (f10 i)) a (Eq.symm Prop a b e) c f0 f2 f4 f5)) ((t : Not b) => Eq (Or b (Not b)) (Decidable.em b d) (Or.inr b (Not b) t) => Eq.mpr (Eq s0 (dite s0 a c f0 f2) (dite s0 b d f1 f3)) (Eq s0 (dite s0 a c f0 f2) (f3 t)) (id (Eq Prop (Eq s0 (dite s0 a c f0 f2) (dite s0 b d f1 f3)) (Eq s0 (dite s0 a c f0 f2) (f3 t))) (congrArg s0 Prop (dite s0 b d f1 f3) (f3 t) ((u : s0) => Eq s0 (dite s0 a c f0 f2) u) (dif_neg b d t s0 f1 f3))) (Eq.rec Prop b ((v : Prop) => (w : Eq Prop b v) => ((x : Decidable v) -> (f12 : v -> s0) -> (f13 : Not v -> s0) -> ((y : b) -> Eq s0 (f12 (Eq.mpr_prop v b (Eq.symm Prop b v w) y)) (f1 y)) -> ((z : Not b) -> Eq s0 (f13 (Eq.mpr_not v b (Eq.symm Prop b v w) z)) (f3 z)) -> Eq s0 (dite s0 v x f12 f13) (f3 t))) ((A : Decidable b) => (f14 : b -> s0) => (f15 : Not b -> s0) => (f16 : (B : b) -> Eq s0 (f14 (Eq.mpr_prop b b (Eq.refl Prop b) B)) (f1 B)) => (f17 : (C : Not b) -> Eq s0 (f15 (Eq.mpr_not b b (Eq.refl Prop b) C)) (f3 C)) => Eq.mpr (Eq s0 (dite s0 b A f14 f15) (f3 t)) (Eq s0 (f15 t) (f3 t)) (id (Eq Prop (Eq s0 (dite s0 b A f14 f15) (f3 t)) (Eq s0 (f15 t) (f3 t))) (congrArg s0 Prop (dite s0 b A f14 f15) (f15 t) ((D : s0) => Eq s0 D (f3 t)) (dif_neg b A t s0 f14 f15))) (f17 t)) a (Eq.symm Prop a b e) c f0 f2 f4 f5)) (Eq.refl (Or b (Not b)) (Decidable.em b d))
thm dite_cond_eq_true : (s0 : Sort(u)) -> (a : Prop) -> (b : Decidable a) -> (f0 : a -> s0) -> (f1 : Not a -> s0) -> (c : Eq Prop a True) -> Eq s0 (dite s0 a b f0 f1) (f0 (of_eq_true a c))
  (s0 : Sort(u)) => (a : Prop) => (b : Decidable a) => (f0 : a -> s0) => (f1 : Not a -> s0) => (c : Eq Prop a True) => of_eq_true (Eq s0 (dite s0 a b f0 f1) (f0 (of_eq_true a c))) (Eq.trans Prop (Eq s0 (dite s0 a b f0 f1) (f0 (of_eq_true a c))) (Eq s0 (dite s0 True instDecidableTrue ((d : True) => f0 (Eq.mpr_prop a True c d)) ((e : Not True) => f1 (Eq.mpr_not a True c e))) (f0 (of_eq_true a c))) True (congrArg s0 Prop (dite s0 a b f0 f1) (dite s0 True instDecidableTrue ((f : True) => f0 (Eq.mpr_prop a True c f)) ((g : Not True) => f1 (Eq.mpr_not a True c g))) ((h : s0) => Eq s0 h (f0 (of_eq_true a c))) (dite_congr a True s0 b instDecidableTrue f0 ((i : True) => f0 (Eq.mpr_prop a True c i)) f1 ((j : Not True) => f1 (Eq.mpr_not a True c j)) c ((k : True) => Eq.refl s0 (f0 (Eq.mpr_prop a True c k))) ((l : Not True) => Eq.refl s0 (f1 (Eq.mpr_not a True c l))))) (eq_self s0 (f0 (Eq.mpr_prop a True c True.intro))))
def Subsingleton : Sort(u) -> Prop
def Subsingleton.allEq : (s0 : Sort(u)) -> Subsingleton s0 -> (a : s0) -> (b : s0) -> Eq s0 a b
thm Subsingleton.elim : (s0 : Sort(u)) -> Subsingleton s0 -> (a : s0) -> (b : s0) -> Eq s0 a b
  (s0 : Sort(u)) => (a : Subsingleton s0) => Subsingleton.allEq s0 a
def Subsingleton.intro : (s0 : Sort(u)) -> ((a : s0) -> (b : s0) -> Eq s0 a b) -> Subsingleton s0
thm instSubsingletonDecidable : (a : Prop) -> Subsingleton (Decidable a)
  (a : Prop) => Subsingleton.intro (Decidable a) ((b : Decidable a) => if_pos.match_1 a ((c : Decidable a) => ((d : Decidable a) -> Eq (Decidable a) c d)) b ((e : a) => (f : Decidable a) => if_pos.match_1 a ((g : Decidable a) => Eq (Decidable a) (Decidable.isTrue a e) g) f ((h : a) => rfl (Decidable a) (Decidable.isTrue a e)) ((i : Not a) => absurd a (Eq (Decidable a) (Decidable.isTrue a e) (Decidable.isFalse a i)) e i)) ((j : Not a) => (k : Decidable a) => if_pos.match_1 a ((l : Decidable a) => Eq (Decidable a) (Decidable.isFalse a j) l) k ((m : a) => absurd a (Eq (Decidable a) (Decidable.isFalse a j) (Decidable.isTrue a m)) m j) ((n : Not a) => rfl (Decidable a) (Decidable.isFalse a j))))
thm decide_eq_decide : (a : Prop) -> (b : Prop) -> (c : Decidable a) -> (d : Decidable b) -> Iff (Eq Bool (Decidable.decide a c) (Decidable.decide b d)) (Iff a b)
  (a : Prop) => (b : Prop) => (c : Decidable a) => (d : Decidable b) => Iff.intro (Eq Bool (Decidable.decide a c) (Decidable.decide b d)) (Iff a b) ((e : Eq Bool (Decidable.decide a c) (Decidable.decide b d)) => Eq.mpr (Iff a b) (Iff (Eq Bool (Decidable.decide a c) Bool.true) b) (id (Eq Prop (Iff a b) (Iff (Eq Bool (Decidable.decide a c) Bool.true) b)) (congrArg Prop Prop a (Eq Bool (Decidable.decide a c) Bool.true) ((f : Prop) => Iff f b) (Eq.symm Prop (Eq Bool (Decidable.decide a c) Bool.true) a (propext (Eq Bool (Decidable.decide a c) Bool.true) a (decide_eq_true_iff a c))))) (Eq.mpr (Iff (Eq Bool (Decidable.decide a c) Bool.true) b) (Iff (Eq Bool (Decidable.decide b d) Bool.true) b) (id (Eq Prop (Iff (Eq Bool (Decidable.decide a c) Bool.true) b) (Iff (Eq Bool (Decidable.decide b d) Bool.true) b)) (congrArg Bool Prop (Decidable.decide a c) (Decidable.decide b d) ((g : Bool) => Iff (Eq Bool g Bool.true) b) e)) (Eq.mpr (Iff (Eq Bool (Decidable.decide b d) Bool.true) b) (Iff b b) (id (Eq Prop (Iff (Eq Bool (Decidable.decide b d) Bool.true) b) (Iff b b)) (congrArg Prop Prop (Eq Bool (Decidable.decide b d) Bool.true) b ((h : Prop) => Iff h b) (propext (Eq Bool (Decidable.decide b d) Bool.true) b (decide_eq_true_iff b d)))) (Iff.rfl b)))) ((i : Iff a b) => of_eq_true (Eq Bool (Decidable.decide a c) (Decidable.decide b d)) (Eq.trans Prop (Eq Bool (Decidable.decide a c) (Decidable.decide b d)) (Eq Bool (Decidable.decide b d) (Decidable.decide b d)) True (congrArg Bool Prop (Decidable.decide a c) (Decidable.decide b d) ((j : Bool) => Eq Bool j (Decidable.decide b d)) (((k : Prop) => (l : Prop) => (m : Eq Prop k l) => Eq.rec Prop k ((n : Prop) => Eq Prop k n => ((o : Decidable k) -> (p : Decidable n) -> Eq Bool (Decidable.decide k o) (Decidable.decide n p))) ((q : Decidable k) => (r : Decidable k) => Eq.ndrec (Decidable k) q ((s : Decidable k) => Eq Bool (Decidable.decide k q) (Decidable.decide k s)) (Eq.refl Bool (Decidable.decide k q)) r (Subsingleton.elim (Decidable k) (instSubsingletonDecidable k) q r)) l m) a b (propext a b i) c d)) (eq_self Bool (Decidable.decide b d))))
thm Init.PropLemmas._auxLemma.53 : (a : Prop) -> (b : Prop) -> (c : Decidable a) -> (d : Decidable b) -> Eq Prop (Eq Bool (Decidable.decide a c) (Decidable.decide b d)) (Iff a b)
  (a : Prop) => (b : Prop) => (c : Decidable a) => (d : Decidable b) => propext (Eq Bool (Decidable.decide a c) (Decidable.decide b d)) (Iff a b) (decide_eq_decide a b c d)
thm Init.PropLemmas._auxLemma.20 : (a : Prop) -> (s0 : Sort(u_1)) -> Nonempty s0 -> Eq Prop (s0 -> a) a
  (a : Prop) => (s0 : Sort(u_1)) => (b : Nonempty s0) => propext (s0 -> a) a (forall_const a s0 b)
def Inhabited : Sort(u) -> Sort(Max(u, 0 + 1))
def Inhabited.default : (s0 : Sort(u)) -> Inhabited s0 -> s0
thm instNonemptyOfInhabited : (s0 : Sort(u)) -> Inhabited s0 -> Nonempty s0
  (s0 : Sort(u)) => (a : Inhabited s0) => Nonempty.intro s0 (Inhabited.default s0 a)
def Inhabited.mk : (s0 : Sort(u)) -> s0 -> Inhabited s0
def instInhabitedTrue := Inhabited.mk True True.intro
def decide_true.match_1 := (f0 : (a : Decidable True) -> Prop) => (b : Decidable True) => (f1 : (c : True) -> f0 (Decidable.isTrue True c)) => (f2 : (d : Not True) -> f0 (Decidable.isFalse True d)) => Decidable.casesOn True ((e : Decidable True) => f0 e) b ((f : Not True) => f2 f) ((g : True) => f1 g)
thm decide_true : (a : Decidable True) -> Eq Bool (Decidable.decide True a) Bool.true
  (a : Decidable True) => decide_true.match_1 ((b : Decidable True) => Eq Bool (Decidable.decide True b) Bool.true) a ((c : True) => rfl Bool (Decidable.decide True (Decidable.isTrue True c))) ((d : Not True) => False.elim (Eq Bool (Decidable.decide True (Decidable.isFalse True d)) Bool.true) (d True.intro))
thm of_eq_false : (a : Prop) -> Eq Prop a False -> Not a
  (a : Prop) => (b : Eq Prop a False) => (c : a) => False.elim False (Eq.mp a False b c)
thm dite_cond_eq_false : (s0 : Sort(u)) -> (a : Prop) -> (b : Decidable a) -> (f0 : a -> s0) -> (f1 : Not a -> s0) -> (c : Eq Prop a False) -> Eq s0 (dite s0 a b f0 f1) (f1 (of_eq_false a c))
  (s0 : Sort(u)) => (a : Prop) => (b : Decidable a) => (f0 : a -> s0) => (f1 : Not a -> s0) => (c : Eq Prop a False) => of_eq_true (Eq s0 (dite s0 a b f0 f1) (f1 (of_eq_false a c))) (Eq.trans Prop (Eq s0 (dite s0 a b f0 f1) (f1 (of_eq_false a c))) (Eq s0 (dite s0 False instDecidableFalse ((d : False) => f0 (Eq.mpr_prop a False c d)) ((e : Not False) => f1 (Eq.mpr_not a False c e))) (f1 (of_eq_false a c))) True (congrArg s0 Prop (dite s0 a b f0 f1) (dite s0 False instDecidableFalse ((f : False) => f0 (Eq.mpr_prop a False c f)) ((g : Not False) => f1 (Eq.mpr_not a False c g))) ((h : s0) => Eq s0 h (f1 (of_eq_false a c))) (dite_congr a False s0 b instDecidableFalse f0 ((i : False) => f0 (Eq.mpr_prop a False c i)) f1 ((j : Not False) => f1 (Eq.mpr_not a False c j)) c ((k : False) => Eq.refl s0 (f0 (Eq.mpr_prop a False c k))) ((l : Not False) => Eq.refl s0 (f1 (Eq.mpr_not a False c l))))) (eq_self s0 (f1 (Eq.mpr_not a False c not_false))))
thm decide_implies : (a : Prop) -> (b : Prop) -> (c : Decidable (a -> b)) -> (d : Decidable a) -> (f0 : a -> Decidable b) -> Eq Bool (Decidable.decide ((e : a) -> b) c) (dite Bool a d ((f : a) => Decidable.decide b (f0 f)) (Not a => Bool.true))
  (a : Prop) => (b : Prop) => (c : Decidable (a -> b)) => (d : Decidable a) => (f0 : a -> Decidable b) => dite (Eq Bool (Decidable.decide ((e : a) -> b) c) (dite Bool a d ((f : a) => Decidable.decide b (f0 f)) ((g : Not a) => Bool.true))) a d ((h : a) => of_eq_true (Eq Bool (Decidable.decide ((i : a) -> b) c) (dite Bool a d ((j : a) => Decidable.decide b (f0 j)) (Not a => Bool.true))) (Eq.trans Prop (Eq Bool (Decidable.decide ((k : a) -> b) c) (dite Bool a d ((l : a) => Decidable.decide b (f0 l)) (Not a => Bool.true))) (Iff ((m : a) -> b) b) True (Eq.trans Prop (Eq Bool (Decidable.decide ((n : a) -> b) c) (dite Bool a d ((o : a) => Decidable.decide b (f0 o)) (Not a => Bool.true))) (Eq Bool (Decidable.decide ((p : a) -> b) c) (Decidable.decide b (f0 (of_eq_true a (eq_true a h))))) (Iff ((q : a) -> b) b) (congrArg Bool Prop (dite Bool a d ((r : a) => Decidable.decide b (f0 r)) (Not a => Bool.true)) (Decidable.decide b (f0 (of_eq_true a (eq_true a h)))) (Eq Bool (Decidable.decide ((s : a) -> b) c)) (dite_cond_eq_true Bool a d ((t : a) => Decidable.decide b (f0 t)) (Not a => Bool.true) (eq_true a h))) (Init.PropLemmas._auxLemma.53 ((u : a) -> b) b c (f0 (of_eq_true a (eq_true a h))))) (Eq.trans Prop (Iff ((v : a) -> b) b) (Iff b b) True (congrArg Prop Prop ((w : a) -> b) b ((x : Prop) => Iff x b) (Eq.trans Prop ((y : a) -> b) (True -> b) b (implies_congr a True b b (eq_true a h) (Eq.refl Prop b)) (Init.PropLemmas._auxLemma.20 b True (instNonemptyOfInhabited True instInhabitedTrue)))) (iff_self b)))) ((z : Not a) => of_eq_true (Eq Bool (Decidable.decide ((A : a) -> b) c) (dite Bool a d ((B : a) => Decidable.decide b (f0 B)) (Not a => Bool.true))) (Eq.trans Prop (Eq Bool (Decidable.decide ((C : a) -> b) c) (dite Bool a d ((D : a) => Decidable.decide b (f0 D)) (Not a => Bool.true))) (Eq Bool Bool.true Bool.true) True (congr Bool Prop (Eq Bool (Decidable.decide ((E : a) -> b) c)) (Eq Bool Bool.true) (dite Bool a d ((F : a) => Decidable.decide b (f0 F)) (Not a => Bool.true)) Bool.true (congrArg Bool (Bool -> Prop) (Decidable.decide ((G : a) -> b) c) Bool.true (Eq Bool) (Eq.trans Bool (Decidable.decide ((H : a) -> b) c) (Decidable.decide True instDecidableTrue) Bool.true (((I : Prop) => (J : Prop) => (K : Eq Prop I J) => Eq.rec Prop I ((L : Prop) => Eq Prop I L => ((M : Decidable I) -> (N : Decidable L) -> Eq Bool (Decidable.decide I M) (Decidable.decide L N))) ((O : Decidable I) => (P : Decidable I) => Eq.ndrec (Decidable I) O ((Q : Decidable I) => Eq Bool (Decidable.decide I O) (Decidable.decide I Q)) (Eq.refl Bool (Decidable.decide I O)) P (Subsingleton.elim (Decidable I) (instSubsingletonDecidable I) O P)) J K) ((R : a) -> b) True (Eq.trans Prop ((S : a) -> b) (False -> b) True (implies_congr a False b b (eq_false a z) (Eq.refl Prop b)) (false_implies b)) c instDecidableTrue) (decide_true instDecidableTrue))) (dite_cond_eq_false Bool a d ((T : a) => Decidable.decide b (f0 T)) (Not a => Bool.true) (eq_false a z))) (eq_self Bool Bool.true)))
thm decide_ite : (a : Prop) -> (b : Decidable a) -> (c : Prop) -> (d : Prop) -> (e : Decidable (ite Prop a b c d)) -> (f : Decidable c) -> (g : Decidable d) -> Eq Bool (Decidable.decide (ite Prop a b c d) e) (ite Bool a b (Decidable.decide c f) (Decidable.decide d g))
  (a : Prop) => (b : Decidable a) => (c : Prop) => (d : Prop) => (e : Decidable (ite Prop a b c d)) => (f : Decidable c) => (g : Decidable d) => Decidable.casesOn a ((h : Decidable a) => (Eq (Decidable a) b h -> Eq Bool (Decidable.decide (ite Prop a b c d) e) (ite Bool a b (Decidable.decide c f) (Decidable.decide d g)))) b ((i : Not a) => (j : Eq (Decidable a) b (Decidable.isFalse a i)) => Eq.ndrec (Decidable a) (Decidable.isFalse a i) ((k : Decidable a) => ((l : Decidable (ite Prop a k c d)) -> Eq Bool (Decidable.decide (ite Prop a k c d) l) (ite Bool a k (Decidable.decide c f) (Decidable.decide d g)))) ((m : Decidable (ite Prop a (Decidable.isFalse a i) c d)) => of_eq_true (Eq Bool (Decidable.decide (ite Prop a (Decidable.isFalse a i) c d) m) (ite Bool a (Decidable.isFalse a i) (Decidable.decide c f) (Decidable.decide d g))) (Eq.trans Prop (Eq Bool (Decidable.decide (ite Prop a (Decidable.isFalse a i) c d) m) (ite Bool a (Decidable.isFalse a i) (Decidable.decide c f) (Decidable.decide d g))) (Eq Bool (Decidable.decide d g) (Decidable.decide d g)) True (congr Bool Prop (Eq Bool (Decidable.decide (ite Prop a (Decidable.isFalse a i) c d) m)) (Eq Bool (Decidable.decide d g)) (ite Bool a (Decidable.isFalse a i) (Decidable.decide c f) (Decidable.decide d g)) (Decidable.decide d g) (congrArg Bool (Bool -> Prop) (Decidable.decide (ite Prop a (Decidable.isFalse a i) c d) m) (Decidable.decide d g) (Eq Bool) (((n : Prop) => (o : Prop) => (p : Eq Prop n o) => Eq.rec Prop n ((q : Prop) => Eq Prop n q => ((r : Decidable n) -> (s : Decidable q) -> Eq Bool (Decidable.decide n r) (Decidable.decide q s))) ((t : Decidable n) => (u : Decidable n) => Eq.ndrec (Decidable n) t ((v : Decidable n) => Eq Bool (Decidable.decide n t) (Decidable.decide n v)) (Eq.refl Bool (Decidable.decide n t)) u (Subsingleton.elim (Decidable n) (instSubsingletonDecidable n) t u)) o p) (ite Prop a (Decidable.isFalse a i) c d) d (ite_cond_eq_false Prop a (Decidable.isFalse a i) c d (eq_false a i)) m g)) (ite_cond_eq_false Bool a (Decidable.isFalse a i) (Decidable.decide c f) (Decidable.decide d g) (eq_false a i))) (eq_self Bool (Decidable.decide d g)))) b (Eq.symm (Decidable a) b (Decidable.isFalse a i) j) e) ((w : a) => (x : Eq (Decidable a) b (Decidable.isTrue a w)) => Eq.ndrec (Decidable a) (Decidable.isTrue a w) ((y : Decidable a) => ((z : Decidable (ite Prop a y c d)) -> Eq Bool (Decidable.decide (ite Prop a y c d) z) (ite Bool a y (Decidable.decide c f) (Decidable.decide d g)))) ((A : Decidable (ite Prop a (Decidable.isTrue a w) c d)) => of_eq_true (Eq Bool (Decidable.decide (ite Prop a (Decidable.isTrue a w) c d) A) (ite Bool a (Decidable.isTrue a w) (Decidable.decide c f) (Decidable.decide d g))) (Eq.trans Prop (Eq Bool (Decidable.decide (ite Prop a (Decidable.isTrue a w) c d) A) (ite Bool a (Decidable.isTrue a w) (Decidable.decide c f) (Decidable.decide d g))) (Eq Bool (Decidable.decide c f) (Decidable.decide c f)) True (congr Bool Prop (Eq Bool (Decidable.decide (ite Prop a (Decidable.isTrue a w) c d) A)) (Eq Bool (Decidable.decide c f)) (ite Bool a (Decidable.isTrue a w) (Decidable.decide c f) (Decidable.decide d g)) (Decidable.decide c f) (congrArg Bool (Bool -> Prop) (Decidable.decide (ite Prop a (Decidable.isTrue a w) c d) A) (Decidable.decide c f) (Eq Bool) (((B : Prop) => (C : Prop) => (D : Eq Prop B C) => Eq.rec Prop B ((E : Prop) => Eq Prop B E => ((F : Decidable B) -> (G : Decidable E) -> Eq Bool (Decidable.decide B F) (Decidable.decide E G))) ((H : Decidable B) => (I : Decidable B) => Eq.ndrec (Decidable B) H ((J : Decidable B) => Eq Bool (Decidable.decide B H) (Decidable.decide B J)) (Eq.refl Bool (Decidable.decide B H)) I (Subsingleton.elim (Decidable B) (instSubsingletonDecidable B) H I)) C D) (ite Prop a (Decidable.isTrue a w) c d) c (ite_cond_eq_true Prop a (Decidable.isTrue a w) c d (eq_true a w)) A f)) (ite_cond_eq_true Bool a (Decidable.isTrue a w) (Decidable.decide c f) (Decidable.decide d g) (eq_true a w))) (eq_self Bool (Decidable.decide c f)))) b (Eq.symm (Decidable a) b (Decidable.isTrue a w) x) e) (Eq.refl (Decidable a) b)
def PUnit : Sort(u)
def Unit := PUnit
def PUnit.unit : PUnit
def Unit.unit := PUnit.unit
def cond.match_1 := (f0 : (a : Bool) -> Sort(u_1)) => (b : Bool) => (f1 : Unit -> f0 Bool.true) => (f2 : Unit -> f0 Bool.false) => Bool.casesOn ((c : Bool) => f0 c) b (f2 Unit.unit) (f1 Unit.unit)
def Bool.or := (a : Bool) => (b : Bool) => cond.match_1 ((c : Bool) => Bool) a (Unit => Bool.true) (Unit => b)
def decide_false.match_1 := (f0 : (a : Decidable False) -> Prop) => (b : Decidable False) => (f1 : (c : Not False) -> f0 (Decidable.isFalse False c)) => (f2 : (d : False) -> f0 (Decidable.isTrue False d)) => Decidable.casesOn False ((e : Decidable False) => f0 e) b ((f : Not False) => f1 f) ((g : False) => f2 g)
thm decide_false : (a : Decidable False) -> Eq Bool (Decidable.decide False a) Bool.false
  (a : Decidable False) => decide_false.match_1 ((b : Decidable False) => Eq Bool (Decidable.decide False b) Bool.false) a ((c : Not False) => rfl Bool (Decidable.decide False (Decidable.isFalse False c))) ((d : False) => False.elim (Eq Bool (Decidable.decide False (Decidable.isTrue False d)) Bool.false) d)
thm Bool.false_or : (a : Bool) -> Eq Bool (Bool.or Bool.false a) a
  (a : Bool) => Bool.casesOn ((b : Bool) => (Eq Bool a b -> Eq Bool (Bool.or Bool.false a) a)) a ((c : Eq Bool a Bool.false) => Eq.ndrec Bool Bool.false ((d : Bool) => Eq Bool (Bool.or Bool.false d) d) (Eq.refl Bool (Bool.or Bool.false Bool.false)) a (Eq.symm Bool a Bool.false c)) ((e : Eq Bool a Bool.true) => Eq.ndrec Bool Bool.true ((f : Bool) => Eq Bool (Bool.or Bool.false f) f) (Eq.refl Bool (Bool.or Bool.false Bool.true)) a (Eq.symm Bool a Bool.true e)) (Eq.refl Bool a)
thm Bool.true_or : (a : Bool) -> Eq Bool (Bool.or Bool.true a) Bool.true
  (a : Bool) => Bool.casesOn ((b : Bool) => (Eq Bool a b -> Eq Bool (Bool.or Bool.true a) Bool.true)) a ((c : Eq Bool a Bool.false) => Eq.ndrec Bool Bool.false ((d : Bool) => Eq Bool (Bool.or Bool.true d) Bool.true) (Eq.refl Bool (Bool.or Bool.true Bool.false)) a (Eq.symm Bool a Bool.false c)) ((e : Eq Bool a Bool.true) => Eq.ndrec Bool Bool.true ((f : Bool) => Eq Bool (Bool.or Bool.true f) Bool.true) (Eq.refl Bool (Bool.or Bool.true Bool.true)) a (Eq.symm Bool a Bool.true e)) (Eq.refl Bool a)
thm ite_then_decide_self : (a : Prop) -> (b : Decidable a) -> (c : Decidable a) -> (d : Bool) -> Eq Bool (ite Bool a b (Decidable.decide a c) d) (Bool.or (Decidable.decide a c) d)
  (a : Prop) => (b : Decidable a) => (c : Decidable a) => (d : Bool) => Decidable.casesOn a ((e : Decidable a) => Eq Bool (ite Bool a b (Decidable.decide a c) d) (Bool.or (Decidable.decide a c) d)) b ((f : Not a) => Eq.mpr (Eq Bool (ite Bool a b (Decidable.decide a c) d) (Bool.or (Decidable.decide a c) d)) (Eq Bool d (Bool.or (Decidable.decide a c) d)) (id (Eq Prop (Eq Bool (ite Bool a b (Decidable.decide a c) d) (Bool.or (Decidable.decide a c) d)) (Eq Bool d (Bool.or (Decidable.decide a c) d))) (congrArg Bool Prop (ite Bool a b (Decidable.decide a c) d) d ((g : Bool) => Eq Bool g (Bool.or (Decidable.decide a c) d)) (if_neg a b f Bool (Decidable.decide a c) d))) (of_eq_true (Eq Bool d (Bool.or (Decidable.decide a c) d)) (Eq.trans Prop (Eq Bool d (Bool.or (Decidable.decide a c) d)) (Eq Bool d d) True (congrArg Bool Prop (Bool.or (Decidable.decide a c) d) d (Eq Bool d) (Eq.trans Bool (Bool.or (Decidable.decide a c) d) (Bool.or Bool.false d) d (congrArg Bool Bool (Decidable.decide a c) Bool.false ((h : Bool) => Bool.or h d) (Eq.trans Bool (Decidable.decide a c) (Decidable.decide False instDecidableFalse) Bool.false (((i : Prop) => (j : Prop) => (k : Eq Prop i j) => Eq.rec Prop i ((l : Prop) => Eq Prop i l => ((m : Decidable i) -> (n : Decidable l) -> Eq Bool (Decidable.decide i m) (Decidable.decide l n))) ((o : Decidable i) => (p : Decidable i) => Eq.ndrec (Decidable i) o ((q : Decidable i) => Eq Bool (Decidable.decide i o) (Decidable.decide i q)) (Eq.refl Bool (Decidable.decide i o)) p (Subsingleton.elim (Decidable i) (instSubsingletonDecidable i) o p)) j k) a False (eq_false a f) c instDecidableFalse) (decide_false instDecidableFalse))) (Bool.false_or d))) (eq_self Bool d)))) ((r : a) => Eq.mpr (Eq Bool (ite Bool a b (Decidable.decide a c) d) (Bool.or (Decidable.decide a c) d)) (Eq Bool (Decidable.decide a c) (Bool.or (Decidable.decide a c) d)) (id (Eq Prop (Eq Bool (ite Bool a b (Decidable.decide a c) d) (Bool.or (Decidable.decide a c) d)) (Eq Bool (Decidable.decide a c) (Bool.or (Decidable.decide a c) d))) (congrArg Bool Prop (ite Bool a b (Decidable.decide a c) d) (Decidable.decide a c) ((s : Bool) => Eq Bool s (Bool.or (Decidable.decide a c) d)) (if_pos a b r Bool (Decidable.decide a c) d))) (of_eq_true (Eq Bool (Decidable.decide a c) (Bool.or (Decidable.decide a c) d)) (Eq.trans Prop (Eq Bool (Decidable.decide a c) (Bool.or (Decidable.decide a c) d)) (Eq Bool Bool.true Bool.true) True (congr Bool Prop (Eq Bool (Decidable.decide a c)) (Eq Bool Bool.true) (Bool.or (Decidable.decide a c) d) Bool.true (congrArg Bool ((t : Bool) -> Prop) (Decidable.decide a c) Bool.true (Eq Bool) (Eq.trans Bool (Decidable.decide a c) (Decidable.decide True instDecidableTrue) Bool.true (((u : Prop) => (v : Prop) => (w : Eq Prop u v) => Eq.rec Prop u ((x : Prop) => Eq Prop u x => ((y : Decidable u) -> (z : Decidable x) -> Eq Bool (Decidable.decide u y) (Decidable.decide x z))) ((A : Decidable u) => (B : Decidable u) => Eq.ndrec (Decidable u) A ((C : Decidable u) => Eq Bool (Decidable.decide u A) (Decidable.decide u C)) (Eq.refl Bool (Decidable.decide u A)) B (Subsingleton.elim (Decidable u) (instSubsingletonDecidable u) A B)) v w) a True (eq_true a r) c instDecidableTrue) (decide_true instDecidableTrue))) (Eq.trans Bool (Bool.or (Decidable.decide a c) d) (Bool.or Bool.true d) Bool.true (congrArg Bool Bool (Decidable.decide a c) Bool.true ((D : Bool) => Bool.or D d) (Eq.trans Bool (Decidable.decide a c) (Decidable.decide True instDecidableTrue) Bool.true (((E : Prop) => (F : Prop) => (G : Eq Prop E F) => Eq.rec Prop E ((H : Prop) => Eq Prop E H => ((I : Decidable E) -> (J : Decidable H) -> Eq Bool (Decidable.decide E I) (Decidable.decide H J))) ((K : Decidable E) => (L : Decidable E) => Eq.ndrec (Decidable E) K ((M : Decidable E) => Eq Bool (Decidable.decide E K) (Decidable.decide E M)) (Eq.refl Bool (Decidable.decide E K)) L (Subsingleton.elim (Decidable E) (instSubsingletonDecidable E) K L)) F G) a True (eq_true a r) c instDecidableTrue) (decide_true instDecidableTrue))) (Bool.true_or d))) (eq_self Bool Bool.true))))
thm ite_true_decide_same : (a : Prop) -> (b : Decidable a) -> (c : Bool) -> Eq Bool (ite Bool a b (Decidable.decide a b) c) (Bool.or (Decidable.decide a b) c)
  (a : Prop) => (b : Decidable a) => (c : Bool) => ite_then_decide_self a b b c
def Bool.and.match_1 := (f0 : (a : Bool) -> Sort(u_1)) => (b : Bool) => (f1 : Unit -> f0 Bool.false) => (f2 : Unit -> f0 Bool.true) => Bool.casesOn ((c : Bool) => f0 c) b (f1 Unit.unit) (f2 Unit.unit)
def Bool.and := (a : Bool) => (b : Bool) => Bool.and.match_1 ((c : Bool) => Bool) a (Unit => Bool.false) (Unit => b)
thm Bool.false_and : (a : Bool) -> Eq Bool (Bool.and Bool.false a) Bool.false
  (a : Bool) => Bool.casesOn ((b : Bool) => (Eq Bool a b -> Eq Bool (Bool.and Bool.false a) Bool.false)) a ((c : Eq Bool a Bool.false) => Eq.ndrec Bool Bool.false ((d : Bool) => Eq Bool (Bool.and Bool.false d) Bool.false) (Eq.refl Bool (Bool.and Bool.false Bool.false)) a (Eq.symm Bool a Bool.false c)) ((e : Eq Bool a Bool.true) => Eq.ndrec Bool Bool.true ((f : Bool) => Eq Bool (Bool.and Bool.false f) Bool.false) (Eq.refl Bool (Bool.and Bool.false Bool.true)) a (Eq.symm Bool a Bool.true e)) (Eq.refl Bool a)
thm Bool.true_and : (a : Bool) -> Eq Bool (Bool.and Bool.true a) a
  (a : Bool) => Bool.casesOn ((b : Bool) => (Eq Bool a b -> Eq Bool (Bool.and Bool.true a) a)) a ((c : Eq Bool a Bool.false) => Eq.ndrec Bool Bool.false ((d : Bool) => Eq Bool (Bool.and Bool.true d) d) (Eq.refl Bool (Bool.and Bool.true Bool.false)) a (Eq.symm Bool a Bool.false c)) ((e : Eq Bool a Bool.true) => Eq.ndrec Bool Bool.true ((f : Bool) => Eq Bool (Bool.and Bool.true f) f) (Eq.refl Bool (Bool.and Bool.true Bool.true)) a (Eq.symm Bool a Bool.true e)) (Eq.refl Bool a)
thm ite_else_decide_self : (a : Prop) -> (b : Decidable a) -> (c : Decidable a) -> (d : Bool) -> Eq Bool (ite Bool a b d (Decidable.decide a c)) (Bool.and (Decidable.decide a c) d)
  (a : Prop) => (b : Decidable a) => (c : Decidable a) => (d : Bool) => Decidable.casesOn a ((e : Decidable a) => Eq Bool (ite Bool a b d (Decidable.decide a c)) (Bool.and (Decidable.decide a c) d)) b ((f : Not a) => Eq.mpr (Eq Bool (ite Bool a b d (Decidable.decide a c)) (Bool.and (Decidable.decide a c) d)) (Eq Bool (Decidable.decide a c) (Bool.and (Decidable.decide a c) d)) (id (Eq Prop (Eq Bool (ite Bool a b d (Decidable.decide a c)) (Bool.and (Decidable.decide a c) d)) (Eq Bool (Decidable.decide a c) (Bool.and (Decidable.decide a c) d))) (congrArg Bool Prop (ite Bool a b d (Decidable.decide a c)) (Decidable.decide a c) ((g : Bool) => Eq Bool g (Bool.and (Decidable.decide a c) d)) (if_neg a b f Bool d (Decidable.decide a c)))) (of_eq_true (Eq Bool (Decidable.decide a c) (Bool.and (Decidable.decide a c) d)) (Eq.trans Prop (Eq Bool (Decidable.decide a c) (Bool.and (Decidable.decide a c) d)) (Eq Bool Bool.false Bool.false) True (congr Bool Prop (Eq Bool (Decidable.decide a c)) (Eq Bool Bool.false) (Bool.and (Decidable.decide a c) d) Bool.false (congrArg Bool ((h : Bool) -> Prop) (Decidable.decide a c) Bool.false (Eq Bool) (Eq.trans Bool (Decidable.decide a c) (Decidable.decide False instDecidableFalse) Bool.false (((i : Prop) => (j : Prop) => (k : Eq Prop i j) => Eq.rec Prop i ((l : Prop) => Eq Prop i l => ((m : Decidable i) -> (n : Decidable l) -> Eq Bool (Decidable.decide i m) (Decidable.decide l n))) ((o : Decidable i) => (p : Decidable i) => Eq.ndrec (Decidable i) o ((q : Decidable i) => Eq Bool (Decidable.decide i o) (Decidable.decide i q)) (Eq.refl Bool (Decidable.decide i o)) p (Subsingleton.elim (Decidable i) (instSubsingletonDecidable i) o p)) j k) a False (eq_false a f) c instDecidableFalse) (decide_false instDecidableFalse))) (Eq.trans Bool (Bool.and (Decidable.decide a c) d) (Bool.and Bool.false d) Bool.false (congrArg Bool Bool (Decidable.decide a c) Bool.false ((r : Bool) => Bool.and r d) (Eq.trans Bool (Decidable.decide a c) (Decidable.decide False instDecidableFalse) Bool.false (((s : Prop) => (t : Prop) => (u : Eq Prop s t) => Eq.rec Prop s ((v : Prop) => Eq Prop s v => ((w : Decidable s) -> (x : Decidable v) -> Eq Bool (Decidable.decide s w) (Decidable.decide v x))) ((y : Decidable s) => (z : Decidable s) => Eq.ndrec (Decidable s) y ((A : Decidable s) => Eq Bool (Decidable.decide s y) (Decidable.decide s A)) (Eq.refl Bool (Decidable.decide s y)) z (Subsingleton.elim (Decidable s) (instSubsingletonDecidable s) y z)) t u) a False (eq_false a f) c instDecidableFalse) (decide_false instDecidableFalse))) (Bool.false_and d))) (eq_self Bool Bool.false)))) ((B : a) => Eq.mpr (Eq Bool (ite Bool a b d (Decidable.decide a c)) (Bool.and (Decidable.decide a c) d)) (Eq Bool d (Bool.and (Decidable.decide a c) d)) (id (Eq Prop (Eq Bool (ite Bool a b d (Decidable.decide a c)) (Bool.and (Decidable.decide a c) d)) (Eq Bool d (Bool.and (Decidable.decide a c) d))) (congrArg Bool Prop (ite Bool a b d (Decidable.decide a c)) d ((C : Bool) => Eq Bool C (Bool.and (Decidable.decide a c) d)) (if_pos a b B Bool d (Decidable.decide a c)))) (of_eq_true (Eq Bool d (Bool.and (Decidable.decide a c) d)) (Eq.trans Prop (Eq Bool d (Bool.and (Decidable.decide a c) d)) (Eq Bool d d) True (congrArg Bool Prop (Bool.and (Decidable.decide a c) d) d (Eq Bool d) (Eq.trans Bool (Bool.and (Decidable.decide a c) d) (Bool.and Bool.true d) d (congrArg Bool Bool (Decidable.decide a c) Bool.true ((D : Bool) => Bool.and D d) (Eq.trans Bool (Decidable.decide a c) (Decidable.decide True instDecidableTrue) Bool.true (((E : Prop) => (F : Prop) => (G : Eq Prop E F) => Eq.rec Prop E ((H : Prop) => Eq Prop E H => ((I : Decidable E) -> (J : Decidable H) -> Eq Bool (Decidable.decide E I) (Decidable.decide H J))) ((K : Decidable E) => (L : Decidable E) => Eq.ndrec (Decidable E) K ((M : Decidable E) => Eq Bool (Decidable.decide E K) (Decidable.decide E M)) (Eq.refl Bool (Decidable.decide E K)) L (Subsingleton.elim (Decidable E) (instSubsingletonDecidable E) K L)) F G) a True (eq_true a B) c instDecidableTrue) (decide_true instDecidableTrue))) (Bool.true_and d))) (eq_self Bool d))))
thm ite_false_decide_same : (a : Prop) -> (b : Decidable a) -> (c : Bool) -> Eq Bool (ite Bool a b c (Decidable.decide a b)) (Bool.and (Decidable.decide a b) c)
  (a : Prop) => (b : Decidable a) => (c : Bool) => ite_else_decide_self a b b c
