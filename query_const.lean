
set_option pp.all true

namespace Flow
universe u v w u_1

inductive HEq : {α : Sort u} -> α -> {β : Sort u} -> β -> Prop where
  | refl : {α : Sort u} -> (a : α) -> @HEq α a α a
inductive Eq : {α : Sort u_1} -> α -> α -> Prop where
  | refl : {α : Sort u_1} -> (a : α) -> @Eq α a a
-- ctor Eq.refl : {α : Sort u_1} -> (a : α) -> @Eq α a a
-- recursor Eq.rec : {α : Sort u_1} -> {a : α} -> {motive : (a1 : α) -> @Eq α a a1 -> Sort u} -> motive a (@Eq.refl α a) -> {a1 : α} -> (t : @Eq α a a1) -> motive a1 t
-- def Eq.casesOn : {α : Sort u_1} -> {a : α} -> {motive : (a1 : α) -> @Eq α a a1 -> Sort u} -> {a1 : α} -> (t : @Eq α a a1) -> motive a (@Eq.refl α a) -> motive a1 t :=
--  fun {α : Sort u_1} => fun {a : α} => fun {motive : (a1 : α) -> @Eq α a a1 -> Sort u} => fun {a1 : α} => fun (t : @Eq α a a1) => fun (refl : motive a (@Eq.refl α a)) => @Eq.rec α a motive refl a1 t
inductive Iff : Prop -> Prop -> Prop where
  | intro : {a : Prop} -> {b : Prop} -> (a -> b) -> (b -> a) -> @Iff a b
axiom propext : {a : Prop} -> {b : Prop} -> @Iff a b -> @Eq Prop a b
-- ctor Iff.intro : {a : Prop} -> {b : Prop} -> (a -> b) -> (b -> a) -> @Iff a b
theorem iff_of_true : {a : Prop} -> {b : Prop} -> a -> b -> @Iff a b :=
  fun {a : Prop} => fun {b : Prop} => fun (ha : a) => fun (hb : b) => @Iff.intro a b (fun (_ : a) => hb) (fun (_ : b) => ha)
#check Flow.Eq.rec
def Eq.ndrec : {α : Sort u2} -> {a : α} -> {motive : α -> Sort u1} -> motive a -> {b : α} -> @Eq α a b -> motive b :=
  fun {α : Sort u2} => fun {a : α} => fun {motive : α -> Sort u1} => fun (m : motive a) => fun {b : α} => fun (h : @Eq α a b) => @Eq.rec α a (fun (x : α) => fun (_ : @Eq α a x) => motive x) m b h
-- ctor HEq.refl : {α : Sort u} -> (a : α) -> @HEq α a α a
def HEq.rfl : {α : Sort u} -> {a : α} -> @HEq α a α a :=
  fun {α : Sort u} => fun {a : α} => @HEq.refl α a
def rfl : {α : Sort u} -> {a : α} -> @Eq α a a :=
  fun {α : Sort u} => fun {a : α} => @Eq.refl α a
theorem Eq.symm : {α : Sort u} -> {a : α} -> {b : α} -> @Eq α a b -> @Eq α b a :=
  fun {α : Sort u} => fun {a : α} => fun {b : α} => fun (h : @Eq α a b) => @Eq.rec α a (fun (x : α) => fun (_ : @Eq α a x) => @Eq α x a) (@rfl α a) b h
theorem proof_irrel_heq : {p : Prop} -> {q : Prop} -> (hp : p) -> (hq : q) -> @HEq p hp q hq :=
  fun {p : Prop} => fun {q : Prop} => fun (hp : p) => fun (hq : q) => @Eq.casesOn Prop p (fun (a : Prop) => fun (t : @Eq Prop p a) => @Eq Prop q a -> @HEq (@Eq Prop p q) (@propext p q (@iff_of_true p q hp hq)) (@Eq Prop p a) t -> @HEq p hp q hq) q (@propext p q (@iff_of_true p q hp hq)) (fun (h : @Eq Prop q p) => @Eq.ndrec Prop p (fun {q1 : Prop} => (hq1 : q1) -> (x : @Eq Prop p q1) -> @HEq (@Eq Prop p q1) x (@Eq Prop p p) (@Eq.refl Prop p) -> @HEq p hp q1 hq1) (fun (_ : p) => fun (x : @Eq Prop p p) => fun (_ : @HEq (@Eq Prop p p) x (@Eq Prop p p) (@Eq.refl Prop p)) => @HEq.rfl p hp) q (@Eq.symm Prop q p h) hq (@propext p q (@iff_of_true p q hp hq))) (@Eq.refl Prop q) (@HEq.refl (@Eq Prop p q) (@propext p q (@iff_of_true p q hp hq)))
inductive False : Prop
def Not : Prop -> Prop :=
  fun (a : Prop) => a -> False
inductive Or : Prop -> Prop -> Prop where
  | inl : {a : Prop} -> {b : Prop} -> a -> @Or a b
  | inr : {a : Prop} -> {b : Prop} -> b -> @Or a b
-- ctor Or.inr : {a : Prop} -> {b : Prop} -> b -> @Or a b
def Function.comp : {α : Sort u} -> {β : Sort v} -> {δ : Sort w} -> (β -> δ) -> (α -> β) -> α -> δ :=
  fun {α : Sort u} => fun {β : Sort v} => fun {δ : Sort w} => fun (f : β -> δ) => fun (g : α -> β) => fun (x : α) => f (g x)
-- ctor Or.inl : {a : Prop} -> {b : Prop} -> a -> @Or a b
theorem not_not_em : (a : Prop) -> @Not (@Not (@Or a (@Not a))) :=
  fun (a : Prop) => fun (h : @Not (@Or a (@Not a))) => h (@Or.inr a (@Not a) (@Function.comp a (@Or a (@Not a)) False h (@Or.inl a (@Not a))))
inductive And : Prop -> Prop -> Prop where
  | intro : {a : Prop} -> {b : Prop} -> a -> b -> @And a b
theorem Iff.refl : (a : Prop) -> @Iff a a :=
  fun (a : Prop) => @Iff.intro a a (fun (h : a) => h) (fun (h : a) => h)
theorem Iff.rfl : {a : Prop} -> @Iff a a :=
  fun {a : Prop} => @Iff.refl a
theorem Iff.of_eq : {a : Prop} -> {b : Prop} -> @Eq Prop a b -> @Iff a b :=
  fun {a : Prop} => fun {b : Prop} => fun (h : @Eq Prop a b) => @Eq.rec Prop a (fun (x : Prop) => fun (_ : @Eq Prop a x) => @Iff a x) (@Iff.rfl a) b h
axiom And.left : {a : Prop} -> {b : Prop} -> @And a b -> a
-- ctor And.intro : {a : Prop} -> {b : Prop} -> a -> b -> @And a b
theorem and_self : (p : Prop) -> @Eq Prop (@And p p) p :=
  fun (p : Prop) => @propext (@And p p) p (@Iff.intro (@And p p) p (fun (x : @And p p) => @And.left p p x) (fun (h : p) => @And.intro p p h h))
theorem and_self_iff : {a : Prop} -> @Iff (@And a a) a :=
  fun {a : Prop} => @Iff.of_eq (@And a a) a (@and_self a)
-- recursor False.rec : (motive : False -> Sort u) -> (t : False) -> motive t
def absurd : {a : Prop} -> {b : Sort v} -> a -> @Not a -> b :=
  fun {a : Prop} => fun {b : Sort v} => fun (h₁ : a) => fun (h₂ : @Not a) => @False.rec (fun (_ : False) => b) (h₂ h₁)
def Not.elim : {a : Prop} -> {α : Sort u_1} -> @Not a -> a -> α :=
  fun {a : Prop} => fun {α : Sort u_1} => fun (H1 : @Not a) => fun (H2 : a) => @absurd a α H2 H1
theorem iff_of_false : {a : Prop} -> {b : Prop} -> @Not a -> @Not b -> @Iff a b :=
  fun {a : Prop} => fun {b : Prop} => fun (ha : @Not a) => fun (hb : @Not b) => @Iff.intro a b (@Not.elim a b ha) (@Not.elim b a hb)
def id : {α : Sort u} -> α -> α :=
  fun {α : Sort u} => fun (a : α) => a
theorem iff_false_intro : {a : Prop} -> @Not a -> @Iff a False :=
  fun {a : Prop} => fun (h : @Not a) => @iff_of_false a False h (@id False)
-- recursor And.rec : {a : Prop} -> {b : Prop} -> {motive : @And a b -> Sort u} -> ((left : a) -> (right : b) -> motive (@And.intro a b left right)) -> (t : @And a b) -> motive t
-- def And.casesOn : {a : Prop} -> {b : Prop} -> {motive : @And a b -> Sort u} -> (t : @And a b) -> ((left : a) -> (right : b) -> motive (@And.intro a b left right)) -> motive t :=
--  fun {a : Prop} => fun {b : Prop} => fun {motive : @And a b -> Sort u} => fun (t : @And a b) => fun (intro : (left : a) -> (right : b) -> motive (@And.intro a b left right)) => @And.rec a b motive (fun (left : a) => fun (right : b) => intro left right) t
def and_not_self.match_1 : {a : Prop} -> (motive : @And a (@Not a) -> Prop) -> (x : @And a (@Not a)) -> ((ha : a) -> (hn : @Not a) -> motive (@And.intro a (@Not a) ha hn)) -> motive x :=
  fun {a : Prop} => fun (motive : @And a (@Not a) -> Prop) => fun (x : @And a (@Not a)) => fun (h_1 : (ha : a) -> (hn : @Not a) -> motive (@And.intro a (@Not a) ha hn)) => @And.casesOn a (@Not a) (fun (x1 : @And a (@Not a)) => motive x1) x (fun (left : a) => fun (right : @Not a) => h_1 left right)
theorem and_not_self : {a : Prop} -> @Not (@And a (@Not a)) :=
  fun {a : Prop} => fun (x : @And a (@Not a)) => @and_not_self.match_1 a (fun (_ : @And a (@Not a)) => False) x (fun (ha : a) => fun (hn : @Not a) => @absurd a False ha hn)
theorem and_not_self_iff : (a : Prop) -> @Iff (@And a (@Not a)) False :=
  fun (a : Prop) => @iff_false_intro (@And a (@Not a)) (@and_not_self a)
def And.symm.match_1 : {a : Prop} -> {b : Prop} -> (motive : @And a b -> Prop) -> (x : @And a b) -> ((ha : a) -> (hb : b) -> motive (@And.intro a b ha hb)) -> motive x :=
  fun {a : Prop} => fun {b : Prop} => fun (motive : @And a b -> Prop) => fun (x : @And a b) => fun (h_1 : (ha : a) -> (hb : b) -> motive (@And.intro a b ha hb)) => @And.casesOn a b (fun (x1 : @And a b) => motive x1) x (fun (left : a) => fun (right : b) => h_1 left right)
theorem And.symm : {a : Prop} -> {b : Prop} -> @And a b -> @And b a :=
  fun {a : Prop} => fun {b : Prop} => fun (x : @And a b) => @And.symm.match_1 a b (fun (_ : @And a b) => @And b a) x (fun (ha : a) => fun (hb : b) => @And.intro b a hb ha)
theorem not_and_self : {a : Prop} -> @Not (@And (@Not a) a) :=
  fun {a : Prop} => @Function.comp (@And (@Not a) a) (@And a (@Not a)) False (@and_not_self a) (@And.symm (@Not a) a)
theorem not_and_self_iff : (a : Prop) -> @Iff (@And (@Not a) a) False :=
  fun (a : Prop) => @iff_false_intro (@And (@Not a) a) (@not_and_self a)
axiom And.right : {a : Prop} -> {b : Prop} -> @And a b -> b
theorem And.imp : {a : Prop} -> {c : Prop} -> {b : Prop} -> {d : Prop} -> (a -> c) -> (b -> d) -> @And a b -> @And c d :=
  fun {a : Prop} => fun {c : Prop} => fun {b : Prop} => fun {d : Prop} => fun (f : a -> c) => fun (g : b -> d) => fun (h : @And a b) => @And.intro c d (f (@And.left a b h)) (g (@And.right a b h))
theorem And.imp_left : {a : Prop} -> {b : Prop} -> {c : Prop} -> (a -> b) -> @And a c -> @And b c :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (h : a -> b) => @And.imp a b c c h (@id c)
theorem And.imp_right : {a : Prop} -> {b : Prop} -> {c : Prop} -> (a -> b) -> @And c a -> @And c b :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (h : a -> b) => @And.imp c c a b (@id c) h
axiom Iff.mp : {a : Prop} -> {b : Prop} -> @Iff a b -> a -> b
axiom Iff.mpr : {a : Prop} -> {b : Prop} -> @Iff a b -> b -> a
theorem and_congr : {a : Prop} -> {c : Prop} -> {b : Prop} -> {d : Prop} -> @Iff a c -> @Iff b d -> @Iff (@And a b) (@And c d) :=
  fun {a : Prop} => fun {c : Prop} => fun {b : Prop} => fun {d : Prop} => fun (h₁ : @Iff a c) => fun (h₂ : @Iff b d) => @Iff.intro (@And a b) (@And c d) (@And.imp a c b d (@Iff.mp a c h₁) (@Iff.mp b d h₂)) (@And.imp c a d b (@Iff.mpr a c h₁) (@Iff.mpr b d h₂))
theorem and_congr_left' : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff a b -> @Iff (@And a c) (@And b c) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (h : @Iff a b) => @and_congr a b c c h (@Iff.rfl c)
theorem and_congr_right' : {b : Prop} -> {c : Prop} -> {a : Prop} -> @Iff b c -> @Iff (@And a b) (@And a c) :=
  fun {b : Prop} => fun {c : Prop} => fun {a : Prop} => fun (h : @Iff b c) => @and_congr a a b c (@Iff.rfl a) h
theorem mt : {a : Prop} -> {b : Prop} -> (a -> b) -> @Not b -> @Not a :=
  fun {a : Prop} => fun {b : Prop} => fun (h₁ : a -> b) => fun (h₂ : @Not b) => fun (ha : a) => h₂ (h₁ ha)
theorem not_and_of_not_left : {a : Prop} -> (b : Prop) -> @Not a -> @Not (@And a b) :=
  fun {a : Prop} => fun (b : Prop) => @mt (@And a b) a (@And.left a b)
theorem not_and_of_not_right : (a : Prop) -> {b : Prop} -> @Not b -> @Not (@And a b) :=
  fun (a : Prop) => fun {b : Prop} => @mt (@And a b) b (@And.right a b)
def and_imp.match_1 : {a : Prop} -> {b : Prop} -> (motive : @And a b -> Prop) -> (x : @And a b) -> ((ha : a) -> (hb : b) -> motive (@And.intro a b ha hb)) -> motive x :=
  fun {a : Prop} => fun {b : Prop} => fun (motive : @And a b -> Prop) => fun (x : @And a b) => fun (h_1 : (ha : a) -> (hb : b) -> motive (@And.intro a b ha hb)) => @And.casesOn a b (fun (x1 : @And a b) => motive x1) x (fun (left : a) => fun (right : b) => h_1 left right)
theorem and_congr_right : {a : Prop} -> {b : Prop} -> {c : Prop} -> (a -> @Iff b c) -> @Iff (@And a b) (@And a c) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (h : a -> @Iff b c) => @Iff.intro (@And a b) (@And a c) (fun (x : @And a b) => @and_imp.match_1 a b (fun (_ : @And a b) => @And a c) x (fun (ha : a) => fun (hb : b) => @And.intro a c ha (@Iff.mp b c (h ha) hb))) (fun (x : @And a c) => @and_imp.match_1 a c (fun (_ : @And a c) => @And a b) x (fun (ha : a) => fun (hb : c) => @And.intro a b ha (@Iff.mpr b c (h ha) hb)))
theorem and_congr_right_eq : {a : Prop} -> {b : Prop} -> {c : Prop} -> (a -> @Eq Prop b c) -> @Eq Prop (@And a b) (@And a c) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (h : a -> @Eq Prop b c) => @propext (@And a b) (@And a c) (@and_congr_right a b c (@Function.comp a (@Eq Prop b c) (@Iff b c) (@Iff.of_eq b c) h))
theorem Iff.trans : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff a b -> @Iff b c -> @Iff a c :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (h₁ : @Iff a b) => fun (h₂ : @Iff b c) => @Iff.intro a c (@Function.comp a b c (@Iff.mp b c h₂) (@Iff.mp a b h₁)) (@Function.comp c b a (@Iff.mpr a b h₁) (@Iff.mpr b c h₂))
theorem And.comm : {a : Prop} -> {b : Prop} -> @Iff (@And a b) (@And b a) :=
  fun {a : Prop} => fun {b : Prop} => @Iff.intro (@And a b) (@And b a) (@And.symm a b) (@And.symm b a)
theorem and_comm : {a : Prop} -> {b : Prop} -> @Iff (@And a b) (@And b a) :=
  fun {a : Prop} => fun {b : Prop} => @And.comm a b
theorem and_congr_left : {c : Prop} -> {a : Prop} -> {b : Prop} -> (c -> @Iff a b) -> @Iff (@And a c) (@And b c) :=
  fun {c : Prop} => fun {a : Prop} => fun {b : Prop} => fun (h : c -> @Iff a b) => @Iff.trans (@And a c) (@And c a) (@And b c) (@and_comm a c) (@Iff.trans (@And c a) (@And c b) (@And b c) (@and_congr_right c a b h) (@and_comm c b))
theorem and_congr_left_eq : {c : Prop} -> {a : Prop} -> {b : Prop} -> (c -> @Eq Prop a b) -> @Eq Prop (@And a c) (@And b c) :=
  fun {c : Prop} => fun {a : Prop} => fun {b : Prop} => fun (h : c -> @Eq Prop a b) => @propext (@And a c) (@And b c) (@and_congr_left c a b (@Function.comp c (@Eq Prop a b) (@Iff a b) (@Iff.of_eq a b) h))
def and_left_comm.match_1 : {a : Prop} -> {b : Prop} -> {c : Prop} -> (motive : @And a (@And b c) -> Prop) -> (x : @And a (@And b c)) -> ((ha : a) -> (hb : b) -> (hc : c) -> motive (@And.intro a (@And b c) ha (@And.intro b c hb hc))) -> motive x :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (motive : @And a (@And b c) -> Prop) => fun (x : @And a (@And b c)) => fun (h_1 : (ha : a) -> (hb : b) -> (hc : c) -> motive (@And.intro a (@And b c) ha (@And.intro b c hb hc))) => @And.casesOn a (@And b c) (fun (x1 : @And a (@And b c)) => motive x1) x (fun (left : a) => fun (right : @And b c) => @And.casesOn b c (fun (x1 : @And b c) => motive (@And.intro a (@And b c) left x1)) right (fun (left1 : b) => fun (right1 : c) => h_1 left left1 right1))
def and_left_comm.match_2 : {a : Prop} -> {b : Prop} -> {c : Prop} -> (motive : @And b (@And a c) -> Prop) -> (x : @And b (@And a c)) -> ((hb : b) -> (ha : a) -> (hc : c) -> motive (@And.intro b (@And a c) hb (@And.intro a c ha hc))) -> motive x :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (motive : @And b (@And a c) -> Prop) => fun (x : @And b (@And a c)) => fun (h_1 : (hb : b) -> (ha : a) -> (hc : c) -> motive (@And.intro b (@And a c) hb (@And.intro a c ha hc))) => @And.casesOn b (@And a c) (fun (x1 : @And b (@And a c)) => motive x1) x (fun (left : b) => fun (right : @And a c) => @And.casesOn a c (fun (x1 : @And a c) => motive (@And.intro b (@And a c) left x1)) right (fun (left1 : a) => fun (right1 : c) => h_1 left left1 right1))
theorem and_left_comm : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff (@And a (@And b c)) (@And b (@And a c)) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => @Iff.intro (@And a (@And b c)) (@And b (@And a c)) (fun (x : @And a (@And b c)) => @and_left_comm.match_1 a b c (fun (_ : @And a (@And b c)) => @And b (@And a c)) x (fun (ha : a) => fun (hb : b) => fun (hc : c) => @And.intro b (@And a c) hb (@And.intro a c ha hc))) (fun (x : @And b (@And a c)) => @and_left_comm.match_2 a b c (fun (_ : @And b (@And a c)) => @And a (@And b c)) x (fun (hb : b) => fun (ha : a) => fun (hc : c) => @And.intro a (@And b c) ha (@And.intro b c hb hc)))
def and_right_comm.match_1 : {a : Prop} -> {b : Prop} -> {c : Prop} -> (motive : @And (@And a b) c -> Prop) -> (x : @And (@And a b) c) -> ((ha : a) -> (hb : b) -> (hc : c) -> motive (@And.intro (@And a b) c (@And.intro a b ha hb) hc)) -> motive x :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (motive : @And (@And a b) c -> Prop) => fun (x : @And (@And a b) c) => fun (h_1 : (ha : a) -> (hb : b) -> (hc : c) -> motive (@And.intro (@And a b) c (@And.intro a b ha hb) hc)) => @And.casesOn (@And a b) c (fun (x1 : @And (@And a b) c) => motive x1) x (fun (left : @And a b) => fun (right : c) => @And.casesOn a b (fun (x1 : @And a b) => motive (@And.intro (@And a b) c x1 right)) left (fun (left1 : a) => fun (right1 : b) => h_1 left1 right1 right))
def and_right_comm.match_2 : {a : Prop} -> {b : Prop} -> {c : Prop} -> (motive : @And (@And a c) b -> Prop) -> (x : @And (@And a c) b) -> ((ha : a) -> (hc : c) -> (hb : b) -> motive (@And.intro (@And a c) b (@And.intro a c ha hc) hb)) -> motive x :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (motive : @And (@And a c) b -> Prop) => fun (x : @And (@And a c) b) => fun (h_1 : (ha : a) -> (hc : c) -> (hb : b) -> motive (@And.intro (@And a c) b (@And.intro a c ha hc) hb)) => @And.casesOn (@And a c) b (fun (x1 : @And (@And a c) b) => motive x1) x (fun (left : @And a c) => fun (right : b) => @And.casesOn a c (fun (x1 : @And a c) => motive (@And.intro (@And a c) b x1 right)) left (fun (left1 : a) => fun (right1 : c) => h_1 left1 right1 right))
theorem and_right_comm : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff (@And (@And a b) c) (@And (@And a c) b) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => @Iff.intro (@And (@And a b) c) (@And (@And a c) b) (fun (x : @And (@And a b) c) => @and_right_comm.match_1 a b c (fun (_ : @And (@And a b) c) => @And (@And a c) b) x (fun (ha : a) => fun (hb : b) => fun (hc : c) => @And.intro (@And a c) b (@And.intro a c ha hc) hb)) (fun (x : @And (@And a c) b) => @and_right_comm.match_2 a b c (fun (_ : @And (@And a c) b) => @And (@And a b) c) x (fun (ha : a) => fun (hc : c) => fun (hb : b) => @And.intro (@And a b) c (@And.intro a b ha hb) hc))
def Eq.mpr : {α : Sort u} -> {β : Sort u} -> @Eq (Sort u) α β -> β -> α :=
  fun {α : Sort u} => fun {β : Sort u} => fun (h : @Eq (Sort u) α β) => fun (b : β) => @Eq.rec (Sort u) β (fun (x : Sort u) => fun (_ : @Eq (Sort u) β x) => x) b α (@Eq.symm (Sort u) α β h)
theorem congrArg : {α : Sort u} -> {β : Sort v} -> {a₁ : α} -> {a₂ : α} -> (f : α -> β) -> @Eq α a₁ a₂ -> @Eq β (f a₁) (f a₂) :=
  fun {α : Sort u} => fun {β : Sort v} => fun {a₁ : α} => fun {a₂ : α} => fun (f : α -> β) => fun (h : @Eq α a₁ a₂) => @Eq.rec α a₁ (fun (x : α) => fun (_ : @Eq α a₁ x) => @Eq β (f a₁) (f x)) (@rfl β (f a₁)) a₂ h
theorem and_rotate : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff (@And a (@And b c)) (@And b (@And c a)) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => @Eq.mpr (@Iff (@And a (@And b c)) (@And b (@And c a))) (@Iff (@And b (@And a c)) (@And b (@And c a))) (@id (@Eq Prop (@Iff (@And a (@And b c)) (@And b (@And c a))) (@Iff (@And b (@And a c)) (@And b (@And c a)))) (@congrArg Prop Prop (@And a (@And b c)) (@And b (@And a c)) (fun (_a : Prop) => @Iff _a (@And b (@And c a))) (@propext (@And a (@And b c)) (@And b (@And a c)) (@and_left_comm a b c)))) (@Eq.mpr (@Iff (@And b (@And a c)) (@And b (@And c a))) (@Iff (@And b (@And c a)) (@And b (@And c a))) (@id (@Eq Prop (@Iff (@And b (@And a c)) (@And b (@And c a))) (@Iff (@And b (@And c a)) (@And b (@And c a)))) (@congrArg Prop Prop (@And a c) (@And c a) (fun (_a : Prop) => @Iff (@And b _a) (@And b (@And c a))) (@propext (@And a c) (@And c a) (@and_comm a c)))) (@Iff.rfl (@And b (@And c a))))
def and_assoc.match_1 : {a : Prop} -> {b : Prop} -> {c : Prop} -> (motive : @And (@And a b) c -> Prop) -> (x : @And (@And a b) c) -> ((ha : a) -> (hb : b) -> (hc : c) -> motive (@And.intro (@And a b) c (@And.intro a b ha hb) hc)) -> motive x :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (motive : @And (@And a b) c -> Prop) => fun (x : @And (@And a b) c) => fun (h_1 : (ha : a) -> (hb : b) -> (hc : c) -> motive (@And.intro (@And a b) c (@And.intro a b ha hb) hc)) => @And.casesOn (@And a b) c (fun (x1 : @And (@And a b) c) => motive x1) x (fun (left : @And a b) => fun (right : c) => @And.casesOn a b (fun (x1 : @And a b) => motive (@And.intro (@And a b) c x1 right)) left (fun (left1 : a) => fun (right1 : b) => h_1 left1 right1 right))
def and_assoc.match_2 : {a : Prop} -> {b : Prop} -> {c : Prop} -> (motive : @And a (@And b c) -> Prop) -> (x : @And a (@And b c)) -> ((ha : a) -> (hb : b) -> (hc : c) -> motive (@And.intro a (@And b c) ha (@And.intro b c hb hc))) -> motive x :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (motive : @And a (@And b c) -> Prop) => fun (x : @And a (@And b c)) => fun (h_1 : (ha : a) -> (hb : b) -> (hc : c) -> motive (@And.intro a (@And b c) ha (@And.intro b c hb hc))) => @And.casesOn a (@And b c) (fun (x1 : @And a (@And b c)) => motive x1) x (fun (left : a) => fun (right : @And b c) => @And.casesOn b c (fun (x1 : @And b c) => motive (@And.intro a (@And b c) left x1)) right (fun (left1 : b) => fun (right1 : c) => h_1 left left1 right1))
theorem and_assoc : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff (@And (@And a b) c) (@And a (@And b c)) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => @Iff.intro (@And (@And a b) c) (@And a (@And b c)) (fun (x : @And (@And a b) c) => @and_assoc.match_1 a b c (fun (_ : @And (@And a b) c) => @And a (@And b c)) x (fun (ha : a) => fun (hb : b) => fun (hc : c) => @And.intro a (@And b c) ha (@And.intro b c hb hc))) (fun (x : @And a (@And b c)) => @and_assoc.match_2 a b c (fun (_ : @And a (@And b c)) => @And (@And a b) c) x (fun (ha : a) => fun (hb : b) => fun (hc : c) => @And.intro (@And a b) c (@And.intro a b ha hb) hc))
theorem and_and_and_comm : {a : Prop} -> {b : Prop} -> {c : Prop} -> {d : Prop} -> @Iff (@And (@And a b) (@And c d)) (@And (@And a c) (@And b d)) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun {d : Prop} => @Eq.mpr (@Iff (@And (@And a b) (@And c d)) (@And (@And a c) (@And b d))) (@Iff (@And (@And (@And a b) c) d) (@And (@And a c) (@And b d))) (@id (@Eq Prop (@Iff (@And (@And a b) (@And c d)) (@And (@And a c) (@And b d))) (@Iff (@And (@And (@And a b) c) d) (@And (@And a c) (@And b d)))) (@congrArg Prop Prop (@And (@And a b) (@And c d)) (@And (@And (@And a b) c) d) (fun (_a : Prop) => @Iff _a (@And (@And a c) (@And b d))) (@Eq.symm Prop (@And (@And (@And a b) c) d) (@And (@And a b) (@And c d)) (@propext (@And (@And (@And a b) c) d) (@And (@And a b) (@And c d)) (@and_assoc (@And a b) c d))))) (@Eq.mpr (@Iff (@And (@And (@And a b) c) d) (@And (@And a c) (@And b d))) (@Iff (@And (@And (@And a c) b) d) (@And (@And a c) (@And b d))) (@id (@Eq Prop (@Iff (@And (@And (@And a b) c) d) (@And (@And a c) (@And b d))) (@Iff (@And (@And (@And a c) b) d) (@And (@And a c) (@And b d)))) (@congrArg Prop Prop (@And (@And a b) c) (@And (@And a c) b) (fun (_a : Prop) => @Iff (@And _a d) (@And (@And a c) (@And b d))) (@propext (@And (@And a b) c) (@And (@And a c) b) (@and_right_comm a b c)))) (@Eq.mpr (@Iff (@And (@And (@And a c) b) d) (@And (@And a c) (@And b d))) (@Iff (@And (@And a c) (@And b d)) (@And (@And a c) (@And b d))) (@id (@Eq Prop (@Iff (@And (@And (@And a c) b) d) (@And (@And a c) (@And b d))) (@Iff (@And (@And a c) (@And b d)) (@And (@And a c) (@And b d)))) (@congrArg Prop Prop (@And (@And (@And a c) b) d) (@And (@And a c) (@And b d)) (fun (_a : Prop) => @Iff _a (@And (@And a c) (@And b d))) (@propext (@And (@And (@And a c) b) d) (@And (@And a c) (@And b d)) (@and_assoc (@And a c) b d)))) (@Iff.rfl (@And (@And a c) (@And b d)))))
theorem and_and_left : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff (@And a (@And b c)) (@And (@And a b) (@And a c)) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => @Eq.mpr (@Iff (@And a (@And b c)) (@And (@And a b) (@And a c))) (@Iff (@And a (@And b c)) (@And (@And a a) (@And b c))) (@id (@Eq Prop (@Iff (@And a (@And b c)) (@And (@And a b) (@And a c))) (@Iff (@And a (@And b c)) (@And (@And a a) (@And b c)))) (@congrArg Prop Prop (@And (@And a b) (@And a c)) (@And (@And a a) (@And b c)) (fun (_a : Prop) => @Iff (@And a (@And b c)) _a) (@propext (@And (@And a b) (@And a c)) (@And (@And a a) (@And b c)) (@and_and_and_comm a b a c)))) (@Eq.mpr (@Iff (@And a (@And b c)) (@And (@And a a) (@And b c))) (@Iff (@And a (@And b c)) (@And a (@And b c))) (@id (@Eq Prop (@Iff (@And a (@And b c)) (@And (@And a a) (@And b c))) (@Iff (@And a (@And b c)) (@And a (@And b c)))) (@congrArg Prop Prop (@And a a) a (fun (_a : Prop) => @Iff (@And a (@And b c)) (@And _a (@And b c))) (@and_self a))) (@Iff.rfl (@And a (@And b c))))
theorem and_and_right : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff (@And (@And a b) c) (@And (@And a c) (@And b c)) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => @Eq.mpr (@Iff (@And (@And a b) c) (@And (@And a c) (@And b c))) (@Iff (@And (@And a b) c) (@And (@And a b) (@And c c))) (@id (@Eq Prop (@Iff (@And (@And a b) c) (@And (@And a c) (@And b c))) (@Iff (@And (@And a b) c) (@And (@And a b) (@And c c)))) (@congrArg Prop Prop (@And (@And a c) (@And b c)) (@And (@And a b) (@And c c)) (fun (_a : Prop) => @Iff (@And (@And a b) c) _a) (@propext (@And (@And a c) (@And b c)) (@And (@And a b) (@And c c)) (@and_and_and_comm a c b c)))) (@Eq.mpr (@Iff (@And (@And a b) c) (@And (@And a b) (@And c c))) (@Iff (@And (@And a b) c) (@And (@And a b) c)) (@id (@Eq Prop (@Iff (@And (@And a b) c) (@And (@And a b) (@And c c))) (@Iff (@And (@And a b) c) (@And (@And a b) c))) (@congrArg Prop Prop (@And c c) c (fun (_a : Prop) => @Iff (@And (@And a b) c) (@And (@And a b) _a)) (@and_self c))) (@Iff.rfl (@And (@And a b) c)))
theorem and_iff_left : {b : Prop} -> {a : Prop} -> b -> @Iff (@And a b) a :=
  fun {b : Prop} => fun {a : Prop} => fun (hb : b) => @Iff.intro (@And a b) a (@And.left a b) (fun (x : a) => @And.intro a b x hb)
theorem and_iff_right : {a : Prop} -> {b : Prop} -> a -> @Iff (@And a b) b :=
  fun {a : Prop} => fun {b : Prop} => fun (ha : a) => @Iff.intro (@And a b) b (@And.right a b) (fun (x : b) => @And.intro a b ha x)
-- recursor Or.rec : {a : Prop} -> {b : Prop} -> {motive : @Or a b -> Prop} -> ((h : a) -> motive (@Or.inl a b h)) -> ((h : b) -> motive (@Or.inr a b h)) -> (t : @Or a b) -> motive t
-- def Or.casesOn : {a : Prop} -> {b : Prop} -> {motive : @Or a b -> Prop} -> (t : @Or a b) -> ((h : a) -> motive (@Or.inl a b h)) -> ((h : b) -> motive (@Or.inr a b h)) -> motive t :=
--  fun {a : Prop} => fun {b : Prop} => fun {motive : @Or a b -> Prop} => fun (t : @Or a b) => fun (inl : (h : a) -> motive (@Or.inl a b h)) => fun (inr : (h : b) -> motive (@Or.inr a b h)) => @Or.rec a b motive (fun (h : a) => inl h) (fun (h : b) => inr h) t
def or_self.match_1 : (p : Prop) -> (motive : @Or p p -> Prop) -> (x : @Or p p) -> ((h : p) -> motive (@Or.inl p p h)) -> ((h : p) -> motive (@Or.inr p p h)) -> motive x :=
  fun (p : Prop) => fun (motive : @Or p p -> Prop) => fun (x : @Or p p) => fun (h_1 : (h : p) -> motive (@Or.inl p p h)) => fun (h_2 : (h : p) -> motive (@Or.inr p p h)) => @Or.casesOn p p (fun (x1 : @Or p p) => motive x1) x (fun (h : p) => h_1 h) (fun (h : p) => h_2 h)
theorem or_self : (p : Prop) -> @Eq Prop (@Or p p) p :=
  fun (p : Prop) => @propext (@Or p p) p (@Iff.intro (@Or p p) p (fun (x : @Or p p) => @or_self.match_1 p (fun (_ : @Or p p) => p) x (fun (h : p) => h) (fun (h : p) => h)) (@Or.inl p p))
theorem or_self_iff : {a : Prop} -> @Iff (@Or a a) a :=
  fun {a : Prop} => @Eq.rec Prop a (fun (x : Prop) => fun (_ : @Eq Prop a x) => @Iff x a) (@Iff.rfl a) (@Or a a) (@Eq.symm Prop (@Or a a) a (@or_self a))
def Or.elim.match_1 : {a : Prop} -> {b : Prop} -> (motive : @Or a b -> Prop) -> (h : @Or a b) -> ((h1 : a) -> motive (@Or.inl a b h1)) -> ((h1 : b) -> motive (@Or.inr a b h1)) -> motive h :=
  fun {a : Prop} => fun {b : Prop} => fun (motive : @Or a b -> Prop) => fun (h : @Or a b) => fun (h_1 : (h1 : a) -> motive (@Or.inl a b h1)) => fun (h_2 : (h1 : b) -> motive (@Or.inr a b h1)) => @Or.casesOn a b (fun (x : @Or a b) => motive x) h (fun (h1 : a) => h_1 h1) (fun (h1 : b) => h_2 h1)
theorem Or.elim : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Or a b -> (a -> c) -> (b -> c) -> c :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (h : @Or a b) => fun (left : a -> c) => fun (right : b -> c) => @Or.elim.match_1 a b (fun (_ : @Or a b) => c) h (fun (h1 : a) => left h1) (fun (h1 : b) => right h1)
theorem not_or_intro : {a : Prop} -> {b : Prop} -> @Not a -> @Not b -> @Not (@Or a b) :=
  fun {a : Prop} => fun {b : Prop} => fun (ha : @Not a) => fun (hb : @Not b) => fun (x : @Or a b) => @Or.elim a b False x ha hb
theorem Or.imp : {a : Prop} -> {c : Prop} -> {b : Prop} -> {d : Prop} -> (a -> c) -> (b -> d) -> @Or a b -> @Or c d :=
  fun {a : Prop} => fun {c : Prop} => fun {b : Prop} => fun {d : Prop} => fun (f : a -> c) => fun (g : b -> d) => fun (h : @Or a b) => @Or.elim a b (@Or c d) h (@Function.comp a c (@Or c d) (@Or.inl c d) f) (@Function.comp b d (@Or c d) (@Or.inr c d) g)
theorem or_congr : {a : Prop} -> {c : Prop} -> {b : Prop} -> {d : Prop} -> @Iff a c -> @Iff b d -> @Iff (@Or a b) (@Or c d) :=
  fun {a : Prop} => fun {c : Prop} => fun {b : Prop} => fun {d : Prop} => fun (h₁ : @Iff a c) => fun (h₂ : @Iff b d) => @Iff.intro (@Or a b) (@Or c d) (@Or.imp a c b d (@Iff.mp a c h₁) (@Iff.mp b d h₂)) (@Or.imp c a d b (@Iff.mpr a c h₁) (@Iff.mpr b d h₂))
theorem or_congr_left : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff a b -> @Iff (@Or a c) (@Or b c) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (h : @Iff a b) => @or_congr a b c c h (@Iff.rfl c)
theorem or_congr_right : {b : Prop} -> {c : Prop} -> {a : Prop} -> @Iff b c -> @Iff (@Or a b) (@Or a c) :=
  fun {b : Prop} => fun {c : Prop} => fun {a : Prop} => fun (h : @Iff b c) => @or_congr a a b c (@Iff.rfl a) h
theorem Or.imp_right : {b : Prop} -> {c : Prop} -> {a : Prop} -> (b -> c) -> @Or a b -> @Or a c :=
  fun {b : Prop} => fun {c : Prop} => fun {a : Prop} => fun (f : b -> c) => @Or.imp a a b c (@id a) f
theorem Or.imp_left : {a : Prop} -> {b : Prop} -> {c : Prop} -> (a -> b) -> @Or a c -> @Or b c :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (f : a -> b) => @Or.imp a b c c f (@id c)
theorem or_assoc : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff (@Or (@Or a b) c) (@Or a (@Or b c)) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => @Iff.intro (@Or (@Or a b) c) (@Or a (@Or b c)) (fun (t : @Or (@Or a b) c) => @Or.rec (@Or a b) c (fun (_ : @Or (@Or a b) c) => @Or a (@Or b c)) (@Or.imp_right b (@Or b c) a (@Or.inl b c)) (@Function.comp c (@Or b c) (@Or a (@Or b c)) (@Or.inr a (@Or b c)) (@Or.inr b c)) t) (fun (t : @Or a (@Or b c)) => @Or.rec a (@Or b c) (fun (_ : @Or a (@Or b c)) => @Or (@Or a b) c) (@Function.comp a (@Or a b) (@Or (@Or a b) c) (@Or.inl (@Or a b) c) (@Or.inl a b)) (@Or.imp_left b (@Or a b) c (@Or.inr a b)) t)
theorem Or.symm : {a : Prop} -> {b : Prop} -> @Or a b -> @Or b a :=
  fun {a : Prop} => fun {b : Prop} => fun (t : @Or a b) => @Or.rec a b (fun (_ : @Or a b) => @Or b a) (@Or.inr b a) (@Or.inl b a) t
theorem Or.comm : {a : Prop} -> {b : Prop} -> @Iff (@Or a b) (@Or b a) :=
  fun {a : Prop} => fun {b : Prop} => @Iff.intro (@Or a b) (@Or b a) (@Or.symm a b) (@Or.symm b a)
theorem or_comm : {a : Prop} -> {b : Prop} -> @Iff (@Or a b) (@Or b a) :=
  fun {a : Prop} => fun {b : Prop} => @Or.comm a b
theorem or_left_comm : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff (@Or a (@Or b c)) (@Or b (@Or a c)) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => @Eq.mpr (@Iff (@Or a (@Or b c)) (@Or b (@Or a c))) (@Iff (@Or (@Or a b) c) (@Or b (@Or a c))) (@id (@Eq Prop (@Iff (@Or a (@Or b c)) (@Or b (@Or a c))) (@Iff (@Or (@Or a b) c) (@Or b (@Or a c)))) (@congrArg Prop Prop (@Or a (@Or b c)) (@Or (@Or a b) c) (fun (_a : Prop) => @Iff _a (@Or b (@Or a c))) (@Eq.symm Prop (@Or (@Or a b) c) (@Or a (@Or b c)) (@propext (@Or (@Or a b) c) (@Or a (@Or b c)) (@or_assoc a b c))))) (@Eq.mpr (@Iff (@Or (@Or a b) c) (@Or b (@Or a c))) (@Iff (@Or (@Or a b) c) (@Or (@Or b a) c)) (@id (@Eq Prop (@Iff (@Or (@Or a b) c) (@Or b (@Or a c))) (@Iff (@Or (@Or a b) c) (@Or (@Or b a) c))) (@congrArg Prop Prop (@Or b (@Or a c)) (@Or (@Or b a) c) (fun (_a : Prop) => @Iff (@Or (@Or a b) c) _a) (@Eq.symm Prop (@Or (@Or b a) c) (@Or b (@Or a c)) (@propext (@Or (@Or b a) c) (@Or b (@Or a c)) (@or_assoc b a c))))) (@Eq.mpr (@Iff (@Or (@Or a b) c) (@Or (@Or b a) c)) (@Iff (@Or (@Or b a) c) (@Or (@Or b a) c)) (@id (@Eq Prop (@Iff (@Or (@Or a b) c) (@Or (@Or b a) c)) (@Iff (@Or (@Or b a) c) (@Or (@Or b a) c))) (@congrArg Prop Prop (@Or a b) (@Or b a) (fun (_a : Prop) => @Iff (@Or _a c) (@Or (@Or b a) c)) (@propext (@Or a b) (@Or b a) (@or_comm a b)))) (@Iff.rfl (@Or (@Or b a) c))))
theorem or_right_comm : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff (@Or (@Or a b) c) (@Or (@Or a c) b) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => @Eq.mpr (@Iff (@Or (@Or a b) c) (@Or (@Or a c) b)) (@Iff (@Or a (@Or b c)) (@Or (@Or a c) b)) (@id (@Eq Prop (@Iff (@Or (@Or a b) c) (@Or (@Or a c) b)) (@Iff (@Or a (@Or b c)) (@Or (@Or a c) b))) (@congrArg Prop Prop (@Or (@Or a b) c) (@Or a (@Or b c)) (fun (_a : Prop) => @Iff _a (@Or (@Or a c) b)) (@propext (@Or (@Or a b) c) (@Or a (@Or b c)) (@or_assoc a b c)))) (@Eq.mpr (@Iff (@Or a (@Or b c)) (@Or (@Or a c) b)) (@Iff (@Or a (@Or b c)) (@Or a (@Or c b))) (@id (@Eq Prop (@Iff (@Or a (@Or b c)) (@Or (@Or a c) b)) (@Iff (@Or a (@Or b c)) (@Or a (@Or c b)))) (@congrArg Prop Prop (@Or (@Or a c) b) (@Or a (@Or c b)) (fun (_a : Prop) => @Iff (@Or a (@Or b c)) _a) (@propext (@Or (@Or a c) b) (@Or a (@Or c b)) (@or_assoc a c b)))) (@Eq.mpr (@Iff (@Or a (@Or b c)) (@Or a (@Or c b))) (@Iff (@Or a (@Or c b)) (@Or a (@Or c b))) (@id (@Eq Prop (@Iff (@Or a (@Or b c)) (@Or a (@Or c b))) (@Iff (@Or a (@Or c b)) (@Or a (@Or c b)))) (@congrArg Prop Prop (@Or b c) (@Or c b) (fun (_a : Prop) => @Iff (@Or a _a) (@Or a (@Or c b))) (@propext (@Or b c) (@Or c b) (@or_comm b c)))) (@Iff.rfl (@Or a (@Or c b)))))
theorem or_or_or_comm : {a : Prop} -> {b : Prop} -> {c : Prop} -> {d : Prop} -> @Iff (@Or (@Or a b) (@Or c d)) (@Or (@Or a c) (@Or b d)) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun {d : Prop} => @Eq.mpr (@Iff (@Or (@Or a b) (@Or c d)) (@Or (@Or a c) (@Or b d))) (@Iff (@Or (@Or (@Or a b) c) d) (@Or (@Or a c) (@Or b d))) (@id (@Eq Prop (@Iff (@Or (@Or a b) (@Or c d)) (@Or (@Or a c) (@Or b d))) (@Iff (@Or (@Or (@Or a b) c) d) (@Or (@Or a c) (@Or b d)))) (@congrArg Prop Prop (@Or (@Or a b) (@Or c d)) (@Or (@Or (@Or a b) c) d) (fun (_a : Prop) => @Iff _a (@Or (@Or a c) (@Or b d))) (@Eq.symm Prop (@Or (@Or (@Or a b) c) d) (@Or (@Or a b) (@Or c d)) (@propext (@Or (@Or (@Or a b) c) d) (@Or (@Or a b) (@Or c d)) (@or_assoc (@Or a b) c d))))) (@Eq.mpr (@Iff (@Or (@Or (@Or a b) c) d) (@Or (@Or a c) (@Or b d))) (@Iff (@Or (@Or (@Or a c) b) d) (@Or (@Or a c) (@Or b d))) (@id (@Eq Prop (@Iff (@Or (@Or (@Or a b) c) d) (@Or (@Or a c) (@Or b d))) (@Iff (@Or (@Or (@Or a c) b) d) (@Or (@Or a c) (@Or b d)))) (@congrArg Prop Prop (@Or (@Or a b) c) (@Or (@Or a c) b) (fun (_a : Prop) => @Iff (@Or _a d) (@Or (@Or a c) (@Or b d))) (@propext (@Or (@Or a b) c) (@Or (@Or a c) b) (@or_right_comm a b c)))) (@Eq.mpr (@Iff (@Or (@Or (@Or a c) b) d) (@Or (@Or a c) (@Or b d))) (@Iff (@Or (@Or a c) (@Or b d)) (@Or (@Or a c) (@Or b d))) (@id (@Eq Prop (@Iff (@Or (@Or (@Or a c) b) d) (@Or (@Or a c) (@Or b d))) (@Iff (@Or (@Or a c) (@Or b d)) (@Or (@Or a c) (@Or b d)))) (@congrArg Prop Prop (@Or (@Or (@Or a c) b) d) (@Or (@Or a c) (@Or b d)) (fun (_a : Prop) => @Iff _a (@Or (@Or a c) (@Or b d))) (@propext (@Or (@Or (@Or a c) b) d) (@Or (@Or a c) (@Or b d)) (@or_assoc (@Or a c) b d)))) (@Iff.rfl (@Or (@Or a c) (@Or b d)))))
theorem or_or_distrib_left : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff (@Or a (@Or b c)) (@Or (@Or a b) (@Or a c)) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => @Eq.mpr (@Iff (@Or a (@Or b c)) (@Or (@Or a b) (@Or a c))) (@Iff (@Or a (@Or b c)) (@Or (@Or a a) (@Or b c))) (@id (@Eq Prop (@Iff (@Or a (@Or b c)) (@Or (@Or a b) (@Or a c))) (@Iff (@Or a (@Or b c)) (@Or (@Or a a) (@Or b c)))) (@congrArg Prop Prop (@Or (@Or a b) (@Or a c)) (@Or (@Or a a) (@Or b c)) (fun (_a : Prop) => @Iff (@Or a (@Or b c)) _a) (@propext (@Or (@Or a b) (@Or a c)) (@Or (@Or a a) (@Or b c)) (@or_or_or_comm a b a c)))) (@Eq.mpr (@Iff (@Or a (@Or b c)) (@Or (@Or a a) (@Or b c))) (@Iff (@Or a (@Or b c)) (@Or a (@Or b c))) (@id (@Eq Prop (@Iff (@Or a (@Or b c)) (@Or (@Or a a) (@Or b c))) (@Iff (@Or a (@Or b c)) (@Or a (@Or b c)))) (@congrArg Prop Prop (@Or a a) a (fun (_a : Prop) => @Iff (@Or a (@Or b c)) (@Or _a (@Or b c))) (@or_self a))) (@Iff.rfl (@Or a (@Or b c))))
theorem or_or_distrib_right : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff (@Or (@Or a b) c) (@Or (@Or a c) (@Or b c)) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => @Eq.mpr (@Iff (@Or (@Or a b) c) (@Or (@Or a c) (@Or b c))) (@Iff (@Or (@Or a b) c) (@Or (@Or a b) (@Or c c))) (@id (@Eq Prop (@Iff (@Or (@Or a b) c) (@Or (@Or a c) (@Or b c))) (@Iff (@Or (@Or a b) c) (@Or (@Or a b) (@Or c c)))) (@congrArg Prop Prop (@Or (@Or a c) (@Or b c)) (@Or (@Or a b) (@Or c c)) (fun (_a : Prop) => @Iff (@Or (@Or a b) c) _a) (@propext (@Or (@Or a c) (@Or b c)) (@Or (@Or a b) (@Or c c)) (@or_or_or_comm a c b c)))) (@Eq.mpr (@Iff (@Or (@Or a b) c) (@Or (@Or a b) (@Or c c))) (@Iff (@Or (@Or a b) c) (@Or (@Or a b) c)) (@id (@Eq Prop (@Iff (@Or (@Or a b) c) (@Or (@Or a b) (@Or c c))) (@Iff (@Or (@Or a b) c) (@Or (@Or a b) c))) (@congrArg Prop Prop (@Or c c) c (fun (_a : Prop) => @Iff (@Or (@Or a b) c) (@Or (@Or a b) _a)) (@or_self c))) (@Iff.rfl (@Or (@Or a b) c)))
inductive True : Prop where
  | intro : True
-- ctor True.intro : True
theorem trivial : True :=
  True.intro
theorem of_eq_true : {p : Prop} -> @Eq Prop p True -> p :=
  fun {p : Prop} => fun (h : @Eq Prop p True) => @Eq.rec Prop True (fun (x : Prop) => fun (_ : @Eq Prop True x) => x) trivial p (@Eq.symm Prop p True h)
theorem Eq.trans : {α : Sort u} -> {a : α} -> {b : α} -> {c : α} -> @Eq α a b -> @Eq α b c -> @Eq α a c :=
  fun {α : Sort u} => fun {a : α} => fun {b : α} => fun {c : α} => fun (h₁ : @Eq α a b) => fun (h₂ : @Eq α b c) => @Eq.rec α b (fun (x : α) => fun (_ : @Eq α b x) => @Eq α a x) h₁ c h₂
theorem Init.PropLemmas._auxLemma_3 : {a : Prop} -> {b : Prop} -> @Eq Prop (@Or a b) (@Or b a) :=
  fun {a : Prop} => fun {b : Prop} => @propext (@Or a b) (@Or b a) (@Or.comm a b)
theorem Init.PropLemmas._auxLemma_2 : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Eq Prop (@Or a (@Or b c)) (@Or b (@Or a c)) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => @propext (@Or a (@Or b c)) (@Or b (@Or a c)) (@or_left_comm a b c)
theorem eq_true : {p : Prop} -> p -> @Eq Prop p True :=
  fun {p : Prop} => fun (h : p) => @propext p True (@Iff.intro p True (fun (_ : p) => trivial) (fun (_ : True) => h))
theorem iff_self : (p : Prop) -> @Eq Prop (@Iff p p) True :=
  fun (p : Prop) => @eq_true (@Iff p p) (@Iff.rfl p)
theorem or_rotate : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff (@Or a (@Or b c)) (@Or b (@Or c a)) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => @of_eq_true (@Iff (@Or a (@Or b c)) (@Or b (@Or c a))) (@Eq.trans Prop (@Iff (@Or a (@Or b c)) (@Or b (@Or c a))) (@Iff (@Or a (@Or b c)) (@Or a (@Or b c))) True (@congrArg Prop Prop (@Or b (@Or c a)) (@Or a (@Or b c)) (@Iff (@Or a (@Or b c))) (@Eq.trans Prop (@Or b (@Or c a)) (@Or b (@Or a c)) (@Or a (@Or b c)) (@congrArg Prop Prop (@Or c a) (@Or a c) (@Or b) (@Init.PropLemmas._auxLemma_3 c a)) (@Init.PropLemmas._auxLemma_2 b a c))) (@iff_self (@Or a (@Or b c))))
theorem or_iff_left_of_imp : {b : Prop} -> {a : Prop} -> (b -> a) -> @Iff (@Or a b) a :=
  fun {b : Prop} => fun {a : Prop} => fun (hb : b -> a) => @Iff.intro (@Or a b) a (fun (t : @Or a b) => @Or.rec a b (fun (_ : @Or a b) => a) (@id a) hb t) (@Or.inl a b)
theorem or_iff_left_iff_imp : {a : Prop} -> {b : Prop} -> @Iff (@Iff (@Or a b) a) (b -> a) :=
  fun {a : Prop} => fun {b : Prop} => @Iff.intro (@Iff (@Or a b) a) (b -> a) (fun (x : @Iff (@Or a b) a) => @Function.comp b (@Or a b) a (@Iff.mp (@Or a b) a x) (@Or.inr a b)) (@or_iff_left_of_imp b a)
theorem or_iff_left : {b : Prop} -> {a : Prop} -> @Not b -> @Iff (@Or a b) a :=
  fun {b : Prop} => fun {a : Prop} => fun (hb : @Not b) => @Iff.mpr (@Iff (@Or a b) a) (b -> a) (@or_iff_left_iff_imp a b) (@Not.elim b a hb)
theorem or_iff_right_iff_imp : {a : Prop} -> {b : Prop} -> @Iff (@Iff (@Or a b) b) (a -> b) :=
  fun {a : Prop} => fun {b : Prop} => @Eq.mpr (@Iff (@Iff (@Or a b) b) (a -> b)) (@Iff (@Iff (@Or b a) b) (a -> b)) (@id (@Eq Prop (@Iff (@Iff (@Or a b) b) (a -> b)) (@Iff (@Iff (@Or b a) b) (a -> b))) (@congrArg Prop Prop (@Or a b) (@Or b a) (fun (_a : Prop) => @Iff (@Iff _a b) (a -> b)) (@propext (@Or a b) (@Or b a) (@or_comm a b)))) (@Eq.mpr (@Iff (@Iff (@Or b a) b) (a -> b)) (@Iff (a -> b) (a -> b)) (@id (@Eq Prop (@Iff (@Iff (@Or b a) b) (a -> b)) (@Iff (a -> b) (a -> b))) (@congrArg Prop Prop (@Iff (@Or b a) b) (a -> b) (fun (_a : Prop) => @Iff _a (a -> b)) (@propext (@Iff (@Or b a) b) (a -> b) (@or_iff_left_iff_imp b a)))) (@Iff.rfl (a -> b)))
theorem or_iff_right : {a : Prop} -> {b : Prop} -> @Not a -> @Iff (@Or a b) b :=
  fun {a : Prop} => fun {b : Prop} => fun (ha : @Not a) => @Iff.mpr (@Iff (@Or a b) b) (a -> b) (@or_iff_right_iff_imp a b) (@Not.elim a b ha)
def not_imp_of_and_not.match_1 : {a : Prop} -> {b : Prop} -> (motive : @And a (@Not b) -> (a -> b) -> Prop) -> (x : @And a (@Not b)) -> (x1 : a -> b) -> ((ha : a) -> (hb : @Not b) -> (h : a -> b) -> motive (@And.intro a (@Not b) ha hb) h) -> motive x x1 :=
  fun {a : Prop} => fun {b : Prop} => fun (motive : @And a (@Not b) -> (a -> b) -> Prop) => fun (x : @And a (@Not b)) => fun (x1 : a -> b) => fun (h_1 : (ha : a) -> (hb : @Not b) -> (h : a -> b) -> motive (@And.intro a (@Not b) ha hb) h) => @And.casesOn a (@Not b) (fun (x2 : @And a (@Not b)) => motive x2 x1) x (fun (left : a) => fun (right : @Not b) => h_1 left right x1)
theorem not_imp_of_and_not : {a : Prop} -> {b : Prop} -> @And a (@Not b) -> @Not (a -> b) :=
  fun {a : Prop} => fun {b : Prop} => fun (x : @And a (@Not b)) => fun (x1 : a -> b) => @not_imp_of_and_not.match_1 a b (fun (_ : @And a (@Not b)) => fun (_ : a -> b) => False) x x1 (fun (ha : a) => fun (hb : @Not b) => fun (h : a -> b) => hb (h ha))
theorem imp_and : {b : Prop} -> {c : Prop} -> {α : Sort u_1} -> @Iff (α -> @And b c) (@And (α -> b) (α -> c)) :=
  fun {b : Prop} => fun {c : Prop} => fun {α : Sort u_1} => @Iff.intro (α -> @And b c) (@And (α -> b) (α -> c)) (fun (h : α -> @And b c) => @And.intro (α -> b) (α -> c) (fun (ha : α) => @And.left b c (h ha)) (fun (ha : α) => @And.right b c (h ha))) (fun (h : @And (α -> b) (α -> c)) => fun (ha : α) => @And.intro b c (@And.left (α -> b) (α -> c) h ha) (@And.right (α -> b) (α -> c) h ha))
theorem and_imp : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff (@And a b -> c) (a -> b -> c) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => @Iff.intro (@And a b -> c) (a -> b -> c) (fun (h : @And a b -> c) => fun (ha : a) => fun (hb : b) => h (@And.intro a b ha hb)) (fun (h : a -> b -> c) => fun (x : @And a b) => @and_imp.match_1 a b (fun (_ : @And a b) => c) x (fun (ha : a) => fun (hb : b) => h ha hb))
theorem not_and : {a : Prop} -> {b : Prop} -> @Iff (@Not (@And a b)) (a -> @Not b) :=
  fun {a : Prop} => fun {b : Prop} => @and_imp a b False
def flip : {α : Sort u} -> {β : Sort v} -> {φ : Sort w} -> (α -> β -> φ) -> β -> α -> φ :=
  fun {α : Sort u} => fun {β : Sort v} => fun {φ : Sort w} => fun (f : α -> β -> φ) => fun (b : β) => fun (a : α) => f a b
theorem imp.swap : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff (a -> b -> c) (b -> a -> c) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => @Iff.intro (a -> b -> c) (b -> a -> c) (@flip a b c) (@flip b a c)
theorem imp_not_comm : {a : Prop} -> {b : Prop} -> @Iff (a -> @Not b) (b -> @Not a) :=
  fun {a : Prop} => fun {b : Prop} => @imp.swap a b False
theorem not_and' : {a : Prop} -> {b : Prop} -> @Iff (@Not (@And a b)) (b -> @Not a) :=
  fun {a : Prop} => fun {b : Prop} => @Iff.trans (@Not (@And a b)) (a -> @Not b) (b -> @Not a) (@not_and a b) (@imp_not_comm a b)
def and_or_left.match_1 : {a : Prop} -> {b : Prop} -> {c : Prop} -> (motive : @And a (@Or b c) -> Prop) -> (x : @And a (@Or b c)) -> ((ha : a) -> (hbc : @Or b c) -> motive (@And.intro a (@Or b c) ha hbc)) -> motive x :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (motive : @And a (@Or b c) -> Prop) => fun (x : @And a (@Or b c)) => fun (h_1 : (ha : a) -> (hbc : @Or b c) -> motive (@And.intro a (@Or b c) ha hbc)) => @And.casesOn a (@Or b c) (fun (x1 : @And a (@Or b c)) => motive x1) x (fun (left : a) => fun (right : @Or b c) => h_1 left right)
theorem and_or_left : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff (@And a (@Or b c)) (@Or (@And a b) (@And a c)) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => @Iff.intro (@And a (@Or b c)) (@Or (@And a b) (@And a c)) (fun (x : @And a (@Or b c)) => @and_or_left.match_1 a b c (fun (_ : @And a (@Or b c)) => @Or (@And a b) (@And a c)) x (fun (ha : a) => fun (hbc : @Or b c) => @Or.imp b (@And a b) c (@And a c) (@And.intro a b ha) (@And.intro a c ha) hbc)) (fun (t : @Or (@And a b) (@And a c)) => @Or.rec (@And a b) (@And a c) (fun (_ : @Or (@And a b) (@And a c)) => @And a (@Or b c)) (@And.imp_right b (@Or b c) a (@Or.inl b c)) (@And.imp_right c (@Or b c) a (@Or.inr b c)) t)
theorem or_and_right : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff (@And (@Or a b) c) (@Or (@And a c) (@And b c)) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => @Eq.mpr (@Iff (@And (@Or a b) c) (@Or (@And a c) (@And b c))) (@Iff (@And c (@Or a b)) (@Or (@And a c) (@And b c))) (@id (@Eq Prop (@Iff (@And (@Or a b) c) (@Or (@And a c) (@And b c))) (@Iff (@And c (@Or a b)) (@Or (@And a c) (@And b c)))) (@congrArg Prop Prop (@And (@Or a b) c) (@And c (@Or a b)) (fun (_a : Prop) => @Iff _a (@Or (@And a c) (@And b c))) (@propext (@And (@Or a b) c) (@And c (@Or a b)) (@and_comm (@Or a b) c)))) (@Eq.mpr (@Iff (@And c (@Or a b)) (@Or (@And a c) (@And b c))) (@Iff (@Or (@And c a) (@And c b)) (@Or (@And a c) (@And b c))) (@id (@Eq Prop (@Iff (@And c (@Or a b)) (@Or (@And a c) (@And b c))) (@Iff (@Or (@And c a) (@And c b)) (@Or (@And a c) (@And b c)))) (@congrArg Prop Prop (@And c (@Or a b)) (@Or (@And c a) (@And c b)) (fun (_a : Prop) => @Iff _a (@Or (@And a c) (@And b c))) (@propext (@And c (@Or a b)) (@Or (@And c a) (@And c b)) (@and_or_left c a b)))) (@Eq.mpr (@Iff (@Or (@And c a) (@And c b)) (@Or (@And a c) (@And b c))) (@Iff (@Or (@And a c) (@And c b)) (@Or (@And a c) (@And b c))) (@id (@Eq Prop (@Iff (@Or (@And c a) (@And c b)) (@Or (@And a c) (@And b c))) (@Iff (@Or (@And a c) (@And c b)) (@Or (@And a c) (@And b c)))) (@congrArg Prop Prop (@And c a) (@And a c) (fun (_a : Prop) => @Iff (@Or _a (@And c b)) (@Or (@And a c) (@And b c))) (@propext (@And c a) (@And a c) (@and_comm c a)))) (@Eq.mpr (@Iff (@Or (@And a c) (@And c b)) (@Or (@And a c) (@And b c))) (@Iff (@Or (@And a c) (@And b c)) (@Or (@And a c) (@And b c))) (@id (@Eq Prop (@Iff (@Or (@And a c) (@And c b)) (@Or (@And a c) (@And b c))) (@Iff (@Or (@And a c) (@And b c)) (@Or (@And a c) (@And b c)))) (@congrArg Prop Prop (@And c b) (@And b c) (fun (_a : Prop) => @Iff (@Or (@And a c) _a) (@Or (@And a c) (@And b c))) (@propext (@And c b) (@And b c) (@and_comm c b)))) (@Iff.rfl (@Or (@And a c) (@And b c))))))
theorem or_and_left : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff (@Or a (@And b c)) (@And (@Or a b) (@Or a c)) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => @Iff.intro (@Or a (@And b c)) (@And (@Or a b) (@Or a c)) (fun (t : @Or a (@And b c)) => @Or.rec a (@And b c) (fun (_ : @Or a (@And b c)) => @And (@Or a b) (@Or a c)) (fun (ha : a) => @And.intro (@Or a b) (@Or a c) (@Or.inl a b ha) (@Or.inl a c ha)) (@And.imp b (@Or a b) c (@Or a c) (@Or.inr a b) (@Or.inr a c)) t) (fun (t : @And (@Or a b) (@Or a c)) => @And.rec (@Or a b) (@Or a c) (fun (_ : @And (@Or a b) (@Or a c)) => @Or a (@And b c)) (fun (t1 : @Or a b) => @Or.rec a b (fun (_ : @Or a b) => @Or a c -> @Or a (@And b c)) (fun (x : a) => fun (_ : @Or a c) => @Or.inl a (@And b c) x) (@Function.comp b (c -> @And b c) (@Or a c -> @Or a (@And b c)) (@Or.imp_right c (@And b c) a) (@And.intro b c)) t1) t)
theorem and_or_right : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff (@Or (@And a b) c) (@And (@Or a c) (@Or b c)) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => @Eq.mpr (@Iff (@Or (@And a b) c) (@And (@Or a c) (@Or b c))) (@Iff (@Or c (@And a b)) (@And (@Or a c) (@Or b c))) (@id (@Eq Prop (@Iff (@Or (@And a b) c) (@And (@Or a c) (@Or b c))) (@Iff (@Or c (@And a b)) (@And (@Or a c) (@Or b c)))) (@congrArg Prop Prop (@Or (@And a b) c) (@Or c (@And a b)) (fun (_a : Prop) => @Iff _a (@And (@Or a c) (@Or b c))) (@propext (@Or (@And a b) c) (@Or c (@And a b)) (@or_comm (@And a b) c)))) (@Eq.mpr (@Iff (@Or c (@And a b)) (@And (@Or a c) (@Or b c))) (@Iff (@And (@Or c a) (@Or c b)) (@And (@Or a c) (@Or b c))) (@id (@Eq Prop (@Iff (@Or c (@And a b)) (@And (@Or a c) (@Or b c))) (@Iff (@And (@Or c a) (@Or c b)) (@And (@Or a c) (@Or b c)))) (@congrArg Prop Prop (@Or c (@And a b)) (@And (@Or c a) (@Or c b)) (fun (_a : Prop) => @Iff _a (@And (@Or a c) (@Or b c))) (@propext (@Or c (@And a b)) (@And (@Or c a) (@Or c b)) (@or_and_left c a b)))) (@Eq.mpr (@Iff (@And (@Or c a) (@Or c b)) (@And (@Or a c) (@Or b c))) (@Iff (@And (@Or a c) (@Or c b)) (@And (@Or a c) (@Or b c))) (@id (@Eq Prop (@Iff (@And (@Or c a) (@Or c b)) (@And (@Or a c) (@Or b c))) (@Iff (@And (@Or a c) (@Or c b)) (@And (@Or a c) (@Or b c)))) (@congrArg Prop Prop (@Or c a) (@Or a c) (fun (_a : Prop) => @Iff (@And _a (@Or c b)) (@And (@Or a c) (@Or b c))) (@propext (@Or c a) (@Or a c) (@or_comm c a)))) (@Eq.mpr (@Iff (@And (@Or a c) (@Or c b)) (@And (@Or a c) (@Or b c))) (@Iff (@And (@Or a c) (@Or b c)) (@And (@Or a c) (@Or b c))) (@id (@Eq Prop (@Iff (@And (@Or a c) (@Or c b)) (@And (@Or a c) (@Or b c))) (@Iff (@And (@Or a c) (@Or b c)) (@And (@Or a c) (@Or b c)))) (@congrArg Prop Prop (@Or c b) (@Or b c) (fun (_a : Prop) => @Iff (@And (@Or a c) _a) (@And (@Or a c) (@Or b c))) (@propext (@Or c b) (@Or b c) (@or_comm c b)))) (@Iff.rfl (@And (@Or a c) (@Or b c))))))
def or_imp.match_1 : {a : Prop} -> {b : Prop} -> {c : Prop} -> (motive : @And (a -> c) (b -> c) -> Prop) -> (x : @And (a -> c) (b -> c)) -> ((ha : a -> c) -> (hb : b -> c) -> motive (@And.intro (a -> c) (b -> c) ha hb)) -> motive x :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (motive : @And (a -> c) (b -> c) -> Prop) => fun (x : @And (a -> c) (b -> c)) => fun (h_1 : (ha : a -> c) -> (hb : b -> c) -> motive (@And.intro (a -> c) (b -> c) ha hb)) => @And.casesOn (a -> c) (b -> c) (fun (x1 : @And (a -> c) (b -> c)) => motive x1) x (fun (left : a -> c) => fun (right : b -> c) => h_1 left right)
theorem or_imp : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Iff (@Or a b -> c) (@And (a -> c) (b -> c)) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => @Iff.intro (@Or a b -> c) (@And (a -> c) (b -> c)) (fun (h : @Or a b -> c) => @And.intro (a -> c) (b -> c) (@Function.comp a (@Or a b) c h (@Or.inl a b)) (@Function.comp b (@Or a b) c h (@Or.inr a b))) (fun (x : @And (a -> c) (b -> c)) => @or_imp.match_1 a b c (fun (_ : @And (a -> c) (b -> c)) => @Or a b -> c) x (fun (ha : a -> c) => fun (hb : b -> c) => fun (t : @Or a b) => @Or.rec a b (fun (_ : @Or a b) => c) ha hb t))
theorem not_and_of_not_or_not : {a : Prop} -> {b : Prop} -> @Or (@Not a) (@Not b) -> @Not (@And a b) :=
  fun {a : Prop} => fun {b : Prop} => fun (h : @Or (@Not a) (@Not b)) => @Or.elim (@Not a) (@Not b) (@Not (@And a b)) h (@mt (@And a b) a (fun (x : @And a b) => @And.left a b x)) (@mt (@And a b) b (fun (x : @And a b) => @And.right a b x))
def Ne : {α : Sort u} -> α -> α -> Prop :=
  fun {α : Sort u} => fun (a : α) => fun (b : α) => @Not (@Eq α a b)
theorem ne_of_apply_ne : {α : Sort u_1} -> {β : Sort u_2} -> (f : α -> β) -> {x : α} -> {y : α} -> @Ne β (f x) (f y) -> @Ne α x y :=
  fun {α : Sort u_1} => fun {β : Sort u_2} => fun (f : α -> β) => fun {x : α} => fun {y : α} => @mt (@Eq α x y) (@Eq β (f x) (f y)) (@congrArg α β x y f)
inductive Decidable : Prop -> Type where
  | isFalse : {p : Prop} -> @Not p -> @Decidable p
  | isTrue : {p : Prop} -> p -> @Decidable p
-- ctor Decidable.isFalse : {p : Prop} -> @Not p -> @Decidable p
-- ctor Decidable.isTrue : {p : Prop} -> p -> @Decidable p
-- recursor Decidable.rec : {p : Prop} -> {motive : @Decidable p -> Sort u} -> ((h : @Not p) -> motive (@Decidable.isFalse p h)) -> ((h : p) -> motive (@Decidable.isTrue p h)) -> (t : @Decidable p) -> motive t
-- def Decidable.casesOn : {p : Prop} -> {motive : @Decidable p -> Sort u} -> (t : @Decidable p) -> ((h : @Not p) -> motive (@Decidable.isFalse p h)) -> ((h : p) -> motive (@Decidable.isTrue p h)) -> motive t :=
--  fun {p : Prop} => fun {motive : @Decidable p -> Sort u} => fun (t : @Decidable p) => fun (isFalse : (h : @Not p) -> motive (@Decidable.isFalse p h)) => fun (isTrue : (h : p) -> motive (@Decidable.isTrue p h)) => @Decidable.rec p motive (fun (h : @Not p) => isFalse h) (fun (h : p) => isTrue h) t
def ite : {α : Sort u} -> (c : Prop) -> @Decidable c -> α -> α -> α :=
  fun {α : Sort u} => fun (c : Prop) => fun (h : @Decidable c) => fun (t : α) => fun (e : α) => @Decidable.casesOn c (fun (_ : @Decidable c) => α) h (fun (_ : @Not c) => e) (fun (_ : c) => t)
theorem congr : {α : Sort u} -> {β : Sort v} -> {f₁ : α -> β} -> {f₂ : α -> β} -> {a₁ : α} -> {a₂ : α} -> @Eq (α -> β) f₁ f₂ -> @Eq α a₁ a₂ -> @Eq β (f₁ a₁) (f₂ a₂) :=
  fun {α : Sort u} => fun {β : Sort v} => fun {f₁ : α -> β} => fun {f₂ : α -> β} => fun {a₁ : α} => fun {a₂ : α} => fun (h₁ : @Eq (α -> β) f₁ f₂) => fun (h₂ : @Eq α a₁ a₂) => @Eq.rec (α -> β) f₁ (fun (x : α -> β) => fun (_ : @Eq (α -> β) f₁ x) => @Eq β (f₁ a₁) (x a₂)) (@Eq.rec α a₁ (fun (x : α) => fun (_ : @Eq α a₁ x) => @Eq β (f₁ a₁) (f₁ x)) (@rfl β (f₁ a₁)) a₂ h₂) f₂ h₁
theorem not_false : @Not False :=
  @id False
def instDecidableFalse : @Decidable False :=
  @Decidable.isFalse False not_false
def Decidable.byCases.match_1 : {p : Prop} -> (motive : @Decidable p -> Sort u_1) -> (dec : @Decidable p) -> ((h : p) -> motive (@Decidable.isTrue p h)) -> ((h : @Not p) -> motive (@Decidable.isFalse p h)) -> motive dec :=
  fun {p : Prop} => fun (motive : @Decidable p -> Sort u_1) => fun (dec : @Decidable p) => fun (h_1 : (h : p) -> motive (@Decidable.isTrue p h)) => fun (h_2 : (h : @Not p) -> motive (@Decidable.isFalse p h)) => @Decidable.casesOn p (fun (x : @Decidable p) => motive x) dec (fun (h : @Not p) => h_2 h) (fun (h : p) => h_1 h)
def Decidable.byCases : {p : Prop} -> {q : Sort u} -> @Decidable p -> (p -> q) -> (@Not p -> q) -> q :=
  fun {p : Prop} => fun {q : Sort u} => fun (dec : @Decidable p) => fun (h1 : p -> q) => fun (h2 : @Not p -> q) => @Decidable.byCases.match_1 p (fun (_ : @Decidable p) => q) dec (fun (h : p) => h1 h) (fun (h : @Not p) => h2 h)
theorem Decidable.em : (p : Prop) -> @Decidable p -> @Or p (@Not p) :=
  fun (p : Prop) => fun (inst : @Decidable p) => @Decidable.byCases p (@Or p (@Not p)) inst (@Or.inl p (@Not p)) (@Or.inr p (@Not p))
def if_pos.match_1 : {c : Prop} -> (motive : @Decidable c -> Prop) -> (h : @Decidable c) -> ((h1 : c) -> motive (@Decidable.isTrue c h1)) -> ((hnc : @Not c) -> motive (@Decidable.isFalse c hnc)) -> motive h :=
  fun {c : Prop} => fun (motive : @Decidable c -> Prop) => fun (h : @Decidable c) => fun (h_1 : (h1 : c) -> motive (@Decidable.isTrue c h1)) => fun (h_2 : (hnc : @Not c) -> motive (@Decidable.isFalse c hnc)) => @Decidable.casesOn c (fun (x : @Decidable c) => motive x) h (fun (h1 : @Not c) => h_2 h1) (fun (h1 : c) => h_1 h1)
theorem if_pos : {c : Prop} -> {h : @Decidable c} -> c -> {α : Sort u} -> {t : α} -> {e : α} -> @Eq α (@ite α c h t e) t :=
  fun {c : Prop} => fun {h : @Decidable c} => fun (hc : c) => fun {α : Sort u} => fun {t : α} => fun {e : α} => @if_pos.match_1 c (fun (h1 : @Decidable c) => @Eq α (@ite α c h1 t e) t) h (fun (h1 : c) => @rfl α (@ite α c (@Decidable.isTrue c h1) t e)) (fun (hnc : @Not c) => @absurd c (@Eq α (@ite α c (@Decidable.isFalse c hnc) t e) t) hc hnc)
theorem if_neg : {c : Prop} -> {h : @Decidable c} -> @Not c -> {α : Sort u} -> {t : α} -> {e : α} -> @Eq α (@ite α c h t e) e :=
  fun {c : Prop} => fun {h : @Decidable c} => fun (hnc : @Not c) => fun {α : Sort u} => fun {t : α} => fun {e : α} => @if_pos.match_1 c (fun (h1 : @Decidable c) => @Eq α (@ite α c h1 t e) e) h (fun (hc : c) => @absurd c (@Eq α (@ite α c (@Decidable.isTrue c hc) t e) e) hc hnc) (fun (h1 : @Not c) => @rfl α (@ite α c (@Decidable.isFalse c h1) t e))
theorem ite_congr : {α : Sort u_1} -> {b : Prop} -> {c : Prop} -> {x : α} -> {y : α} -> {u : α} -> {v : α} -> {s : @Decidable b} -> (inst : @Decidable c) -> @Eq Prop b c -> (c -> @Eq α x u) -> (@Not c -> @Eq α y v) -> @Eq α (@ite α b s x y) (@ite α c inst u v) :=
  fun {α : Sort u_1} => fun {b : Prop} => fun {c : Prop} => fun {x : α} => fun {y : α} => fun {u : α} => fun {v : α} => fun {s : @Decidable b} => fun (inst : @Decidable c) => fun (h₁ : @Eq Prop b c) => fun (h₂ : c -> @Eq α x u) => fun (h₃ : @Not c -> @Eq α y v) => @Or.casesOn c (@Not c) (fun (t : @Or c (@Not c)) => @Eq (@Or c (@Not c)) (@Decidable.em c inst) t -> @Eq α (@ite α b s x y) (@ite α c inst u v)) (@Decidable.em c inst) (fun (h : c) => fun (_ : @Eq (@Or c (@Not c)) (@Decidable.em c inst) (@Or.inl c (@Not c) h)) => @Eq.mpr (@Eq α (@ite α b s x y) (@ite α c inst u v)) (@Eq α (@ite α b s x y) u) (@id (@Eq Prop (@Eq α (@ite α b s x y) (@ite α c inst u v)) (@Eq α (@ite α b s x y) u)) (@congrArg α Prop (@ite α c inst u v) u (fun (_a : α) => @Eq α (@ite α b s x y) _a) (@if_pos c inst h α u v))) (@Eq.ndrec Prop c (fun {b1 : Prop} => {s1 : @Decidable b1} -> @Eq α (@ite α b1 s1 x y) u) (fun {s1 : @Decidable c} => @Eq.mpr (@Eq α (@ite α c s1 x y) u) (@Eq α x u) (@id (@Eq Prop (@Eq α (@ite α c s1 x y) u) (@Eq α x u)) (@congrArg α Prop (@ite α c s1 x y) x (fun (_a : α) => @Eq α _a u) (@if_pos c s1 h α x y))) (h₂ h)) b (@Eq.symm Prop b c h₁) s)) (fun (h : @Not c) => fun (_ : @Eq (@Or c (@Not c)) (@Decidable.em c inst) (@Or.inr c (@Not c) h)) => @Eq.mpr (@Eq α (@ite α b s x y) (@ite α c inst u v)) (@Eq α (@ite α b s x y) v) (@id (@Eq Prop (@Eq α (@ite α b s x y) (@ite α c inst u v)) (@Eq α (@ite α b s x y) v)) (@congrArg α Prop (@ite α c inst u v) v (fun (_a : α) => @Eq α (@ite α b s x y) _a) (@if_neg c inst h α u v))) (@Eq.ndrec Prop c (fun {b1 : Prop} => {s1 : @Decidable b1} -> @Eq α (@ite α b1 s1 x y) v) (fun {s1 : @Decidable c} => @Eq.mpr (@Eq α (@ite α c s1 x y) v) (@Eq α y v) (@id (@Eq Prop (@Eq α (@ite α c s1 x y) v) (@Eq α y v)) (@congrArg α Prop (@ite α c s1 x y) y (fun (_a : α) => @Eq α _a v) (@if_neg c s1 h α x y))) (h₃ h)) b (@Eq.symm Prop b c h₁) s)) (@Eq.refl (@Or c (@Not c)) (@Decidable.em c inst))
theorem eq_self : {α : Sort u_1} -> (a : α) -> @Eq Prop (@Eq α a a) True :=
  fun {α : Sort u_1} => fun (a : α) => @eq_true (@Eq α a a) (@rfl α a)
theorem ite_cond_eq_false : {α : Sort u} -> {c : Prop} -> {x : @Decidable c} -> (a : α) -> (b : α) -> @Eq Prop c False -> @Eq α (@ite α c x a b) b :=
  fun {α : Sort u} => fun {c : Prop} => fun {x : @Decidable c} => fun (a : α) => fun (b : α) => fun (h : @Eq Prop c False) => @of_eq_true (@Eq α (@ite α c x a b) b) (@Eq.trans Prop (@Eq α (@ite α c x a b) b) (@Eq α (@ite α False instDecidableFalse a b) b) True (@congrArg α Prop (@ite α c x a b) (@ite α False instDecidableFalse a b) (fun (x1 : α) => @Eq α x1 b) (@ite_congr α c False a b a b x instDecidableFalse h (fun (_ : False) => @Eq.refl α a) (fun (_ : @Not False) => @Eq.refl α b))) (@eq_self α b))
def False.elim : {C : Sort u} -> False -> C :=
  fun {C : Sort u} => fun (h : False) => @False.rec (fun (_ : False) => C) h
theorem eq_false : {p : Prop} -> @Not p -> @Eq Prop p False :=
  fun {p : Prop} => fun (h : @Not p) => @propext p False (@Iff.intro p False (fun (h' : p) => @absurd p False h' h) (fun (h' : False) => @False.elim p h'))
theorem not_false_eq_true : @Eq Prop (@Not False) True :=
  @eq_true (@Not False) (@False.elim False)
theorem true_and : (p : Prop) -> @Eq Prop (@And True p) p :=
  fun (p : Prop) => @propext (@And True p) p (@Iff.intro (@And True p) p (fun (x : @And True p) => @And.right True p x) (fun (x : p) => @And.intro True p trivial x))
def instDecidableTrue : @Decidable True :=
  @Decidable.isTrue True trivial
theorem ite_cond_eq_true : {α : Sort u} -> {c : Prop} -> {x : @Decidable c} -> (a : α) -> (b : α) -> @Eq Prop c True -> @Eq α (@ite α c x a b) a :=
  fun {α : Sort u} => fun {c : Prop} => fun {x : @Decidable c} => fun (a : α) => fun (b : α) => fun (h : @Eq Prop c True) => @of_eq_true (@Eq α (@ite α c x a b) a) (@Eq.trans Prop (@Eq α (@ite α c x a b) a) (@Eq α (@ite α True instDecidableTrue a b) a) True (@congrArg α Prop (@ite α c x a b) (@ite α True instDecidableTrue a b) (fun (x1 : α) => @Eq α x1 a) (@ite_congr α c True a b a b x instDecidableTrue h (fun (_ : True) => @Eq.refl α a) (fun (_ : @Not True) => @Eq.refl α b))) (@eq_self α a))
inductive Bool : Type where
  | false : Bool
  | true : Bool
-- ctor Bool.false : Bool
-- ctor Bool.true : Bool
def Decidable.decide : (p : Prop) -> @Decidable p -> Bool :=
  fun (p : Prop) => fun (h : @Decidable p) => @Decidable.casesOn p (fun (_ : @Decidable p) => Bool) h (fun (_ : @Not p) => Bool.false) (fun (_ : p) => Bool.true)
def of_decide_eq_true.match_1 : {p : Prop} -> (motive : @Decidable p -> Prop) -> (inst : @Decidable p) -> ((h₁ : p) -> motive (@Decidable.isTrue p h₁)) -> ((h₁ : @Not p) -> motive (@Decidable.isFalse p h₁)) -> motive inst :=
  fun {p : Prop} => fun (motive : @Decidable p -> Prop) => fun (inst : @Decidable p) => fun (h_1 : (h₁ : p) -> motive (@Decidable.isTrue p h₁)) => fun (h_2 : (h₁ : @Not p) -> motive (@Decidable.isFalse p h₁)) => @Decidable.casesOn p (fun (x : @Decidable p) => motive x) inst (fun (h : @Not p) => h_2 h) (fun (h : p) => h_1 h)
-- recursor Bool.rec : {motive : Bool -> Sort u} -> motive Bool.false -> motive Bool.true -> (t : Bool) -> motive t
-- def Bool.casesOn : {motive : Bool -> Sort u} -> (t : Bool) -> motive Bool.false -> motive Bool.true -> motive t :=
--  fun {motive : Bool -> Sort u} => fun (t : Bool) => fun (false : motive Bool.false) => fun (true : motive Bool.true) => @Bool.rec motive false true t
def ne_true_of_eq_false.match_1 : (motive : (x : Bool) -> @Eq Bool x Bool.false -> Prop) -> (x : Bool) -> (x1 : @Eq Bool x Bool.false) -> ((h : @Eq Bool Bool.true Bool.false) -> motive Bool.true h) -> ((x2 : @Eq Bool Bool.false Bool.false) -> motive Bool.false x2) -> motive x x1 :=
  fun (motive : (x : Bool) -> @Eq Bool x Bool.false -> Prop) => fun (x : Bool) => fun (x1 : @Eq Bool x Bool.false) => fun (h_1 : (h : @Eq Bool Bool.true Bool.false) -> motive Bool.true h) => fun (h_2 : (x2 : @Eq Bool Bool.false Bool.false) -> motive Bool.false x2) => @Bool.casesOn (fun (x2 : Bool) => (x3 : @Eq Bool x2 Bool.false) -> motive x2 x3) x (fun (x2 : @Eq Bool Bool.false Bool.false) => h_2 x2) (fun (x2 : @Eq Bool Bool.true Bool.false) => h_1 x2) x1
def Bool.noConfusionType : Sort u -> Bool -> Bool -> Sort u :=
  fun (P : Sort u) => fun (v1 : Bool) => fun (v2 : Bool) => @Bool.casesOn (fun (_ : Bool) => Sort u) v1 (@Bool.casesOn (fun (_ : Bool) => Sort u) v2 (P -> P) P) (@Bool.casesOn (fun (_ : Bool) => Sort u) v2 P (P -> P))
def Bool.noConfusion : {P : Sort u} -> {v1 : Bool} -> {v2 : Bool} -> @Eq Bool v1 v2 -> @Bool.noConfusionType P v1 v2 :=
  fun {P : Sort u} => fun {v1 : Bool} => fun {v2 : Bool} => fun (h12 : @Eq Bool v1 v2) => @Eq.ndrec Bool v1 (fun (a : Bool) => @Eq Bool v1 a -> @Bool.noConfusionType P v1 a) (fun (_ : @Eq Bool v1 v1) => @Bool.casesOn (fun {v11 : Bool} => @Bool.noConfusionType P v11 v11) v1 (fun (a : P) => a) (fun (a : P) => a)) v2 h12 h12
theorem ne_true_of_eq_false : {b : Bool} -> @Eq Bool b Bool.false -> @Not (@Eq Bool b Bool.true) :=
  fun (x : Bool) => fun (x1 : @Eq Bool x Bool.false) => @ne_true_of_eq_false.match_1 (fun (x2 : Bool) => fun (_ : @Eq Bool x2 Bool.false) => @Not (@Eq Bool x2 Bool.true)) x x1 (fun (h : @Eq Bool Bool.true Bool.false) => @Bool.noConfusion (@Not (@Eq Bool Bool.true Bool.true)) Bool.true Bool.false h) (fun (_ : @Eq Bool Bool.false Bool.false) => fun (h : @Eq Bool Bool.false Bool.true) => @Bool.noConfusion False Bool.false Bool.true h)
def decide_eq_false.match_1 : {p : Prop} -> (motive : @Decidable p -> @Not p -> Prop) -> (x : @Decidable p) -> (x1 : @Not p) -> ((h₁ : p) -> (h₂ : @Not p) -> motive (@Decidable.isTrue p h₁) h₂) -> ((h : @Not p) -> (x2 : @Not p) -> motive (@Decidable.isFalse p h) x2) -> motive x x1 :=
  fun {p : Prop} => fun (motive : @Decidable p -> @Not p -> Prop) => fun (x : @Decidable p) => fun (x1 : @Not p) => fun (h_1 : (h₁ : p) -> (h₂ : @Not p) -> motive (@Decidable.isTrue p h₁) h₂) => fun (h_2 : (h : @Not p) -> (x2 : @Not p) -> motive (@Decidable.isFalse p h) x2) => @Decidable.casesOn p (fun (x2 : @Decidable p) => motive x2 x1) x (fun (h : @Not p) => h_2 h x1) (fun (h : p) => h_1 h x1)
theorem decide_eq_false : {p : Prop} -> (inst : @Decidable p) -> @Not p -> @Eq Bool (@Decidable.decide p inst) Bool.false :=
  fun {p : Prop} => fun (x : @Decidable p) => fun (x1 : @Not p) => @decide_eq_false.match_1 p (fun (x2 : @Decidable p) => fun (_ : @Not p) => @Eq Bool (@Decidable.decide p x2) Bool.false) x x1 (fun (h₁ : p) => fun (h₂ : @Not p) => @absurd p (@Eq Bool (@Decidable.decide p (@Decidable.isTrue p h₁)) Bool.false) h₁ h₂) (fun (h : @Not p) => fun (_ : @Not p) => @rfl Bool (@Decidable.decide p (@Decidable.isFalse p h)))
theorem of_decide_eq_true : {p : Prop} -> (inst : @Decidable p) -> @Eq Bool (@Decidable.decide p inst) Bool.true -> p :=
  fun {p : Prop} => fun (inst : @Decidable p) => fun (h : @Eq Bool (@Decidable.decide p inst) Bool.true) => @of_decide_eq_true.match_1 p (fun (_ : @Decidable p) => p) inst (fun (h₁ : p) => h₁) (fun (h₁ : @Not p) => @absurd (@Eq Bool (@Decidable.decide p inst) Bool.true) p h (@ne_true_of_eq_false (@Decidable.decide p inst) (@decide_eq_false p inst h₁)))
def instDecidableEqOfIff.match_1 : {p : Prop} -> {q : Prop} -> (motive : @Decidable (@Iff p q) -> Sort u_1) -> (d : @Decidable (@Iff p q)) -> ((h : @Iff p q) -> motive (@Decidable.isTrue (@Iff p q) h)) -> ((h : @Not (@Iff p q)) -> motive (@Decidable.isFalse (@Iff p q) h)) -> motive d :=
  fun {p : Prop} => fun {q : Prop} => fun (motive : @Decidable (@Iff p q) -> Sort u_1) => fun (d : @Decidable (@Iff p q)) => fun (h_1 : (h : @Iff p q) -> motive (@Decidable.isTrue (@Iff p q) h)) => fun (h_2 : (h : @Not (@Iff p q)) -> motive (@Decidable.isFalse (@Iff p q) h)) => @Decidable.casesOn (@Iff p q) (fun (x : @Decidable (@Iff p q)) => motive x) d (fun (h : @Not (@Iff p q)) => h_2 h) (fun (h : @Iff p q) => h_1 h)
theorem instDecidableEqOfIff.proof_1 : {p : Prop} -> {q : Prop} -> @Not (@Iff p q) -> @Eq Prop p q -> False :=
  fun {p : Prop} => fun {q : Prop} => fun (h : @Not (@Iff p q)) => fun (heq : @Eq Prop p q) => h (@Eq.rec Prop p (fun (x : Prop) => fun (_ : @Eq Prop p x) => @Iff p x) (@Iff.rfl p) q heq)
def instDecidableEqOfIff : {p : Prop} -> {q : Prop} -> @Decidable (@Iff p q) -> @Decidable (@Eq Prop p q) :=
  fun {p : Prop} => fun {q : Prop} => fun (d : @Decidable (@Iff p q)) => @instDecidableEqOfIff.match_1 p q (fun (_ : @Decidable (@Iff p q)) => @Decidable (@Eq Prop p q)) d (fun (h : @Iff p q) => @Decidable.isTrue (@Eq Prop p q) (@propext p q h)) (fun (h : @Not (@Iff p q)) => @Decidable.isFalse (@Eq Prop p q) (@instDecidableEqOfIff.proof_1 p q h))
def dite : {α : Sort u} -> (c : Prop) -> @Decidable c -> (c -> α) -> (@Not c -> α) -> α :=
  fun {α : Sort u} => fun (c : Prop) => fun (h : @Decidable c) => fun (t : c -> α) => fun (e : @Not c -> α) => @Decidable.casesOn c (fun (_ : @Decidable c) => α) h e t
theorem instDecidableIff.proof_1 : {p : Prop} -> {q : Prop} -> p -> q -> @Iff p q :=
  fun {p : Prop} => fun {q : Prop} => fun (hp : p) => fun (hq : q) => @Iff.intro p q (fun (_ : p) => hq) (fun (_ : q) => hp)
theorem instDecidableIff.proof_2 : {p : Prop} -> {q : Prop} -> p -> @Not q -> @Iff p q -> False :=
  fun {p : Prop} => fun {q : Prop} => fun (hp : p) => fun (hq : @Not q) => fun (h : @Iff p q) => hq (@Iff.mp p q h hp)
theorem instDecidableIff.proof_3 : {p : Prop} -> {q : Prop} -> @Not p -> q -> @Iff p q -> False :=
  fun {p : Prop} => fun {q : Prop} => fun (hp : @Not p) => fun (hq : q) => fun (h : @Iff p q) => hp (@Iff.mpr p q h hq)
theorem instDecidableIff.proof_4 : {p : Prop} -> {q : Prop} -> @Not p -> @Not q -> @Iff p q :=
  fun {p : Prop} => fun {q : Prop} => fun (hp : @Not p) => fun (hq : @Not q) => @Iff.intro p q (fun (h : p) => @absurd p q h hp) (fun (h : q) => @absurd q p h hq)
def instDecidableIff : {p : Prop} -> {q : Prop} -> @Decidable p -> @Decidable q -> @Decidable (@Iff p q) :=
  fun {p : Prop} => fun {q : Prop} => fun (inst : @Decidable p) => fun (inst1 : @Decidable q) => @dite (@Decidable (@Iff p q)) p inst (fun (hp : p) => @dite (@Decidable (@Iff p q)) q inst1 (fun (hq : q) => @Decidable.isTrue (@Iff p q) (@instDecidableIff.proof_1 p q hp hq)) (fun (hq : @Not q) => @Decidable.isFalse (@Iff p q) (@instDecidableIff.proof_2 p q hp hq))) (fun (hp : @Not p) => @dite (@Decidable (@Iff p q)) q inst1 (fun (hq : q) => @Decidable.isFalse (@Iff p q) (@instDecidableIff.proof_3 p q hp hq)) (fun (hq : @Not q) => @Decidable.isTrue (@Iff p q) (@instDecidableIff.proof_4 p q hp hq)))
def instDecidableAnd.match_1 : {q : Prop} -> (motive : @Decidable q -> Sort u_1) -> (dq : @Decidable q) -> ((hq : q) -> motive (@Decidable.isTrue q hq)) -> ((hq : @Not q) -> motive (@Decidable.isFalse q hq)) -> motive dq :=
  fun {q : Prop} => fun (motive : @Decidable q -> Sort u_1) => fun (dq : @Decidable q) => fun (h_1 : (hq : q) -> motive (@Decidable.isTrue q hq)) => fun (h_2 : (hq : @Not q) -> motive (@Decidable.isFalse q hq)) => @Decidable.casesOn q (fun (x : @Decidable q) => motive x) dq (fun (h : @Not q) => h_2 h) (fun (h : q) => h_1 h)
def instDecidableNot : {p : Prop} -> @Decidable p -> @Decidable (@Not p) :=
  fun {p : Prop} => fun (dp : @Decidable p) => @instDecidableAnd.match_1 p (fun (_ : @Decidable p) => @Decidable (@Not p)) dp (fun (hp : p) => @Decidable.isFalse (@Not p) (@absurd p False hp)) (fun (hp : @Not p) => @Decidable.isTrue (@Not p) hp)
theorem not_true_eq_false : @Eq Prop (@Not True) False :=
  @of_decide_eq_true (@Eq Prop (@Not True) False) (@instDecidableEqOfIff (@Not True) False (@instDecidableIff (@Not True) False (@instDecidableNot True instDecidableTrue) instDecidableFalse)) (@id (@Eq Bool (@Decidable.decide (@Eq Prop (@Not True) False) (@instDecidableEqOfIff (@Not True) False (@instDecidableIff (@Not True) False (@instDecidableNot True instDecidableTrue) instDecidableFalse))) Bool.true) (@Eq.refl Bool Bool.true))
theorem false_and : (p : Prop) -> @Eq Prop (@And False p) False :=
  fun (p : Prop) => @eq_false (@And False p) (fun (x : @And False p) => @And.left False p x)
theorem if_false_left : {p : Prop} -> {q : Prop} -> (h : @Decidable p) -> @Iff (@ite Prop p h False q) (@And (@Not p) q) :=
  fun {p : Prop} => fun {q : Prop} => fun (h : @Decidable p) => @Decidable.casesOn p (fun (t : @Decidable p) => @Eq (@Decidable p) h t -> @Iff (@ite Prop p h False q) (@And (@Not p) q)) h (fun (h1 : @Not p) => fun (h2 : @Eq (@Decidable p) h (@Decidable.isFalse p h1)) => @Eq.ndrec (@Decidable p) (@Decidable.isFalse p h1) (fun (h3 : @Decidable p) => @Iff (@ite Prop p h3 False q) (@And (@Not p) q)) (@of_eq_true (@Iff (@ite Prop p (@Decidable.isFalse p h1) False q) (@And (@Not p) q)) (@Eq.trans Prop (@Iff (@ite Prop p (@Decidable.isFalse p h1) False q) (@And (@Not p) q)) (@Iff q q) True (@congr Prop Prop (@Iff (@ite Prop p (@Decidable.isFalse p h1) False q)) (@Iff q) (@And (@Not p) q) q (@congrArg Prop (Prop -> Prop) (@ite Prop p (@Decidable.isFalse p h1) False q) q Iff (@ite_cond_eq_false Prop p (@Decidable.isFalse p h1) False q (@eq_false p h1))) (@Eq.trans Prop (@And (@Not p) q) (@And True q) q (@congrArg Prop Prop (@Not p) True (fun (x : Prop) => @And x q) (@Eq.trans Prop (@Not p) (@Not False) True (@congrArg Prop Prop p False Not (@eq_false p h1)) not_false_eq_true)) (@true_and q))) (@iff_self q))) h (@Eq.symm (@Decidable p) h (@Decidable.isFalse p h1) h2)) (fun (h1 : p) => fun (h2 : @Eq (@Decidable p) h (@Decidable.isTrue p h1)) => @Eq.ndrec (@Decidable p) (@Decidable.isTrue p h1) (fun (h3 : @Decidable p) => @Iff (@ite Prop p h3 False q) (@And (@Not p) q)) (@of_eq_true (@Iff (@ite Prop p (@Decidable.isTrue p h1) False q) (@And (@Not p) q)) (@Eq.trans Prop (@Iff (@ite Prop p (@Decidable.isTrue p h1) False q) (@And (@Not p) q)) (@Iff False False) True (@congr Prop Prop (@Iff (@ite Prop p (@Decidable.isTrue p h1) False q)) (@Iff False) (@And (@Not p) q) False (@congrArg Prop (Prop -> Prop) (@ite Prop p (@Decidable.isTrue p h1) False q) False Iff (@ite_cond_eq_true Prop p (@Decidable.isTrue p h1) False q (@eq_true p h1))) (@Eq.trans Prop (@And (@Not p) q) (@And False q) False (@congrArg Prop Prop (@Not p) False (fun (x : Prop) => @And x q) (@Eq.trans Prop (@Not p) (@Not True) False (@congrArg Prop Prop p True Not (@eq_true p h1)) not_true_eq_false)) (@false_and q))) (@iff_self False))) h (@Eq.symm (@Decidable p) h (@Decidable.isTrue p h1) h2)) (@Eq.refl (@Decidable p) h)
theorem if_false_right : {p : Prop} -> {q : Prop} -> (h : @Decidable p) -> @Iff (@ite Prop p h q False) (@And p q) :=
  fun {p : Prop} => fun {q : Prop} => fun (h : @Decidable p) => @Decidable.casesOn p (fun (t : @Decidable p) => @Eq (@Decidable p) h t -> @Iff (@ite Prop p h q False) (@And p q)) h (fun (h1 : @Not p) => fun (h2 : @Eq (@Decidable p) h (@Decidable.isFalse p h1)) => @Eq.ndrec (@Decidable p) (@Decidable.isFalse p h1) (fun (h3 : @Decidable p) => @Iff (@ite Prop p h3 q False) (@And p q)) (@of_eq_true (@Iff (@ite Prop p (@Decidable.isFalse p h1) q False) (@And p q)) (@Eq.trans Prop (@Iff (@ite Prop p (@Decidable.isFalse p h1) q False) (@And p q)) (@Iff False False) True (@congr Prop Prop (@Iff (@ite Prop p (@Decidable.isFalse p h1) q False)) (@Iff False) (@And p q) False (@congrArg Prop (Prop -> Prop) (@ite Prop p (@Decidable.isFalse p h1) q False) False Iff (@ite_cond_eq_false Prop p (@Decidable.isFalse p h1) q False (@eq_false p h1))) (@Eq.trans Prop (@And p q) (@And False q) False (@congrArg Prop Prop p False (fun (x : Prop) => @And x q) (@eq_false p h1)) (@false_and q))) (@iff_self False))) h (@Eq.symm (@Decidable p) h (@Decidable.isFalse p h1) h2)) (fun (h1 : p) => fun (h2 : @Eq (@Decidable p) h (@Decidable.isTrue p h1)) => @Eq.ndrec (@Decidable p) (@Decidable.isTrue p h1) (fun (h3 : @Decidable p) => @Iff (@ite Prop p h3 q False) (@And p q)) (@of_eq_true (@Iff (@ite Prop p (@Decidable.isTrue p h1) q False) (@And p q)) (@Eq.trans Prop (@Iff (@ite Prop p (@Decidable.isTrue p h1) q False) (@And p q)) (@Iff q q) True (@congr Prop Prop (@Iff (@ite Prop p (@Decidable.isTrue p h1) q False)) (@Iff q) (@And p q) q (@congrArg Prop (Prop -> Prop) (@ite Prop p (@Decidable.isTrue p h1) q False) q Iff (@ite_cond_eq_true Prop p (@Decidable.isTrue p h1) q False (@eq_true p h1))) (@Eq.trans Prop (@And p q) (@And True q) q (@congrArg Prop Prop p True (fun (x : Prop) => @And x q) (@eq_true p h1)) (@true_and q))) (@iff_self q))) h (@Eq.symm (@Decidable p) h (@Decidable.isTrue p h1) h2)) (@Eq.refl (@Decidable p) h)
theorem implies_congr : {p₁ : Sort u} -> {p₂ : Sort u} -> {q₁ : Sort v} -> {q₂ : Sort v} -> @Eq (Sort u) p₁ p₂ -> @Eq (Sort v) q₁ q₂ -> @Eq (Sort (imax u v)) (p₁ -> q₁) (p₂ -> q₂) :=
  fun {p₁ : Sort u} => fun {p₂ : Sort u} => fun {q₁ : Sort v} => fun {q₂ : Sort v} => fun (h₁ : @Eq (Sort u) p₁ p₂) => fun (h₂ : @Eq (Sort v) q₁ q₂) => @Eq.rec (Sort u) p₁ (fun (x : Sort u) => fun (_ : @Eq (Sort u) p₁ x) => @Eq (Sort (imax u v)) (p₁ -> q₁) (x -> q₂)) (@Eq.rec (Sort v) q₁ (fun (x : Sort v) => fun (_ : @Eq (Sort v) q₁ x) => @Eq (Sort (imax u v)) (p₁ -> q₁) (p₁ -> x)) (@rfl (Sort (imax u v)) (p₁ -> q₁)) q₂ h₂) p₂ h₁
theorem true_implies : (p : Prop) -> @Eq Prop (True -> p) p :=
  fun (p : Prop) => @propext (True -> p) p (@Iff.intro (True -> p) p (fun (x : True -> p) => x trivial) (fun (x : p) => fun (_ : True) => x))
theorem false_implies : (p : Prop) -> @Eq Prop (False -> p) True :=
  fun (p : Prop) => @eq_true (False -> p) (@False.elim p)
theorem if_true_left : {p : Prop} -> {q : Prop} -> (h : @Decidable p) -> @Iff (@ite Prop p h True q) (@Not p -> q) :=
  fun {p : Prop} => fun {q : Prop} => fun (h : @Decidable p) => @Decidable.casesOn p (fun (t : @Decidable p) => @Eq (@Decidable p) h t -> @Iff (@ite Prop p h True q) (@Not p -> q)) h (fun (h1 : @Not p) => fun (h2 : @Eq (@Decidable p) h (@Decidable.isFalse p h1)) => @Eq.ndrec (@Decidable p) (@Decidable.isFalse p h1) (fun (h3 : @Decidable p) => @Iff (@ite Prop p h3 True q) (@Not p -> q)) (@of_eq_true (@Iff (@ite Prop p (@Decidable.isFalse p h1) True q) (@Not p -> q)) (@Eq.trans Prop (@Iff (@ite Prop p (@Decidable.isFalse p h1) True q) (@Not p -> q)) (@Iff q q) True (@congr Prop Prop (@Iff (@ite Prop p (@Decidable.isFalse p h1) True q)) (@Iff q) (@Not p -> q) q (@congrArg Prop (Prop -> Prop) (@ite Prop p (@Decidable.isFalse p h1) True q) q Iff (@ite_cond_eq_false Prop p (@Decidable.isFalse p h1) True q (@eq_false p h1))) (@Eq.trans Prop (@Not p -> q) (True -> q) q (@implies_congr (@Not p) True q q (@Eq.trans Prop (@Not p) (@Not False) True (@congrArg Prop Prop p False Not (@eq_false p h1)) not_false_eq_true) (@Eq.refl Prop q)) (@true_implies q))) (@iff_self q))) h (@Eq.symm (@Decidable p) h (@Decidable.isFalse p h1) h2)) (fun (h1 : p) => fun (h2 : @Eq (@Decidable p) h (@Decidable.isTrue p h1)) => @Eq.ndrec (@Decidable p) (@Decidable.isTrue p h1) (fun (h3 : @Decidable p) => @Iff (@ite Prop p h3 True q) (@Not p -> q)) (@of_eq_true (@Iff (@ite Prop p (@Decidable.isTrue p h1) True q) (@Not p -> q)) (@Eq.trans Prop (@Iff (@ite Prop p (@Decidable.isTrue p h1) True q) (@Not p -> q)) (@Iff True True) True (@congr Prop Prop (@Iff (@ite Prop p (@Decidable.isTrue p h1) True q)) (@Iff True) (@Not p -> q) True (@congrArg Prop (Prop -> Prop) (@ite Prop p (@Decidable.isTrue p h1) True q) True Iff (@ite_cond_eq_true Prop p (@Decidable.isTrue p h1) True q (@eq_true p h1))) (@Eq.trans Prop (@Not p -> q) (False -> q) True (@implies_congr (@Not p) False q q (@Eq.trans Prop (@Not p) (@Not True) False (@congrArg Prop Prop p True Not (@eq_true p h1)) not_true_eq_false) (@Eq.refl Prop q)) (@false_implies q))) (@iff_self True))) h (@Eq.symm (@Decidable p) h (@Decidable.isTrue p h1) h2)) (@Eq.refl (@Decidable p) h)
theorem if_true_right : {p : Prop} -> {q : Prop} -> (h : @Decidable p) -> @Iff (@ite Prop p h q True) (p -> q) :=
  fun {p : Prop} => fun {q : Prop} => fun (h : @Decidable p) => @Decidable.casesOn p (fun (t : @Decidable p) => @Eq (@Decidable p) h t -> @Iff (@ite Prop p h q True) (p -> q)) h (fun (h1 : @Not p) => fun (h2 : @Eq (@Decidable p) h (@Decidable.isFalse p h1)) => @Eq.ndrec (@Decidable p) (@Decidable.isFalse p h1) (fun (h3 : @Decidable p) => @Iff (@ite Prop p h3 q True) (p -> q)) (@of_eq_true (@Iff (@ite Prop p (@Decidable.isFalse p h1) q True) (p -> q)) (@Eq.trans Prop (@Iff (@ite Prop p (@Decidable.isFalse p h1) q True) (p -> q)) (@Iff True True) True (@congr Prop Prop (@Iff (@ite Prop p (@Decidable.isFalse p h1) q True)) (@Iff True) (p -> q) True (@congrArg Prop (Prop -> Prop) (@ite Prop p (@Decidable.isFalse p h1) q True) True Iff (@ite_cond_eq_false Prop p (@Decidable.isFalse p h1) q True (@eq_false p h1))) (@Eq.trans Prop (p -> q) (False -> q) True (@implies_congr p False q q (@eq_false p h1) (@Eq.refl Prop q)) (@false_implies q))) (@iff_self True))) h (@Eq.symm (@Decidable p) h (@Decidable.isFalse p h1) h2)) (fun (h1 : p) => fun (h2 : @Eq (@Decidable p) h (@Decidable.isTrue p h1)) => @Eq.ndrec (@Decidable p) (@Decidable.isTrue p h1) (fun (h3 : @Decidable p) => @Iff (@ite Prop p h3 q True) (p -> q)) (@of_eq_true (@Iff (@ite Prop p (@Decidable.isTrue p h1) q True) (p -> q)) (@Eq.trans Prop (@Iff (@ite Prop p (@Decidable.isTrue p h1) q True) (p -> q)) (@Iff q q) True (@congr Prop Prop (@Iff (@ite Prop p (@Decidable.isTrue p h1) q True)) (@Iff q) (p -> q) q (@congrArg Prop (Prop -> Prop) (@ite Prop p (@Decidable.isTrue p h1) q True) q Iff (@ite_cond_eq_true Prop p (@Decidable.isTrue p h1) q True (@eq_true p h1))) (@Eq.trans Prop (p -> q) (True -> q) q (@implies_congr p True q q (@eq_true p h1) (@Eq.refl Prop q)) (@true_implies q))) (@iff_self q))) h (@Eq.symm (@Decidable p) h (@Decidable.isTrue p h1) h2)) (@Eq.refl (@Decidable p) h)
theorem ite_then_self : {p : Prop} -> {q : Prop} -> (h : @Decidable p) -> @Iff (@ite Prop p h p q) (@Not p -> q) :=
  fun {p : Prop} => fun {q : Prop} => fun (h : @Decidable p) => @Decidable.casesOn p (fun (t : @Decidable p) => @Eq (@Decidable p) h t -> @Iff (@ite Prop p h p q) (@Not p -> q)) h (fun (h1 : @Not p) => fun (h2 : @Eq (@Decidable p) h (@Decidable.isFalse p h1)) => @Eq.ndrec (@Decidable p) (@Decidable.isFalse p h1) (fun (h3 : @Decidable p) => @Iff (@ite Prop p h3 p q) (@Not p -> q)) (@of_eq_true (@Iff (@ite Prop p (@Decidable.isFalse p h1) p q) (@Not p -> q)) (@Eq.trans Prop (@Iff (@ite Prop p (@Decidable.isFalse p h1) p q) (@Not p -> q)) (@Iff q q) True (@congr Prop Prop (@Iff (@ite Prop p (@Decidable.isFalse p h1) p q)) (@Iff q) (@Not p -> q) q (@congrArg Prop (Prop -> Prop) (@ite Prop p (@Decidable.isFalse p h1) p q) q Iff (@ite_cond_eq_false Prop p (@Decidable.isFalse p h1) p q (@eq_false p h1))) (@Eq.trans Prop (@Not p -> q) (True -> q) q (@implies_congr (@Not p) True q q (@Eq.trans Prop (@Not p) (@Not False) True (@congrArg Prop Prop p False Not (@eq_false p h1)) not_false_eq_true) (@Eq.refl Prop q)) (@true_implies q))) (@iff_self q))) h (@Eq.symm (@Decidable p) h (@Decidable.isFalse p h1) h2)) (fun (h1 : p) => fun (h2 : @Eq (@Decidable p) h (@Decidable.isTrue p h1)) => @Eq.ndrec (@Decidable p) (@Decidable.isTrue p h1) (fun (h3 : @Decidable p) => @Iff (@ite Prop p h3 p q) (@Not p -> q)) (@of_eq_true (@Iff (@ite Prop p (@Decidable.isTrue p h1) p q) (@Not p -> q)) (@Eq.trans Prop (@Iff (@ite Prop p (@Decidable.isTrue p h1) p q) (@Not p -> q)) (@Iff True True) True (@congr Prop Prop (@Iff (@ite Prop p (@Decidable.isTrue p h1) p q)) (@Iff True) (@Not p -> q) True (@congrArg Prop (Prop -> Prop) (@ite Prop p (@Decidable.isTrue p h1) p q) True Iff (@Eq.trans Prop (@ite Prop p (@Decidable.isTrue p h1) p q) p True (@ite_cond_eq_true Prop p (@Decidable.isTrue p h1) p q (@eq_true p h1)) (@eq_true p h1))) (@Eq.trans Prop (@Not p -> q) (False -> q) True (@implies_congr (@Not p) False q q (@Eq.trans Prop (@Not p) (@Not True) False (@congrArg Prop Prop p True Not (@eq_true p h1)) not_true_eq_false) (@Eq.refl Prop q)) (@false_implies q))) (@iff_self True))) h (@Eq.symm (@Decidable p) h (@Decidable.isTrue p h1) h2)) (@Eq.refl (@Decidable p) h)
theorem ite_true_same : {p : Prop} -> {q : Prop} -> (inst : @Decidable p) -> @Iff (@ite Prop p inst p q) (@Not p -> q) :=
  fun {p : Prop} => fun {q : Prop} => fun (inst : @Decidable p) => @ite_then_self p q inst
theorem ite_else_self : {p : Prop} -> {q : Prop} -> (h : @Decidable p) -> @Iff (@ite Prop p h q p) (@And p q) :=
  fun {p : Prop} => fun {q : Prop} => fun (h : @Decidable p) => @Decidable.casesOn p (fun (t : @Decidable p) => @Eq (@Decidable p) h t -> @Iff (@ite Prop p h q p) (@And p q)) h (fun (h1 : @Not p) => fun (h2 : @Eq (@Decidable p) h (@Decidable.isFalse p h1)) => @Eq.ndrec (@Decidable p) (@Decidable.isFalse p h1) (fun (h3 : @Decidable p) => @Iff (@ite Prop p h3 q p) (@And p q)) (@of_eq_true (@Iff (@ite Prop p (@Decidable.isFalse p h1) q p) (@And p q)) (@Eq.trans Prop (@Iff (@ite Prop p (@Decidable.isFalse p h1) q p) (@And p q)) (@Iff False False) True (@congr Prop Prop (@Iff (@ite Prop p (@Decidable.isFalse p h1) q p)) (@Iff False) (@And p q) False (@congrArg Prop (Prop -> Prop) (@ite Prop p (@Decidable.isFalse p h1) q p) False Iff (@Eq.trans Prop (@ite Prop p (@Decidable.isFalse p h1) q p) p False (@ite_cond_eq_false Prop p (@Decidable.isFalse p h1) q p (@eq_false p h1)) (@eq_false p h1))) (@Eq.trans Prop (@And p q) (@And False q) False (@congrArg Prop Prop p False (fun (x : Prop) => @And x q) (@eq_false p h1)) (@false_and q))) (@iff_self False))) h (@Eq.symm (@Decidable p) h (@Decidable.isFalse p h1) h2)) (fun (h1 : p) => fun (h2 : @Eq (@Decidable p) h (@Decidable.isTrue p h1)) => @Eq.ndrec (@Decidable p) (@Decidable.isTrue p h1) (fun (h3 : @Decidable p) => @Iff (@ite Prop p h3 q p) (@And p q)) (@of_eq_true (@Iff (@ite Prop p (@Decidable.isTrue p h1) q p) (@And p q)) (@Eq.trans Prop (@Iff (@ite Prop p (@Decidable.isTrue p h1) q p) (@And p q)) (@Iff q q) True (@congr Prop Prop (@Iff (@ite Prop p (@Decidable.isTrue p h1) q p)) (@Iff q) (@And p q) q (@congrArg Prop (Prop -> Prop) (@ite Prop p (@Decidable.isTrue p h1) q p) q Iff (@ite_cond_eq_true Prop p (@Decidable.isTrue p h1) q p (@eq_true p h1))) (@Eq.trans Prop (@And p q) (@And True q) q (@congrArg Prop Prop p True (fun (x : Prop) => @And x q) (@eq_true p h1)) (@true_and q))) (@iff_self q))) h (@Eq.symm (@Decidable p) h (@Decidable.isTrue p h1) h2)) (@Eq.refl (@Decidable p) h)
theorem ite_false_same : {p : Prop} -> {q : Prop} -> (inst : @Decidable p) -> @Iff (@ite Prop p inst q p) (@And p q) :=
  fun {p : Prop} => fun {q : Prop} => fun (inst : @Decidable p) => @ite_else_self p q inst
theorem forall_imp : {α : Sort u_1} -> {p : α -> Prop} -> {q : α -> Prop} -> ((a : α) -> p a -> q a) -> ((a : α) -> p a) -> (a1 : α) -> q a1 :=
  fun {α : Sort u_1} => fun {p : α -> Prop} => fun {q : α -> Prop} => fun (h : (a : α) -> p a -> q a) => fun (h' : (a : α) -> p a) => fun (a : α) => h a (h' a)
inductive Exists : {α : Sort u} -> (α -> Prop) -> Prop where
  | intro : {α : Sort u} -> {p : α -> Prop} -> (w : α) -> p w -> @Exists α p
-- ctor Exists.intro : {α : Sort u} -> {p : α -> Prop} -> (w : α) -> p w -> @Exists α p
-- recursor Exists.rec : {α : Sort u} -> {p : α -> Prop} -> {motive : @Exists α p -> Prop} -> ((w : α) -> (h : p w) -> motive (@Exists.intro α p w h)) -> (t : @Exists α p) -> motive t
-- def Exists.casesOn : {α : Sort u} -> {p : α -> Prop} -> {motive : @Exists α p -> Prop} -> (t : @Exists α p) -> ((w : α) -> (h : p w) -> motive (@Exists.intro α p w h)) -> motive t :=
--  fun {α : Sort u} => fun {p : α -> Prop} => fun {motive : @Exists α p -> Prop} => fun (t : @Exists α p) => fun (intro : (w : α) -> (h : p w) -> motive (@Exists.intro α p w h)) => @Exists.rec α p motive (fun (w : α) => fun (h : p w) => intro w h) t
def forall_exists_index.match_1 : {α : Sort u_1} -> {p : α -> Prop} -> (motive : @Exists α (fun (x : α) => p x) -> Prop) -> (x : @Exists α (fun (x : α) => p x)) -> ((x1 : α) -> (hpx : p x1) -> motive (@Exists.intro α (fun (x2 : α) => p x2) x1 hpx)) -> motive x :=
  fun {α : Sort u_1} => fun {p : α -> Prop} => fun (motive : @Exists α (fun (x : α) => p x) -> Prop) => fun (x : @Exists α (fun (x : α) => p x)) => fun (h_1 : (x1 : α) -> (hpx : p x1) -> motive (@Exists.intro α (fun (x2 : α) => p x2) x1 hpx)) => @Exists.casesOn α (fun (x1 : α) => p x1) (fun (x1 : @Exists α (fun (x1 : α) => p x1)) => motive x1) x (fun (w : α) => fun (h : p w) => h_1 w h)
theorem Exists.imp : {α : Sort u_1} -> {p : α -> Prop} -> {q : α -> Prop} -> ((a : α) -> p a -> q a) -> @Exists α (fun (a : α) => p a) -> @Exists α (fun (a1 : α) => q a1) :=
  fun {α : Sort u_1} => fun {p : α -> Prop} => fun {q : α -> Prop} => fun (h : (a : α) -> p a -> q a) => fun (x : @Exists α (fun (a : α) => p a)) => @forall_exists_index.match_1 α p (fun (_ : @Exists α (fun (a : α) => p a)) => @Exists α (fun (a : α) => q a)) x (fun (a : α) => fun (hp : p a) => @Exists.intro α (fun (a1 : α) => q a1) a (h a hp))
theorem Exists.imp' : {α : Sort u_2} -> {p : α -> Prop} -> {β : Sort u_1} -> {q : β -> Prop} -> (f : α -> β) -> ((a : α) -> p a -> q (f a)) -> @Exists α (fun (a : α) => p a) -> @Exists β (fun (b : β) => q b) :=
  fun {α : Sort u_2} => fun {p : α -> Prop} => fun {β : Sort u_1} => fun {q : β -> Prop} => fun (f : α -> β) => fun (hpq : (a : α) -> p a -> q (f a)) => fun (x : @Exists α (fun (a : α) => p a)) => @forall_exists_index.match_1 α p (fun (_ : @Exists α (fun (a : α) => p a)) => @Exists β (fun (b : β) => q b)) x (fun (w : α) => fun (hp : p w) => @Exists.intro β (fun (b : β) => q b) (f w) (hpq w hp))
theorem forall_exists_index : {α : Sort u_1} -> {p : α -> Prop} -> {q : @Exists α (fun (x : α) => p x) -> Prop} -> @Iff ((h : @Exists α (fun (x : α) => p x)) -> q h) ((x : α) -> (h : p x) -> q (@Exists.intro α (fun (x1 : α) => p x1) x h)) :=
  fun {α : Sort u_1} => fun {p : α -> Prop} => fun {q : @Exists α (fun (x : α) => p x) -> Prop} => @Iff.intro ((h : @Exists α (fun (x : α) => p x)) -> q h) ((x : α) -> (h : p x) -> q (@Exists.intro α (fun (x1 : α) => p x1) x h)) (fun (h : (h : @Exists α (fun (x : α) => p x)) -> q h) => fun (x : α) => fun (hpx : p x) => h (@Exists.intro α (fun (x1 : α) => p x1) x hpx)) (fun (h : (x : α) -> (h : p x) -> q (@Exists.intro α (fun (x1 : α) => p x1) x h)) => fun (x : @Exists α (fun (x : α) => p x)) => @forall_exists_index.match_1 α p (fun (x1 : @Exists α (fun (x1 : α) => p x1)) => q x1) x (fun (x1 : α) => fun (hpx : p x1) => h x1 hpx))
theorem exists_imp : {α : Sort u_1} -> {p : α -> Prop} -> {b : Prop} -> @Iff (@Exists α (fun (x : α) => p x) -> b) ((x : α) -> p x -> b) :=
  fun {α : Sort u_1} => fun {p : α -> Prop} => fun {b : Prop} => @forall_exists_index α p (fun (_ : @Exists α (fun (x : α) => p x)) => b)
theorem Init.PropLemmas._auxLemma_15 : {α : Sort u_1} -> {p : α -> Prop} -> {q : @Exists α (fun (x : α) => p x) -> Prop} -> @Eq Prop ((h : @Exists α (fun (x : α) => p x)) -> q h) ((x : α) -> (h : p x) -> q (@Exists.intro α (fun (x1 : α) => p x1) x h)) :=
  fun {α : Sort u_1} => fun {p : α -> Prop} => fun {q : @Exists α (fun (x : α) => p x) -> Prop} => @propext ((h : @Exists α (fun (x : α) => p x)) -> q h) ((x : α) -> (h : p x) -> q (@Exists.intro α (fun (x1 : α) => p x1) x h)) (@forall_exists_index α p q)
axiom Quot : {α : Sort u} -> (α -> α -> Prop) -> Sort u
axiom Quot.lift : {α : Sort u} -> {r : α -> α -> Prop} -> {β : Sort v} -> (f : α -> β) -> ((a : α) -> (b : α) -> r a b -> @Eq β (f a) (f b)) -> @Quot α r -> β
def Quot.liftOn : {α : Sort u} -> {β : Sort v} -> {r : α -> α -> Prop} -> @Quot α r -> (f : α -> β) -> ((a : α) -> (b : α) -> r a b -> @Eq β (f a) (f b)) -> β :=
  fun {α : Sort u} => fun {β : Sort v} => fun {r : α -> α -> Prop} => fun (q : @Quot α r) => fun (f : α -> β) => fun (c : (a : α) -> (b : α) -> r a b -> @Eq β (f a) (f b)) => @Quot.lift α r β f c q
def letFun : {α : Sort u} -> {β : α -> Sort v} -> (v : α) -> ((x : α) -> β x) -> β v :=
  fun {α : Sort u} => fun {β : α -> Sort v} => fun (v : α) => fun (f : (x : α) -> β x) => f v
axiom Quot.mk : {α : Sort u} -> (r : α -> α -> Prop) -> α -> @Quot α r
axiom Quot.sound : {α : Sort u} -> {r : α -> α -> Prop} -> {a : α} -> {b : α} -> r a b -> @Eq (@Quot α r) (@Quot.mk α r a) (@Quot.mk α r b)
theorem funext : {α : Sort u} -> {β : α -> Sort v} -> {f : (x : α) -> β x} -> {g : (x : α) -> β x} -> ((x : α) -> @Eq (β x) (f x) (g x)) -> @Eq ((x : α) -> β x) f g :=
  fun {α : Sort u} => fun {β : α -> Sort v} => fun {f : (x : α) -> β x} => fun {g : (x : α) -> β x} => fun (h : (x : α) -> @Eq (β x) (f x) (g x)) => (let eqv := fun (f1 : (x : α) -> β x) => fun (g1 : (x : α) -> β x) => (x : α) -> @Eq (β x) (f1 x) (g1 x) ; (let extfunApp := fun (f1 : @Quot ((x : α) -> β x) eqv) => fun (x : α) => @Quot.liftOn ((x1 : α) -> β x1) (β x) eqv f1 (fun (f2 : (x1 : α) -> β x1) => f2 x) (fun (x1 : (x1 : α) -> β x1) => fun (x2 : (x2 : α) -> β x2) => fun (h1 : eqv x1 x2) => h1 x) ; @letFun (@Eq ((x : α) -> β x) (extfunApp (@Quot.mk ((x : α) -> β x) eqv f)) (extfunApp (@Quot.mk ((x : α) -> β x) eqv g))) (fun (_ : @Eq ((x : α) -> β x) (extfunApp (@Quot.mk ((x : α) -> β x) eqv f)) (extfunApp (@Quot.mk ((x : α) -> β x) eqv g))) => @Eq ((x : α) -> β x) (extfunApp (@Quot.mk ((x : α) -> β x) eqv f)) (extfunApp (@Quot.mk ((x : α) -> β x) eqv g))) (@congrArg (@Quot ((x : α) -> β x) eqv) ((x : α) -> β x) (@Quot.mk ((x : α) -> β x) eqv f) (@Quot.mk ((x : α) -> β x) eqv g) extfunApp (@Quot.sound ((x : α) -> β x) eqv f g h)) (fun (this : @Eq ((x : α) -> β x) (extfunApp (@Quot.mk ((x : α) -> β x) eqv f)) (extfunApp (@Quot.mk ((x : α) -> β x) eqv g))) => this)))
theorem forall_congr : {α : Sort u} -> {p : α -> Prop} -> {q : α -> Prop} -> ((a : α) -> @Eq Prop (p a) (q a)) -> @Eq Prop ((a : α) -> p a) ((a : α) -> q a) :=
  fun {α : Sort u} => fun {p : α -> Prop} => fun {q : α -> Prop} => fun (h : (a : α) -> @Eq Prop (p a) (q a)) => @Eq.rec (α -> Prop) p (fun (x : α -> Prop) => fun (_ : @Eq (α -> Prop) p x) => @Eq Prop ((a : α) -> p a) ((a : α) -> x a)) (@rfl Prop ((a : α) -> p a)) q (@funext α (fun (_ : α) => Prop) p q h)
theorem exists₂_imp : {α : Sort u_1} -> {p : α -> Prop} -> {b : Prop} -> {P : (x : α) -> p x -> Prop} -> @Iff (@Exists α (fun (x : α) => @Exists (p x) (fun (h : p x) => P x h)) -> b) ((x : α) -> (h : p x) -> P x h -> b) :=
  fun {α : Sort u_1} => fun {p : α -> Prop} => fun {b : Prop} => fun {P : (x : α) -> p x -> Prop} => @of_eq_true (@Iff (@Exists α (fun (x : α) => @Exists (p x) (fun (h : p x) => P x h)) -> b) ((x : α) -> (x1 : p x) -> P x x1 -> b)) (@Eq.trans Prop (@Iff (@Exists α (fun (x : α) => @Exists (p x) (fun (h : p x) => P x h)) -> b) ((x : α) -> (x1 : p x) -> P x x1 -> b)) (@Iff ((a : α) -> (x : p a) -> P a x -> b) ((x : α) -> (x1 : p x) -> P x x1 -> b)) True (@congrArg Prop Prop (@Exists α (fun (x : α) => @Exists (p x) (fun (h : p x) => P x h)) -> b) ((a : α) -> (x : p a) -> P a x -> b) (fun (x : Prop) => @Iff x ((x1 : α) -> (x2 : p x1) -> P x1 x2 -> b)) (@Eq.trans Prop (@Exists α (fun (x : α) => @Exists (p x) (fun (h : p x) => P x h)) -> b) ((x : α) -> @Exists (p x) (fun (h : p x) => P x h) -> b) ((a : α) -> (x : p a) -> P a x -> b) (@Init.PropLemmas._auxLemma_15 α (fun (x : α) => @Exists (p x) (fun (h : p x) => P x h)) (fun (_ : @Exists α (fun (x : α) => @Exists (p x) (fun (h : p x) => P x h))) => b)) (@forall_congr α (fun (a : α) => @Exists (p a) (fun (x : p a) => P a x) -> b) (fun (a : α) => (x : p a) -> P a x -> b) (fun (x : α) => @Init.PropLemmas._auxLemma_15 (p x) (P x) (fun (_ : @Exists (p x) (fun (x1 : p x) => P x x1)) => b))))) (@iff_self ((x : α) -> (x1 : p x) -> P x x1 -> b)))
def exists_prop_congr.match_1 : {p : Prop} -> {q : p -> Prop} -> (motive : @Exists p q -> Prop) -> (x : @Exists p q) -> ((w : p) -> (h : q w) -> motive (@Exists.intro p q w h)) -> motive x :=
  fun {p : Prop} => fun {q : p -> Prop} => fun (motive : @Exists p q -> Prop) => fun (x : @Exists p q) => fun (h_1 : (w : p) -> (h : q w) -> motive (@Exists.intro p q w h)) => @Exists.casesOn p q (fun (x1 : @Exists p q) => motive x1) x (fun (w : p) => fun (h : q w) => h_1 w h)
def exists_prop_congr.match_2 : {p : Prop} -> {p' : Prop} -> {q' : p -> Prop} -> (hp : @Iff p p') -> (motive : @Exists p' (fun (h : p') => q' (@Iff.mpr p p' hp h)) -> Prop) -> (x : @Exists p' (fun (h : p') => q' (@Iff.mpr p p' hp h))) -> ((w : p') -> (h : q' (@Iff.mpr p p' hp w)) -> motive (@Exists.intro p' (fun (h1 : p') => q' (@Iff.mpr p p' hp h1)) w h)) -> motive x :=
  fun {p : Prop} => fun {p' : Prop} => fun {q' : p -> Prop} => fun (hp : @Iff p p') => fun (motive : @Exists p' (fun (h : p') => q' (@Iff.mpr p p' hp h)) -> Prop) => fun (x : @Exists p' (fun (h : p') => q' (@Iff.mpr p p' hp h))) => fun (h_1 : (w : p') -> (h : q' (@Iff.mpr p p' hp w)) -> motive (@Exists.intro p' (fun (h1 : p') => q' (@Iff.mpr p p' hp h1)) w h)) => @Exists.casesOn p' (fun (h : p') => q' (@Iff.mpr p p' hp h)) (fun (x1 : @Exists p' (fun (h : p') => q' (@Iff.mpr p p' hp h))) => motive x1) x (fun (w : p') => fun (h : q' (@Iff.mpr p p' hp w)) => h_1 w h)
theorem exists_prop_congr : {p : Prop} -> {p' : Prop} -> {q : p -> Prop} -> {q' : p -> Prop} -> ((h : p) -> @Iff (q h) (q' h)) -> (hp : @Iff p p') -> @Iff (@Exists p q) (@Exists p' (fun (h : p') => q' (@Iff.mpr p p' hp h))) :=
  fun {p : Prop} => fun {p' : Prop} => fun {q : p -> Prop} => fun {q' : p -> Prop} => fun (hq : (h : p) -> @Iff (q h) (q' h)) => fun (hp : @Iff p p') => @Iff.intro (@Exists p q) (@Exists p' (fun (h : p') => q' (@Iff.mpr p p' hp h))) (fun (x : @Exists p q) => @exists_prop_congr.match_1 p q (fun (_ : @Exists p q) => @Exists p' (fun (h : p') => q' (@Iff.mpr p p' hp h))) x (fun (w : p) => fun (h : q w) => @Exists.intro p' (fun (h1 : p') => q' (@Iff.mpr p p' hp h1)) (@Iff.mp p p' hp w) (@Iff.mp (q (@Iff.mpr p p' hp (@Iff.mp p p' hp w))) (q' (@Iff.mpr p p' hp (@Iff.mp p p' hp w))) (hq (@Iff.mpr p p' hp (@Iff.mp p p' hp w))) h))) (fun (x : @Exists p' (fun (h : p') => q' (@Iff.mpr p p' hp h))) => @exists_prop_congr.match_2 p p' q' hp (fun (_ : @Exists p' (fun (h : p') => q' (@Iff.mpr p p' hp h))) => @Exists p q) x (fun (w : p') => fun (h : q' (@Iff.mpr p p' hp w)) => @Exists.intro p q (@Iff.mpr p p' hp w) (@Iff.mpr (q (@Iff.mpr p p' hp w)) (q' (@Iff.mpr p p' hp w)) (hq (@Iff.mpr p p' hp w)) h)))
inductive Nonempty : Sort u -> Prop where
  | intro : {α : Sort u} -> α -> @Nonempty α
def exists_const.match_1 : {b : Prop} -> (α : Sort u_1) -> (motive : @Exists α (fun (_ : α) => b) -> Prop) -> (x : @Exists α (fun (_ : α) => b)) -> ((w : α) -> (h : b) -> motive (@Exists.intro α (fun (_ : α) => b) w h)) -> motive x :=
  fun {b : Prop} => fun (α : Sort u_1) => fun (motive : @Exists α (fun (_ : α) => b) -> Prop) => fun (x : @Exists α (fun (_ : α) => b)) => fun (h_1 : (w : α) -> (h : b) -> motive (@Exists.intro α (fun (_ : α) => b) w h)) => @Exists.casesOn α (fun (_ : α) => b) (fun (x1 : @Exists α (fun (_ : α) => b)) => motive x1) x (fun (w : α) => fun (h : b) => h_1 w h)
-- ctor Nonempty.intro : {α : Sort u} -> α -> @Nonempty α
-- recursor Nonempty.rec : {α : Sort u} -> {motive : @Nonempty α -> Prop} -> ((val : α) -> motive (@Nonempty.intro α val)) -> (t : @Nonempty α) -> motive t
-- def Nonempty.casesOn : {α : Sort u} -> {motive : @Nonempty α -> Prop} -> (t : @Nonempty α) -> ((val : α) -> motive (@Nonempty.intro α val)) -> motive t :=
--  fun {α : Sort u} => fun {motive : @Nonempty α -> Prop} => fun (t : @Nonempty α) => fun (intro : (val : α) -> motive (@Nonempty.intro α val)) => @Nonempty.rec α motive (fun (val : α) => intro val) t
def Nonempty.elim.match_1 : {α : Sort u_1} -> (motive : @Nonempty α -> Prop) -> (h₁ : @Nonempty α) -> ((a : α) -> motive (@Nonempty.intro α a)) -> motive h₁ :=
  fun {α : Sort u_1} => fun (motive : @Nonempty α -> Prop) => fun (h₁ : @Nonempty α) => fun (h_1 : (a : α) -> motive (@Nonempty.intro α a)) => @Nonempty.casesOn α (fun (x : @Nonempty α) => motive x) h₁ (fun (val : α) => h_1 val)
theorem Nonempty.elim : {α : Sort u} -> {p : Prop} -> @Nonempty α -> (α -> p) -> p :=
  fun {α : Sort u} => fun {p : Prop} => fun (h₁ : @Nonempty α) => fun (h₂ : α -> p) => @Nonempty.elim.match_1 α (fun (_ : @Nonempty α) => p) h₁ (fun (a : α) => h₂ a)
theorem exists_const : {b : Prop} -> (α : Sort u_1) -> @Nonempty α -> @Iff (@Exists α (fun (_ : α) => b)) b :=
  fun {b : Prop} => fun (α : Sort u_1) => fun (i : @Nonempty α) => @Iff.intro (@Exists α (fun (_ : α) => b)) b (fun (x : @Exists α (fun (_ : α) => b)) => @exists_const.match_1 b α (fun (_ : @Exists α (fun (_ : α) => b)) => b) x (fun (_ : α) => fun (h : b) => h)) (@Nonempty.elim α (b -> @Exists α (fun (_ : α) => b)) i (@Exists.intro α (fun (_ : α) => b)))
theorem exists_prop_of_true : {p : Prop} -> {q : p -> Prop} -> (h : p) -> @Iff (@Exists p (fun (h' : p) => q h')) (q h) :=
  fun {p : Prop} => fun {q : p -> Prop} => fun (h : p) => @exists_const (q h) p (@Nonempty.intro p h)
theorem forall_congr' : {α : Sort u_1} -> {p : α -> Prop} -> {q : α -> Prop} -> ((a : α) -> @Iff (p a) (q a)) -> @Iff ((a : α) -> p a) ((a : α) -> q a) :=
  fun {α : Sort u_1} => fun {p : α -> Prop} => fun {q : α -> Prop} => fun (h : (a : α) -> @Iff (p a) (q a)) => @Iff.intro ((a : α) -> p a) ((a : α) -> q a) (fun (H : (a : α) -> p a) => fun (a : α) => @Iff.mp (p a) (q a) (h a) (H a)) (fun (H : (a : α) -> q a) => fun (a : α) => @Iff.mpr (p a) (q a) (h a) (H a))
theorem exists_congr : {α : Sort u_1} -> {p : α -> Prop} -> {q : α -> Prop} -> ((a : α) -> @Iff (p a) (q a)) -> @Iff (@Exists α (fun (a : α) => p a)) (@Exists α (fun (a : α) => q a)) :=
  fun {α : Sort u_1} => fun {p : α -> Prop} => fun {q : α -> Prop} => fun (h : (a : α) -> @Iff (p a) (q a)) => @Iff.intro (@Exists α (fun (a : α) => p a)) (@Exists α (fun (a : α) => q a)) (@Exists.imp α p q (fun (x : α) => @Iff.mp (p x) (q x) (h x))) (@Exists.imp α q p (fun (x : α) => @Iff.mpr (p x) (q x) (h x)))
theorem forall₂_congr : {α : Sort u_1} -> {β : α -> Sort u_2} -> {p : (a : α) -> β a -> Prop} -> {q : (a : α) -> β a -> Prop} -> ((a : α) -> (b : β a) -> @Iff (p a b) (q a b)) -> @Iff ((a : α) -> (b : β a) -> p a b) ((a : α) -> (b : β a) -> q a b) :=
  fun {α : Sort u_1} => fun {β : α -> Sort u_2} => fun {p : (a : α) -> β a -> Prop} => fun {q : (a : α) -> β a -> Prop} => fun (h : (a : α) -> (b : β a) -> @Iff (p a b) (q a b)) => @forall_congr' α (fun (a : α) => (b : β a) -> p a b) (fun (a : α) => (b : β a) -> q a b) (fun (a : α) => @forall_congr' (β a) (p a) (q a) (h a))
theorem exists₂_congr : {α : Sort u_1} -> {β : α -> Sort u_2} -> {p : (a : α) -> β a -> Prop} -> {q : (a : α) -> β a -> Prop} -> ((a : α) -> (b : β a) -> @Iff (p a b) (q a b)) -> @Iff (@Exists α (fun (a : α) => @Exists (β a) (fun (b : β a) => p a b))) (@Exists α (fun (a : α) => @Exists (β a) (fun (b : β a) => q a b))) :=
  fun {α : Sort u_1} => fun {β : α -> Sort u_2} => fun {p : (a : α) -> β a -> Prop} => fun {q : (a : α) -> β a -> Prop} => fun (h : (a : α) -> (b : β a) -> @Iff (p a b) (q a b)) => @exists_congr α (fun (a : α) => @Exists (β a) (fun (b : β a) => p a b)) (fun (a : α) => @Exists (β a) (fun (b : β a) => q a b)) (fun (a : α) => @exists_congr (β a) (p a) (q a) (h a))
theorem forall₃_congr : {α : Sort u_1} -> {β : α -> Sort u_2} -> {γ : (a : α) -> β a -> Sort u_3} -> {p : (a : α) -> (b : β a) -> γ a b -> Prop} -> {q : (a : α) -> (b : β a) -> γ a b -> Prop} -> ((a : α) -> (b : β a) -> (c : γ a b) -> @Iff (p a b c) (q a b c)) -> @Iff ((a : α) -> (b : β a) -> (c : γ a b) -> p a b c) ((a : α) -> (b : β a) -> (c : γ a b) -> q a b c) :=
  fun {α : Sort u_1} => fun {β : α -> Sort u_2} => fun {γ : (a : α) -> β a -> Sort u_3} => fun {p : (a : α) -> (b : β a) -> γ a b -> Prop} => fun {q : (a : α) -> (b : β a) -> γ a b -> Prop} => fun (h : (a : α) -> (b : β a) -> (c : γ a b) -> @Iff (p a b c) (q a b c)) => @forall_congr' α (fun (a : α) => (b : β a) -> (c : γ a b) -> p a b c) (fun (a : α) => (b : β a) -> (c : γ a b) -> q a b c) (fun (a : α) => @forall₂_congr (β a) (γ a) (p a) (q a) (h a))
theorem exists₃_congr : {α : Sort u_1} -> {β : α -> Sort u_2} -> {γ : (a : α) -> β a -> Sort u_3} -> {p : (a : α) -> (b : β a) -> γ a b -> Prop} -> {q : (a : α) -> (b : β a) -> γ a b -> Prop} -> ((a : α) -> (b : β a) -> (c : γ a b) -> @Iff (p a b c) (q a b c)) -> @Iff (@Exists α (fun (a : α) => @Exists (β a) (fun (b : β a) => @Exists (γ a b) (fun (c : γ a b) => p a b c)))) (@Exists α (fun (a : α) => @Exists (β a) (fun (b : β a) => @Exists (γ a b) (fun (c : γ a b) => q a b c)))) :=
  fun {α : Sort u_1} => fun {β : α -> Sort u_2} => fun {γ : (a : α) -> β a -> Sort u_3} => fun {p : (a : α) -> (b : β a) -> γ a b -> Prop} => fun {q : (a : α) -> (b : β a) -> γ a b -> Prop} => fun (h : (a : α) -> (b : β a) -> (c : γ a b) -> @Iff (p a b c) (q a b c)) => @exists_congr α (fun (a : α) => @Exists (β a) (fun (b : β a) => @Exists (γ a b) (fun (c : γ a b) => p a b c))) (fun (a : α) => @Exists (β a) (fun (b : β a) => @Exists (γ a b) (fun (c : γ a b) => q a b c))) (fun (a : α) => @exists₂_congr (β a) (γ a) (p a) (q a) (h a))
theorem forall₄_congr : {α : Sort u_1} -> {β : α -> Sort u_2} -> {γ : (a : α) -> β a -> Sort u_3} -> {δ : (a : α) -> (b : β a) -> γ a b -> Sort u_4} -> {p : (a : α) -> (b : β a) -> (c : γ a b) -> δ a b c -> Prop} -> {q : (a : α) -> (b : β a) -> (c : γ a b) -> δ a b c -> Prop} -> ((a : α) -> (b : β a) -> (c : γ a b) -> (d : δ a b c) -> @Iff (p a b c d) (q a b c d)) -> @Iff ((a : α) -> (b : β a) -> (c : γ a b) -> (d : δ a b c) -> p a b c d) ((a : α) -> (b : β a) -> (c : γ a b) -> (d : δ a b c) -> q a b c d) :=
  fun {α : Sort u_1} => fun {β : α -> Sort u_2} => fun {γ : (a : α) -> β a -> Sort u_3} => fun {δ : (a : α) -> (b : β a) -> γ a b -> Sort u_4} => fun {p : (a : α) -> (b : β a) -> (c : γ a b) -> δ a b c -> Prop} => fun {q : (a : α) -> (b : β a) -> (c : γ a b) -> δ a b c -> Prop} => fun (h : (a : α) -> (b : β a) -> (c : γ a b) -> (d : δ a b c) -> @Iff (p a b c d) (q a b c d)) => @forall_congr' α (fun (a : α) => (b : β a) -> (c : γ a b) -> (d : δ a b c) -> p a b c d) (fun (a : α) => (b : β a) -> (c : γ a b) -> (d : δ a b c) -> q a b c d) (fun (a : α) => @forall₃_congr (β a) (γ a) (δ a) (p a) (q a) (h a))
theorem exists₄_congr : {α : Sort u_1} -> {β : α -> Sort u_2} -> {γ : (a : α) -> β a -> Sort u_3} -> {δ : (a : α) -> (b : β a) -> γ a b -> Sort u_4} -> {p : (a : α) -> (b : β a) -> (c : γ a b) -> δ a b c -> Prop} -> {q : (a : α) -> (b : β a) -> (c : γ a b) -> δ a b c -> Prop} -> ((a : α) -> (b : β a) -> (c : γ a b) -> (d : δ a b c) -> @Iff (p a b c d) (q a b c d)) -> @Iff (@Exists α (fun (a : α) => @Exists (β a) (fun (b : β a) => @Exists (γ a b) (fun (c : γ a b) => @Exists (δ a b c) (fun (d : δ a b c) => p a b c d))))) (@Exists α (fun (a : α) => @Exists (β a) (fun (b : β a) => @Exists (γ a b) (fun (c : γ a b) => @Exists (δ a b c) (fun (d : δ a b c) => q a b c d))))) :=
  fun {α : Sort u_1} => fun {β : α -> Sort u_2} => fun {γ : (a : α) -> β a -> Sort u_3} => fun {δ : (a : α) -> (b : β a) -> γ a b -> Sort u_4} => fun {p : (a : α) -> (b : β a) -> (c : γ a b) -> δ a b c -> Prop} => fun {q : (a : α) -> (b : β a) -> (c : γ a b) -> δ a b c -> Prop} => fun (h : (a : α) -> (b : β a) -> (c : γ a b) -> (d : δ a b c) -> @Iff (p a b c d) (q a b c d)) => @exists_congr α (fun (a : α) => @Exists (β a) (fun (b : β a) => @Exists (γ a b) (fun (c : γ a b) => @Exists (δ a b c) (fun (d : δ a b c) => p a b c d)))) (fun (a : α) => @Exists (β a) (fun (b : β a) => @Exists (γ a b) (fun (c : γ a b) => @Exists (δ a b c) (fun (d : δ a b c) => q a b c d)))) (fun (a : α) => @exists₃_congr (β a) (γ a) (δ a) (p a) (q a) (h a))
theorem forall₅_congr : {α : Sort u_1} -> {β : α -> Sort u_2} -> {γ : (a : α) -> β a -> Sort u_3} -> {δ : (a : α) -> (b : β a) -> γ a b -> Sort u_4} -> {ε : (a : α) -> (b : β a) -> (c : γ a b) -> δ a b c -> Sort u_5} -> {p : (a : α) -> (b : β a) -> (c : γ a b) -> (d : δ a b c) -> ε a b c d -> Prop} -> {q : (a : α) -> (b : β a) -> (c : γ a b) -> (d : δ a b c) -> ε a b c d -> Prop} -> ((a : α) -> (b : β a) -> (c : γ a b) -> (d : δ a b c) -> (e : ε a b c d) -> @Iff (p a b c d e) (q a b c d e)) -> @Iff ((a : α) -> (b : β a) -> (c : γ a b) -> (d : δ a b c) -> (e : ε a b c d) -> p a b c d e) ((a : α) -> (b : β a) -> (c : γ a b) -> (d : δ a b c) -> (e : ε a b c d) -> q a b c d e) :=
  fun {α : Sort u_1} => fun {β : α -> Sort u_2} => fun {γ : (a : α) -> β a -> Sort u_3} => fun {δ : (a : α) -> (b : β a) -> γ a b -> Sort u_4} => fun {ε : (a : α) -> (b : β a) -> (c : γ a b) -> δ a b c -> Sort u_5} => fun {p : (a : α) -> (b : β a) -> (c : γ a b) -> (d : δ a b c) -> ε a b c d -> Prop} => fun {q : (a : α) -> (b : β a) -> (c : γ a b) -> (d : δ a b c) -> ε a b c d -> Prop} => fun (h : (a : α) -> (b : β a) -> (c : γ a b) -> (d : δ a b c) -> (e : ε a b c d) -> @Iff (p a b c d e) (q a b c d e)) => @forall_congr' α (fun (a : α) => (b : β a) -> (c : γ a b) -> (d : δ a b c) -> (e : ε a b c d) -> p a b c d e) (fun (a : α) => (b : β a) -> (c : γ a b) -> (d : δ a b c) -> (e : ε a b c d) -> q a b c d e) (fun (a : α) => @forall₄_congr (β a) (γ a) (δ a) (ε a) (p a) (q a) (h a))
theorem exists₅_congr : {α : Sort u_1} -> {β : α -> Sort u_2} -> {γ : (a : α) -> β a -> Sort u_3} -> {δ : (a : α) -> (b : β a) -> γ a b -> Sort u_4} -> {ε : (a : α) -> (b : β a) -> (c : γ a b) -> δ a b c -> Sort u_5} -> {p : (a : α) -> (b : β a) -> (c : γ a b) -> (d : δ a b c) -> ε a b c d -> Prop} -> {q : (a : α) -> (b : β a) -> (c : γ a b) -> (d : δ a b c) -> ε a b c d -> Prop} -> ((a : α) -> (b : β a) -> (c : γ a b) -> (d : δ a b c) -> (e : ε a b c d) -> @Iff (p a b c d e) (q a b c d e)) -> @Iff (@Exists α (fun (a : α) => @Exists (β a) (fun (b : β a) => @Exists (γ a b) (fun (c : γ a b) => @Exists (δ a b c) (fun (d : δ a b c) => @Exists (ε a b c d) (fun (e : ε a b c d) => p a b c d e)))))) (@Exists α (fun (a : α) => @Exists (β a) (fun (b : β a) => @Exists (γ a b) (fun (c : γ a b) => @Exists (δ a b c) (fun (d : δ a b c) => @Exists (ε a b c d) (fun (e : ε a b c d) => q a b c d e)))))) :=
  fun {α : Sort u_1} => fun {β : α -> Sort u_2} => fun {γ : (a : α) -> β a -> Sort u_3} => fun {δ : (a : α) -> (b : β a) -> γ a b -> Sort u_4} => fun {ε : (a : α) -> (b : β a) -> (c : γ a b) -> δ a b c -> Sort u_5} => fun {p : (a : α) -> (b : β a) -> (c : γ a b) -> (d : δ a b c) -> ε a b c d -> Prop} => fun {q : (a : α) -> (b : β a) -> (c : γ a b) -> (d : δ a b c) -> ε a b c d -> Prop} => fun (h : (a : α) -> (b : β a) -> (c : γ a b) -> (d : δ a b c) -> (e : ε a b c d) -> @Iff (p a b c d e) (q a b c d e)) => @exists_congr α (fun (a : α) => @Exists (β a) (fun (b : β a) => @Exists (γ a b) (fun (c : γ a b) => @Exists (δ a b c) (fun (d : δ a b c) => @Exists (ε a b c d) (fun (e : ε a b c d) => p a b c d e))))) (fun (a : α) => @Exists (β a) (fun (b : β a) => @Exists (γ a b) (fun (c : γ a b) => @Exists (δ a b c) (fun (d : δ a b c) => @Exists (ε a b c d) (fun (e : ε a b c d) => q a b c d e))))) (fun (a : α) => @exists₄_congr (β a) (γ a) (δ a) (ε a) (p a) (q a) (h a))
theorem not_exists : {α : Sort u_1} -> {p : α -> Prop} -> @Iff (@Not (@Exists α (fun (x : α) => p x))) ((x : α) -> @Not (p x)) :=
  fun {α : Sort u_1} => fun {p : α -> Prop} => @exists_imp α p False
theorem forall_not_of_not_exists : {α : Sort u_1} -> {p : α -> Prop} -> @Not (@Exists α (fun (x : α) => p x)) -> (x : α) -> @Not (p x) :=
  fun {α : Sort u_1} => fun {p : α -> Prop} => fun (h : @Not (@Exists α (fun (x : α) => p x))) => @Iff.mp (@Not (@Exists α (fun (x : α) => p x))) ((x : α) -> @Not (p x)) (@not_exists α p) h
theorem not_exists_of_forall_not : {α : Sort u_1} -> {p : α -> Prop} -> ((x : α) -> @Not (p x)) -> @Not (@Exists α (fun (x : α) => p x)) :=
  fun {α : Sort u_1} => fun {p : α -> Prop} => fun (h : (x : α) -> @Not (p x)) => @Iff.mpr (@Not (@Exists α (fun (x : α) => p x))) ((x : α) -> @Not (p x)) (@not_exists α p) h
def forall_and.match_1 : {α : Sort u_1} -> {p : α -> Prop} -> {q : α -> Prop} -> (motive : @And ((x : α) -> p x) ((x : α) -> q x) -> Prop) -> (x : @And ((x : α) -> p x) ((x : α) -> q x)) -> ((h₁ : (x1 : α) -> p x1) -> (h₂ : (x1 : α) -> q x1) -> motive (@And.intro ((x1 : α) -> p x1) ((x1 : α) -> q x1) h₁ h₂)) -> motive x :=
  fun {α : Sort u_1} => fun {p : α -> Prop} => fun {q : α -> Prop} => fun (motive : @And ((x : α) -> p x) ((x : α) -> q x) -> Prop) => fun (x : @And ((x : α) -> p x) ((x : α) -> q x)) => fun (h_1 : (h₁ : (x1 : α) -> p x1) -> (h₂ : (x1 : α) -> q x1) -> motive (@And.intro ((x1 : α) -> p x1) ((x1 : α) -> q x1) h₁ h₂)) => @And.casesOn ((x1 : α) -> p x1) ((x1 : α) -> q x1) (fun (x1 : @And ((x1 : α) -> p x1) ((x1 : α) -> q x1)) => motive x1) x (fun (left : (x1 : α) -> p x1) => fun (right : (x1 : α) -> q x1) => h_1 left right)
theorem forall_and : {α : Sort u_1} -> {p : α -> Prop} -> {q : α -> Prop} -> @Iff ((x : α) -> @And (p x) (q x)) (@And ((x : α) -> p x) ((x : α) -> q x)) :=
  fun {α : Sort u_1} => fun {p : α -> Prop} => fun {q : α -> Prop} => @Iff.intro ((x : α) -> @And (p x) (q x)) (@And ((x : α) -> p x) ((x : α) -> q x)) (fun (h : (x : α) -> @And (p x) (q x)) => @And.intro ((x : α) -> p x) ((x : α) -> q x) (fun (x : α) => @And.left (p x) (q x) (h x)) (fun (x : α) => @And.right (p x) (q x) (h x))) (fun (x : @And ((x : α) -> p x) ((x : α) -> q x)) => fun (x1 : α) => @forall_and.match_1 α p q (fun (_ : @And ((x2 : α) -> p x2) ((x2 : α) -> q x2)) => @And (p x1) (q x1)) x (fun (h₁ : (x2 : α) -> p x2) => fun (h₂ : (x2 : α) -> q x2) => @And.intro (p x1) (q x1) (h₁ x1) (h₂ x1)))
def exists_or.match_1 : {α : Sort u_1} -> {p : α -> Prop} -> {q : α -> Prop} -> (motive : @Exists α (fun (x : α) => @Or (p x) (q x)) -> Prop) -> (x : @Exists α (fun (x : α) => @Or (p x) (q x))) -> ((x1 : α) -> (h : p x1) -> motive (@Exists.intro α (fun (x2 : α) => @Or (p x2) (q x2)) x1 (@Or.inl (p x1) (q x1) h))) -> ((x1 : α) -> (h : q x1) -> motive (@Exists.intro α (fun (x2 : α) => @Or (p x2) (q x2)) x1 (@Or.inr (p x1) (q x1) h))) -> motive x :=
  fun {α : Sort u_1} => fun {p : α -> Prop} => fun {q : α -> Prop} => fun (motive : @Exists α (fun (x : α) => @Or (p x) (q x)) -> Prop) => fun (x : @Exists α (fun (x : α) => @Or (p x) (q x))) => fun (h_1 : (x1 : α) -> (h : p x1) -> motive (@Exists.intro α (fun (x2 : α) => @Or (p x2) (q x2)) x1 (@Or.inl (p x1) (q x1) h))) => fun (h_2 : (x1 : α) -> (h : q x1) -> motive (@Exists.intro α (fun (x2 : α) => @Or (p x2) (q x2)) x1 (@Or.inr (p x1) (q x1) h))) => @Exists.casesOn α (fun (x1 : α) => @Or (p x1) (q x1)) (fun (x1 : @Exists α (fun (x1 : α) => @Or (p x1) (q x1))) => motive x1) x (fun (w : α) => fun (h : @Or (p w) (q w)) => @Or.casesOn (p w) (q w) (fun (x1 : @Or (p w) (q w)) => motive (@Exists.intro α (fun (x2 : α) => @Or (p x2) (q x2)) w x1)) h (fun (h1 : p w) => h_1 w h1) (fun (h1 : q w) => h_2 w h1))
def exists_or.match_2 : {α : Sort u_1} -> {p : α -> Prop} -> {q : α -> Prop} -> (motive : @Or (@Exists α (fun (x : α) => p x)) (@Exists α (fun (x : α) => q x)) -> Prop) -> (x : @Or (@Exists α (fun (x : α) => p x)) (@Exists α (fun (x : α) => q x))) -> ((x1 : α) -> (h : p x1) -> motive (@Or.inl (@Exists α (fun (x2 : α) => p x2)) (@Exists α (fun (x2 : α) => q x2)) (@Exists.intro α (fun (x2 : α) => p x2) x1 h))) -> ((x1 : α) -> (h : q x1) -> motive (@Or.inr (@Exists α (fun (x2 : α) => p x2)) (@Exists α (fun (x2 : α) => q x2)) (@Exists.intro α (fun (x2 : α) => q x2) x1 h))) -> motive x :=
  fun {α : Sort u_1} => fun {p : α -> Prop} => fun {q : α -> Prop} => fun (motive : @Or (@Exists α (fun (x : α) => p x)) (@Exists α (fun (x : α) => q x)) -> Prop) => fun (x : @Or (@Exists α (fun (x : α) => p x)) (@Exists α (fun (x : α) => q x))) => fun (h_1 : (x1 : α) -> (h : p x1) -> motive (@Or.inl (@Exists α (fun (x2 : α) => p x2)) (@Exists α (fun (x2 : α) => q x2)) (@Exists.intro α (fun (x2 : α) => p x2) x1 h))) => fun (h_2 : (x1 : α) -> (h : q x1) -> motive (@Or.inr (@Exists α (fun (x2 : α) => p x2)) (@Exists α (fun (x2 : α) => q x2)) (@Exists.intro α (fun (x2 : α) => q x2) x1 h))) => @Or.casesOn (@Exists α (fun (x1 : α) => p x1)) (@Exists α (fun (x1 : α) => q x1)) (fun (x1 : @Or (@Exists α (fun (x1 : α) => p x1)) (@Exists α (fun (x1 : α) => q x1))) => motive x1) x (fun (h : @Exists α (fun (x1 : α) => p x1)) => @Exists.casesOn α (fun (x1 : α) => p x1) (fun (x1 : @Exists α (fun (x1 : α) => p x1)) => motive (@Or.inl (@Exists α (fun (x2 : α) => p x2)) (@Exists α (fun (x2 : α) => q x2)) x1)) h (fun (w : α) => fun (h1 : p w) => h_1 w h1)) (fun (h : @Exists α (fun (x1 : α) => q x1)) => @Exists.casesOn α (fun (x1 : α) => q x1) (fun (x1 : @Exists α (fun (x1 : α) => q x1)) => motive (@Or.inr (@Exists α (fun (x2 : α) => p x2)) (@Exists α (fun (x2 : α) => q x2)) x1)) h (fun (w : α) => fun (h1 : q w) => h_2 w h1))
theorem exists_or : {α : Sort u_1} -> {p : α -> Prop} -> {q : α -> Prop} -> @Iff (@Exists α (fun (x : α) => @Or (p x) (q x))) (@Or (@Exists α (fun (x : α) => p x)) (@Exists α (fun (x : α) => q x))) :=
  fun {α : Sort u_1} => fun {p : α -> Prop} => fun {q : α -> Prop} => @Iff.intro (@Exists α (fun (x : α) => @Or (p x) (q x))) (@Or (@Exists α (fun (x : α) => p x)) (@Exists α (fun (x : α) => q x))) (fun (x : @Exists α (fun (x : α) => @Or (p x) (q x))) => @exists_or.match_1 α p q (fun (_ : @Exists α (fun (x1 : α) => @Or (p x1) (q x1))) => @Or (@Exists α (fun (x2 : α) => p x2)) (@Exists α (fun (x2 : α) => q x2))) x (fun (x1 : α) => fun (h : p x1) => @Or.inl (@Exists α (fun (x2 : α) => p x2)) (@Exists α (fun (x2 : α) => q x2)) (@Exists.intro α (fun (x2 : α) => p x2) x1 h)) (fun (x1 : α) => fun (h : q x1) => @Or.inr (@Exists α (fun (x2 : α) => p x2)) (@Exists α (fun (x2 : α) => q x2)) (@Exists.intro α (fun (x2 : α) => q x2) x1 h))) (fun (x : @Or (@Exists α (fun (x : α) => p x)) (@Exists α (fun (x : α) => q x))) => @exists_or.match_2 α p q (fun (_ : @Or (@Exists α (fun (x1 : α) => p x1)) (@Exists α (fun (x1 : α) => q x1))) => @Exists α (fun (x2 : α) => @Or (p x2) (q x2))) x (fun (x1 : α) => fun (h : p x1) => @Exists.intro α (fun (x2 : α) => @Or (p x2) (q x2)) x1 (@Or.inl (p x1) (q x1) h)) (fun (x1 : α) => fun (h : q x1) => @Exists.intro α (fun (x2 : α) => @Or (p x2) (q x2)) x1 (@Or.inr (p x1) (q x1) h)))
theorem Exists.nonempty : {α : Sort u_1} -> {p : α -> Prop} -> @Exists α (fun (x : α) => p x) -> @Nonempty α :=
  fun {α : Sort u_1} => fun {p : α -> Prop} => fun (x : @Exists α (fun (x : α) => p x)) => @forall_exists_index.match_1 α p (fun (_ : @Exists α (fun (x1 : α) => p x1)) => @Nonempty α) x (fun (x1 : α) => fun (_ : p x1) => @Nonempty.intro α x1)
def not_forall_of_exists_not.match_1 : {α : Sort u_1} -> {p : α -> Prop} -> (motive : @Exists α (fun (x : α) => @Not (p x)) -> ((x1 : α) -> p x1) -> Prop) -> (x : @Exists α (fun (x : α) => @Not (p x))) -> (x1 : (x1 : α) -> p x1) -> ((x2 : α) -> (hn : @Not (p x2)) -> (h : (x3 : α) -> p x3) -> motive (@Exists.intro α (fun (x3 : α) => @Not (p x3)) x2 hn) h) -> motive x x1 :=
  fun {α : Sort u_1} => fun {p : α -> Prop} => fun (motive : @Exists α (fun (x : α) => @Not (p x)) -> ((x1 : α) -> p x1) -> Prop) => fun (x : @Exists α (fun (x : α) => @Not (p x))) => fun (x1 : (x1 : α) -> p x1) => fun (h_1 : (x2 : α) -> (hn : @Not (p x2)) -> (h : (x3 : α) -> p x3) -> motive (@Exists.intro α (fun (x3 : α) => @Not (p x3)) x2 hn) h) => @Exists.casesOn α (fun (x2 : α) => @Not (p x2)) (fun (x2 : @Exists α (fun (x2 : α) => @Not (p x2))) => motive x2 x1) x (fun (w : α) => fun (h : @Not (p w)) => h_1 w h x1)
theorem not_forall_of_exists_not : {α : Sort u_1} -> {p : α -> Prop} -> @Exists α (fun (x : α) => @Not (p x)) -> @Not ((x : α) -> p x) :=
  fun {α : Sort u_1} => fun {p : α -> Prop} => fun (x : @Exists α (fun (x : α) => @Not (p x))) => fun (x1 : (x1 : α) -> p x1) => @not_forall_of_exists_not.match_1 α p (fun (_ : @Exists α (fun (x2 : α) => @Not (p x2))) => fun (_ : (x3 : α) -> p x3) => False) x x1 (fun (x2 : α) => fun (hn : @Not (p x2)) => fun (h : (x3 : α) -> p x3) => hn (h x2))
def exists_prop'.match_1 : {α : Sort u_1} -> {p : Prop} -> (motive : @Exists α (fun (_ : α) => p) -> Prop) -> (x : @Exists α (fun (_ : α) => p)) -> ((a : α) -> (h : p) -> motive (@Exists.intro α (fun (_ : α) => p) a h)) -> motive x :=
  fun {α : Sort u_1} => fun {p : Prop} => fun (motive : @Exists α (fun (_ : α) => p) -> Prop) => fun (x : @Exists α (fun (_ : α) => p)) => fun (h_1 : (a : α) -> (h : p) -> motive (@Exists.intro α (fun (_ : α) => p) a h)) => @Exists.casesOn α (fun (_ : α) => p) (fun (x1 : @Exists α (fun (_ : α) => p)) => motive x1) x (fun (w : α) => fun (h : p) => h_1 w h)
def exists_prop'.match_2 : {α : Sort u_1} -> {p : Prop} -> (motive : @And (@Nonempty α) p -> Prop) -> (x : @And (@Nonempty α) p) -> ((a : α) -> (h : p) -> motive (@And.intro (@Nonempty α) p (@Nonempty.intro α a) h)) -> motive x :=
  fun {α : Sort u_1} => fun {p : Prop} => fun (motive : @And (@Nonempty α) p -> Prop) => fun (x : @And (@Nonempty α) p) => fun (h_1 : (a : α) -> (h : p) -> motive (@And.intro (@Nonempty α) p (@Nonempty.intro α a) h)) => @And.casesOn (@Nonempty α) p (fun (x1 : @And (@Nonempty α) p) => motive x1) x (fun (left : @Nonempty α) => fun (right : p) => @Nonempty.casesOn α (fun (x1 : @Nonempty α) => motive (@And.intro (@Nonempty α) p x1 right)) left (fun (val : α) => h_1 val right))
theorem exists_prop' : {α : Sort u_1} -> {p : Prop} -> @Iff (@Exists α (fun (_ : α) => p)) (@And (@Nonempty α) p) :=
  fun {α : Sort u_1} => fun {p : Prop} => @Iff.intro (@Exists α (fun (_ : α) => p)) (@And (@Nonempty α) p) (fun (x : @Exists α (fun (_ : α) => p)) => @exists_prop'.match_1 α p (fun (_ : @Exists α (fun (_ : α) => p)) => @And (@Nonempty α) p) x (fun (a : α) => fun (h : p) => @And.intro (@Nonempty α) p (@Nonempty.intro α a) h)) (fun (x : @And (@Nonempty α) p) => @exists_prop'.match_2 α p (fun (_ : @And (@Nonempty α) p) => @Exists α (fun (_ : α) => p)) x (fun (a : α) => fun (h : p) => @Exists.intro α (fun (_ : α) => p) a h))
theorem forall_const : {b : Prop} -> (α : Sort u_1) -> @Nonempty α -> @Iff (α -> b) b :=
  fun {b : Prop} => fun (α : Sort u_1) => fun (i : @Nonempty α) => @Iff.intro (α -> b) b (@Nonempty.elim α b i) (fun (hb : b) => fun (_ : α) => hb)
theorem forall_prop_of_true : {p : Prop} -> {q : p -> Prop} -> (h : p) -> @Iff ((h' : p) -> q h') (q h) :=
  fun {p : Prop} => fun {q : p -> Prop} => fun (h : p) => @forall_const (q h) p (@Nonempty.intro p h)
theorem forall_comm : {α : Sort u_2} -> {β : Sort u_1} -> {p : α -> β -> Prop} -> @Iff ((a : α) -> (b : β) -> p a b) ((b : β) -> (a : α) -> p a b) :=
  fun {α : Sort u_2} => fun {β : Sort u_1} => fun {p : α -> β -> Prop} => @Iff.intro ((a : α) -> (b : β) -> p a b) ((b : β) -> (a : α) -> p a b) (fun (h : (a : α) -> (b : β) -> p a b) => fun (b : β) => fun (a : α) => h a b) (fun (h : (b : β) -> (a : α) -> p a b) => fun (a : α) => fun (b : β) => h b a)
def exists_comm.match_1 : {α : Sort u_1} -> {β : Sort u_2} -> {p : α -> β -> Prop} -> (motive : @Exists α (fun (a : α) => @Exists β (fun (b : β) => p a b)) -> Prop) -> (x : @Exists α (fun (a : α) => @Exists β (fun (b : β) => p a b))) -> ((a : α) -> (b : β) -> (h : p a b) -> motive (@Exists.intro α (fun (a1 : α) => @Exists β (fun (b1 : β) => p a1 b1)) a (@Exists.intro β (fun (b1 : β) => p a b1) b h))) -> motive x :=
  fun {α : Sort u_1} => fun {β : Sort u_2} => fun {p : α -> β -> Prop} => fun (motive : @Exists α (fun (a : α) => @Exists β (fun (b : β) => p a b)) -> Prop) => fun (x : @Exists α (fun (a : α) => @Exists β (fun (b : β) => p a b))) => fun (h_1 : (a : α) -> (b : β) -> (h : p a b) -> motive (@Exists.intro α (fun (a1 : α) => @Exists β (fun (b1 : β) => p a1 b1)) a (@Exists.intro β (fun (b1 : β) => p a b1) b h))) => @Exists.casesOn α (fun (a : α) => @Exists β (fun (b : β) => p a b)) (fun (x1 : @Exists α (fun (a : α) => @Exists β (fun (b : β) => p a b))) => motive x1) x (fun (w : α) => fun (h : @Exists β (fun (b : β) => p w b)) => @Exists.casesOn β (fun (b : β) => p w b) (fun (x1 : @Exists β (fun (b : β) => p w b)) => motive (@Exists.intro α (fun (a : α) => @Exists β (fun (b : β) => p a b)) w x1)) h (fun (w1 : β) => fun (h1 : p w w1) => h_1 w w1 h1))
def exists_comm.match_2 : {α : Sort u_2} -> {β : Sort u_1} -> {p : α -> β -> Prop} -> (motive : @Exists β (fun (b : β) => @Exists α (fun (a : α) => p a b)) -> Prop) -> (x : @Exists β (fun (b : β) => @Exists α (fun (a : α) => p a b))) -> ((b : β) -> (a : α) -> (h : p a b) -> motive (@Exists.intro β (fun (b1 : β) => @Exists α (fun (a1 : α) => p a1 b1)) b (@Exists.intro α (fun (a1 : α) => p a1 b) a h))) -> motive x :=
  fun {α : Sort u_2} => fun {β : Sort u_1} => fun {p : α -> β -> Prop} => fun (motive : @Exists β (fun (b : β) => @Exists α (fun (a : α) => p a b)) -> Prop) => fun (x : @Exists β (fun (b : β) => @Exists α (fun (a : α) => p a b))) => fun (h_1 : (b : β) -> (a : α) -> (h : p a b) -> motive (@Exists.intro β (fun (b1 : β) => @Exists α (fun (a1 : α) => p a1 b1)) b (@Exists.intro α (fun (a1 : α) => p a1 b) a h))) => @Exists.casesOn β (fun (b : β) => @Exists α (fun (a : α) => p a b)) (fun (x1 : @Exists β (fun (b : β) => @Exists α (fun (a : α) => p a b))) => motive x1) x (fun (w : β) => fun (h : @Exists α (fun (a : α) => p a w)) => @Exists.casesOn α (fun (a : α) => p a w) (fun (x1 : @Exists α (fun (a : α) => p a w)) => motive (@Exists.intro β (fun (b : β) => @Exists α (fun (a : α) => p a b)) w x1)) h (fun (w1 : α) => fun (h1 : p w1 w) => h_1 w w1 h1))
theorem exists_comm : {α : Sort u_2} -> {β : Sort u_1} -> {p : α -> β -> Prop} -> @Iff (@Exists α (fun (a : α) => @Exists β (fun (b : β) => p a b))) (@Exists β (fun (b : β) => @Exists α (fun (a : α) => p a b))) :=
  fun {α : Sort u_2} => fun {β : Sort u_1} => fun {p : α -> β -> Prop} => @Iff.intro (@Exists α (fun (a : α) => @Exists β (fun (b : β) => p a b))) (@Exists β (fun (b : β) => @Exists α (fun (a : α) => p a b))) (fun (x : @Exists α (fun (a : α) => @Exists β (fun (b : β) => p a b))) => @exists_comm.match_1 α β p (fun (_ : @Exists α (fun (a : α) => @Exists β (fun (b : β) => p a b))) => @Exists β (fun (b : β) => @Exists α (fun (a : α) => p a b))) x (fun (a : α) => fun (b : β) => fun (h : p a b) => @Exists.intro β (fun (b1 : β) => @Exists α (fun (a1 : α) => p a1 b1)) b (@Exists.intro α (fun (a1 : α) => p a1 b) a h))) (fun (x : @Exists β (fun (b : β) => @Exists α (fun (a : α) => p a b))) => @exists_comm.match_2 α β p (fun (_ : @Exists β (fun (b : β) => @Exists α (fun (a : α) => p a b))) => @Exists α (fun (a : α) => @Exists β (fun (b : β) => p a b))) x (fun (b : β) => fun (a : α) => fun (h : p a b) => @Exists.intro α (fun (a1 : α) => @Exists β (fun (b1 : β) => p a1 b1)) a (@Exists.intro β (fun (b1 : β) => p a b1) b h)))
theorem iff_true_intro : {a : Prop} -> a -> @Iff a True :=
  fun {a : Prop} => fun (h : a) => @iff_of_true a True h trivial
theorem forall_prop_of_false : {p : Prop} -> {q : p -> Prop} -> @Not p -> @Iff ((h' : p) -> q h') True :=
  fun {p : Prop} => fun {q : p -> Prop} => fun (hn : @Not p) => @iff_true_intro ((h' : p) -> q h') (fun (h : p) => @Not.elim p (q h) hn h)
def outParam : Sort u -> Sort u :=
  fun (α : Sort u) => α
inductive Membership : @outParam (Type u) -> Type v -> Sort (max (u + 1) (v + 1)) where
  | mk : {α : @outParam (Type u)} -> {γ : Type v} -> (γ -> α -> Prop) -> @Membership α γ
def Membership.mem : {α : @outParam (Type u)} -> {γ : Type v} -> @Membership α γ -> γ -> α -> Prop :=
  fun {α : @outParam (Type u)} => fun (γ : Type v) => fun (self : @Membership α γ) => self.0
theorem ne_of_mem_of_not_mem : {α : Type u_1} -> {β : Type u_2} -> (inst : @Membership α β) -> {s : β} -> {a : α} -> {b : α} -> @Membership.mem α β inst s a -> @Not (@Membership.mem α β inst s b) -> @Ne α a b :=
  fun {α : Type u_1} => fun {β : Type u_2} => fun (inst : @Membership α β) => fun {s : β} => fun {a : α} => fun {b : α} => fun (h : @Membership.mem α β inst s a) => @mt (@Eq α a b) (@Membership.mem α β inst s b) (fun (e : @Eq α a b) => @Eq.rec α a (fun (x : α) => fun (_ : @Eq α a x) => @Membership.mem α β inst s x) h b e)
theorem ne_of_mem_of_not_mem' : {α : Type u_1} -> {β : Type u_2} -> (inst : @Membership α β) -> {s : β} -> {t : β} -> {a : α} -> @Membership.mem α β inst s a -> @Not (@Membership.mem α β inst t a) -> @Ne β s t :=
  fun {α : Type u_1} => fun {β : Type u_2} => fun (inst : @Membership α β) => fun {s : β} => fun {t : β} => fun {a : α} => fun (h : @Membership.mem α β inst s a) => @mt (@Eq β s t) (@Membership.mem α β inst t a) (fun (e : @Eq β s t) => @Eq.rec β s (fun (x : β) => fun (_ : @Eq β s x) => @Membership.mem α β inst x a) h t e)
-- def False.casesOn : (motive : False -> Sort u) -> (t : False) -> motive t :=
--  fun (motive : False -> Sort u) => fun (t : False) => @False.rec motive t
def or_false.match_1 : (p : Prop) -> (motive : @Or p False -> Prop) -> (x : @Or p False) -> ((h : p) -> motive (@Or.inl p False h)) -> motive x :=
  fun (p : Prop) => fun (motive : @Or p False -> Prop) => fun (x : @Or p False) => fun (h_1 : (h : p) -> motive (@Or.inl p False h)) => @Or.casesOn p False (fun (x1 : @Or p False) => motive x1) x (fun (h : p) => h_1 h) (fun (h : False) => @False.casesOn (fun (x1 : False) => motive (@Or.inr p False x1)) h)
theorem or_false : (p : Prop) -> @Eq Prop (@Or p False) p :=
  fun (p : Prop) => @propext (@Or p False) p (@Iff.intro (@Or p False) p (fun (x : @Or p False) => @or_false.match_1 p (fun (_ : @Or p False) => p) x (fun (h : p) => h)) (@Or.inl p False))
theorem or_true : (p : Prop) -> @Eq Prop (@Or p True) True :=
  fun (p : Prop) => @eq_true (@Or p True) (@Or.inr p True trivial)
theorem Decidable.not_or_self : (p : Prop) -> @Decidable p -> @Or (@Not p) p :=
  fun (p : Prop) => fun (h : @Decidable p) => @Decidable.casesOn p (fun (t : @Decidable p) => @Eq (@Decidable p) h t -> @Or (@Not p) p) h (fun (h1 : @Not p) => fun (_ : @Eq (@Decidable p) h (@Decidable.isFalse p h1)) => @of_eq_true (@Or (@Not p) p) (@Eq.trans Prop (@Or (@Not p) p) (@Or True False) True (@congr Prop Prop (@Or (@Not p)) (@Or True) p False (@congrArg Prop (Prop -> Prop) (@Not p) True Or (@Eq.trans Prop (@Not p) (@Not False) True (@congrArg Prop Prop p False Not (@eq_false p h1)) not_false_eq_true)) (@eq_false p h1)) (@or_false True))) (fun (h1 : p) => fun (_ : @Eq (@Decidable p) h (@Decidable.isTrue p h1)) => @of_eq_true (@Or (@Not p) p) (@Eq.trans Prop (@Or (@Not p) p) (@Or False True) True (@congr Prop Prop (@Or (@Not p)) (@Or False) p True (@congrArg Prop (Prop -> Prop) (@Not p) False Or (@Eq.trans Prop (@Not p) (@Not True) False (@congrArg Prop Prop p True Not (@eq_true p h1)) not_true_eq_false)) (@eq_true p h1)) (@or_true False))) (@Eq.refl (@Decidable p) h)
theorem Decidable.byContradiction : {p : Prop} -> @Decidable p -> (@Not p -> False) -> p :=
  fun {p : Prop} => fun (dec : @Decidable p) => fun (h : @Not p -> False) => @Decidable.byCases p p dec (@id p) (fun (np : @Not p) => @False.elim p (h np))
theorem Decidable.of_not_not : {p : Prop} -> @Decidable p -> @Not (@Not p) -> p :=
  fun {p : Prop} => fun (inst : @Decidable p) => fun (hnn : @Not (@Not p)) => @Decidable.byContradiction p inst (fun (hn : @Not p) => @absurd (@Not p) False hn hnn)
theorem Decidable.by_contra : {p : Prop} -> @Decidable p -> (@Not p -> False) -> p :=
  fun {p : Prop} => fun (inst : @Decidable p) => @Decidable.of_not_not p inst
def decide_eq_true.match_1 : {p : Prop} -> (motive : @Decidable p -> p -> Prop) -> (x : @Decidable p) -> (x1 : p) -> ((h : p) -> (x2 : p) -> motive (@Decidable.isTrue p h) x2) -> ((h₁ : @Not p) -> (h₂ : p) -> motive (@Decidable.isFalse p h₁) h₂) -> motive x x1 :=
  fun {p : Prop} => fun (motive : @Decidable p -> p -> Prop) => fun (x : @Decidable p) => fun (x1 : p) => fun (h_1 : (h : p) -> (x2 : p) -> motive (@Decidable.isTrue p h) x2) => fun (h_2 : (h₁ : @Not p) -> (h₂ : p) -> motive (@Decidable.isFalse p h₁) h₂) => @Decidable.casesOn p (fun (x2 : @Decidable p) => motive x2 x1) x (fun (h : @Not p) => h_2 h x1) (fun (h : p) => h_1 h x1)
theorem decide_eq_true : {p : Prop} -> (inst : @Decidable p) -> p -> @Eq Bool (@Decidable.decide p inst) Bool.true :=
  fun {p : Prop} => fun (x : @Decidable p) => fun (x1 : p) => @decide_eq_true.match_1 p (fun (x2 : @Decidable p) => fun (_ : p) => @Eq Bool (@Decidable.decide p x2) Bool.true) x x1 (fun (h : p) => fun (_ : p) => @rfl Bool (@Decidable.decide p (@Decidable.isTrue p h))) (fun (h₁ : @Not p) => fun (h₂ : p) => @absurd p (@Eq Bool (@Decidable.decide p (@Decidable.isFalse p h₁)) Bool.true) h₂ h₁)
theorem decide_eq_true_eq : {p : Prop} -> (inst : @Decidable p) -> @Eq Prop (@Eq Bool (@Decidable.decide p inst) Bool.true) p :=
  fun {p : Prop} => fun (inst : @Decidable p) => @propext (@Eq Bool (@Decidable.decide p inst) Bool.true) p (@Iff.intro (@Eq Bool (@Decidable.decide p inst) Bool.true) p (@of_decide_eq_true p inst) (@decide_eq_true p inst))
theorem decide_eq_true_iff : {p : Prop} -> (inst : @Decidable p) -> @Iff (@Eq Bool (@Decidable.decide p inst) Bool.true) p :=
  fun {p : Prop} => fun (inst : @Decidable p) => @of_eq_true (@Iff (@Eq Bool (@Decidable.decide p inst) Bool.true) p) (@Eq.trans Prop (@Iff (@Eq Bool (@Decidable.decide p inst) Bool.true) p) (@Iff p p) True (@congrArg Prop Prop (@Eq Bool (@Decidable.decide p inst) Bool.true) p (fun (x : Prop) => @Iff x p) (@decide_eq_true_eq p inst)) (@iff_self p))
theorem not_not_of_not_imp : {a : Prop} -> {b : Prop} -> @Not (a -> b) -> @Not (@Not a) :=
  fun {a : Prop} => fun {b : Prop} => @mt (@Not a) (a -> b) (@Not.elim a b)
theorem Decidable.of_not_imp : {a : Prop} -> {b : Prop} -> @Decidable a -> @Not (a -> b) -> a :=
  fun {a : Prop} => fun {b : Prop} => fun (inst : @Decidable a) => fun (h : @Not (a -> b)) => @Decidable.byContradiction a inst (@not_not_of_not_imp a b h)
theorem Decidable.not_imp_symm : {a : Prop} -> {b : Prop} -> @Decidable a -> (@Not a -> b) -> @Not b -> a :=
  fun {a : Prop} => fun {b : Prop} => fun (inst : @Decidable a) => fun (h : @Not a -> b) => fun (hb : @Not b) => @Decidable.byContradiction a inst (@Function.comp (@Not a) b False hb h)
theorem Decidable.not_imp_comm : {a : Prop} -> {b : Prop} -> @Decidable a -> @Decidable b -> @Iff (@Not a -> b) (@Not b -> a) :=
  fun {a : Prop} => fun {b : Prop} => fun (inst : @Decidable a) => fun (inst1 : @Decidable b) => @Iff.intro (@Not a -> b) (@Not b -> a) (@Decidable.not_imp_symm a b inst) (@Decidable.not_imp_symm b a inst1)
theorem imp_not_self : {a : Prop} -> @Iff (a -> @Not a) (@Not a) :=
  fun {a : Prop} => @Iff.intro (a -> @Not a) (@Not a) (fun (h : a -> @Not a) => fun (ha : a) => h ha ha) (fun (h : @Not a) => fun (_ : a) => h)
def Eq.mp : {α : Sort u} -> {β : Sort u} -> @Eq (Sort u) α β -> α -> β :=
  fun {α : Sort u} => fun {β : Sort u} => fun (h : @Eq (Sort u) α β) => fun (a : α) => @Eq.rec (Sort u) α (fun (x : Sort u) => fun (_ : @Eq (Sort u) α x) => x) a β h
theorem not_not_intro : {p : Prop} -> p -> @Not (@Not p) :=
  fun {p : Prop} => fun (h : p) => fun (hn : @Not p) => hn h
theorem Decidable.not_not : {p : Prop} -> @Decidable p -> @Iff (@Not (@Not p)) p :=
  fun {p : Prop} => fun (inst : @Decidable p) => @Iff.intro (@Not (@Not p)) p (@Decidable.of_not_not p inst) (@not_not_intro p)
theorem Decidable.not_imp_self : {a : Prop} -> @Decidable a -> @Iff (@Not a -> a) a :=
  fun {a : Prop} => fun (inst : @Decidable a) => @letFun (@Iff (@Not a -> @Not (@Not a)) (@Not (@Not a))) (fun (_ : @Iff (@Not a -> @Not (@Not a)) (@Not (@Not a))) => ([mdata noImplicitLambda:1 Iff ((Not #2) -> #2) #2])) (@imp_not_self (@Not a)) (fun (this : @Iff (@Not a -> @Not (@Not a)) (@Not (@Not a))) => @Eq.mp (@Iff (@Not a -> @Not (@Not a)) (@Not (@Not a))) (@Iff (@Not a -> a) a) (@congrArg Prop Prop (@Not (@Not a)) a (fun (_a : Prop) => @Iff (@Not a -> _a) _a) (@propext (@Not (@Not a)) a (@Decidable.not_not a inst))) this)
theorem Or.resolve_left : {a : Prop} -> {b : Prop} -> @Or a b -> @Not a -> b :=
  fun {a : Prop} => fun {b : Prop} => fun (h : @Or a b) => fun (na : @Not a) => @Or.elim a b b h (fun (x : a) => @absurd a b x na) (@id b)
theorem Decidable.or_iff_not_imp_left : {a : Prop} -> {b : Prop} -> @Decidable a -> @Iff (@Or a b) (@Not a -> b) :=
  fun {a : Prop} => fun {b : Prop} => fun (inst : @Decidable a) => @Iff.intro (@Or a b) (@Not a -> b) (@Or.resolve_left a b) (fun (h : @Not a -> b) => @dite (@Or a b) a inst (@Or.inl a b) (@Function.comp (@Not a) b (@Or a b) (@Or.inr a b) h))
theorem Decidable.or_iff_not_imp_right : {b : Prop} -> {a : Prop} -> @Decidable b -> @Iff (@Or a b) (@Not b -> a) :=
  fun {b : Prop} => fun {a : Prop} => fun (inst : @Decidable b) => @Iff.trans (@Or a b) (@Or b a) (@Not b -> a) (@or_comm a b) (@Decidable.or_iff_not_imp_left b a inst)
theorem Decidable.not_imp_not : {a : Prop} -> {b : Prop} -> @Decidable a -> @Iff (@Not a -> @Not b) (b -> a) :=
  fun {a : Prop} => fun {b : Prop} => fun (inst : @Decidable a) => @Iff.intro (@Not a -> @Not b) (b -> a) (fun (h : @Not a -> @Not b) => fun (hb : b) => @Decidable.byContradiction a inst (fun (x : @Not a) => h x hb)) (@mt b a)
theorem Decidable.not_or_of_imp : {a : Prop} -> {b : Prop} -> @Decidable a -> (a -> b) -> @Or (@Not a) b :=
  fun {a : Prop} => fun {b : Prop} => fun (inst : @Decidable a) => fun (h : a -> b) => @dite (@Or (@Not a) b) a inst (fun (ha : a) => @Or.inr (@Not a) b (h ha)) (fun (ha : @Not a) => @Or.inl (@Not a) b ha)
theorem Or.neg_resolve_left : {a : Prop} -> {b : Prop} -> @Or (@Not a) b -> a -> b :=
  fun {a : Prop} => fun {b : Prop} => fun (h : @Or (@Not a) b) => fun (ha : a) => @Or.elim (@Not a) b b h (@absurd a b ha) (@id b)
theorem Decidable.imp_iff_not_or : {a : Prop} -> {b : Prop} -> @Decidable a -> @Iff (a -> b) (@Or (@Not a) b) :=
  fun {a : Prop} => fun {b : Prop} => fun (inst : @Decidable a) => @Iff.intro (a -> b) (@Or (@Not a) b) (@Decidable.not_or_of_imp a b inst) (@Or.neg_resolve_left a b)
theorem Decidable.imp_iff_or_not : {b : Prop} -> {a : Prop} -> @Decidable b -> @Iff (b -> a) (@Or a (@Not b)) :=
  fun {b : Prop} => fun {a : Prop} => fun (inst : @Decidable b) => @Iff.trans (b -> a) (@Or (@Not b) a) (@Or a (@Not b)) (@Decidable.imp_iff_not_or b a inst) (@or_comm (@Not b) a)
theorem imp_iff_right : {b : Prop} -> {a : Prop} -> a -> @Iff (a -> b) b :=
  fun {b : Prop} => fun {a : Prop} => fun (ha : a) => @Iff.intro (a -> b) b (fun (x : a -> b) => x ha) (fun (a1 : b) => fun (_ : a) => a1)
theorem false_imp_iff : (a : Prop) -> @Iff (False -> a) True :=
  fun (a : Prop) => @iff_true_intro (False -> a) (@False.elim a)
theorem true_or : (p : Prop) -> @Eq Prop (@Or True p) True :=
  fun (p : Prop) => @eq_true (@Or True p) (@Or.inl True p trivial)
theorem Decidable.imp_or : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Decidable a -> @Iff (a -> @Or b c) (@Or (a -> b) (a -> c)) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (inst : @Decidable a) => @dite (@Iff (a -> @Or b c) (@Or (a -> b) (a -> c))) a inst (fun (h : a) => @Eq.mpr (@Iff (a -> @Or b c) (@Or (a -> b) (a -> c))) (@Iff (@Or b c) (@Or (a -> b) (a -> c))) (@id (@Eq Prop (@Iff (a -> @Or b c) (@Or (a -> b) (a -> c))) (@Iff (@Or b c) (@Or (a -> b) (a -> c)))) (@congrArg Prop Prop (a -> @Or b c) (@Or b c) (fun (_a : Prop) => @Iff _a (@Or (a -> b) (a -> c))) (@propext (a -> @Or b c) (@Or b c) (@imp_iff_right (@Or b c) a h)))) (@Eq.mpr (@Iff (@Or b c) (@Or (a -> b) (a -> c))) (@Iff (@Or b c) (@Or b (a -> c))) (@id (@Eq Prop (@Iff (@Or b c) (@Or (a -> b) (a -> c))) (@Iff (@Or b c) (@Or b (a -> c)))) (@congrArg Prop Prop (a -> b) b (fun (_a : Prop) => @Iff (@Or b c) (@Or _a (a -> c))) (@propext (a -> b) b (@imp_iff_right b a h)))) (@Eq.mpr (@Iff (@Or b c) (@Or b (a -> c))) (@Iff (@Or b c) (@Or b c)) (@id (@Eq Prop (@Iff (@Or b c) (@Or b (a -> c))) (@Iff (@Or b c) (@Or b c))) (@congrArg Prop Prop (a -> c) c (fun (_a : Prop) => @Iff (@Or b c) (@Or b _a)) (@propext (a -> c) c (@imp_iff_right c a h)))) (@Iff.rfl (@Or b c))))) (fun (h : @Not a) => @Eq.mpr (@Iff (a -> @Or b c) (@Or (a -> b) (a -> c))) (@Iff (False -> @Or b c) (@Or (False -> b) (False -> c))) (@id (@Eq Prop (@Iff (a -> @Or b c) (@Or (a -> b) (a -> c))) (@Iff (False -> @Or b c) (@Or (False -> b) (False -> c)))) (@congrArg Prop Prop a False (fun (_a : Prop) => @Iff (_a -> @Or b c) (@Or (_a -> b) (_a -> c))) (@propext a False (@iff_false_intro a h)))) (@Eq.mpr (@Iff (False -> @Or b c) (@Or (False -> b) (False -> c))) (@Iff True (@Or (False -> b) (False -> c))) (@id (@Eq Prop (@Iff (False -> @Or b c) (@Or (False -> b) (False -> c))) (@Iff True (@Or (False -> b) (False -> c)))) (@congrArg Prop Prop (False -> @Or b c) True (fun (_a : Prop) => @Iff _a (@Or (False -> b) (False -> c))) (@propext (False -> @Or b c) True (@false_imp_iff (@Or b c))))) (@Eq.mpr (@Iff True (@Or (False -> b) (False -> c))) (@Iff True (@Or True (False -> c))) (@id (@Eq Prop (@Iff True (@Or (False -> b) (False -> c))) (@Iff True (@Or True (False -> c)))) (@congrArg Prop Prop (False -> b) True (fun (_a : Prop) => @Iff True (@Or _a (False -> c))) (@propext (False -> b) True (@false_imp_iff b)))) (@Eq.mpr (@Iff True (@Or True (False -> c))) (@Iff True True) (@id (@Eq Prop (@Iff True (@Or True (False -> c))) (@Iff True True)) (@congrArg Prop Prop (@Or True (False -> c)) True (fun (_a : Prop) => @Iff True _a) (@true_or (False -> c)))) (@Iff.rfl True)))))
theorem implies_true : (α : Sort u) -> @Eq Prop (α -> True) True :=
  fun (α : Sort u) => @eq_true (α -> True) (fun (_ : α) => trivial)
def false_or.match_1 : (p : Prop) -> (motive : @Or False p -> Prop) -> (x : @Or False p) -> ((h : p) -> motive (@Or.inr False p h)) -> motive x :=
  fun (p : Prop) => fun (motive : @Or False p -> Prop) => fun (x : @Or False p) => fun (h_1 : (h : p) -> motive (@Or.inr False p h)) => @Or.casesOn False p (fun (x1 : @Or False p) => motive x1) x (fun (h : False) => @False.casesOn (fun (x1 : False) => motive (@Or.inl False p x1)) h) (fun (h : p) => h_1 h)
theorem false_or : (p : Prop) -> @Eq Prop (@Or False p) p :=
  fun (p : Prop) => @propext (@Or False p) p (@Iff.intro (@Or False p) p (fun (x : @Or False p) => @false_or.match_1 p (fun (_ : @Or False p) => p) x (fun (h : p) => h)) (@Or.inr False p))
theorem Iff.symm : {a : Prop} -> {b : Prop} -> @Iff a b -> @Iff b a :=
  fun {a : Prop} => fun {b : Prop} => fun (h : @Iff a b) => @Iff.intro b a (@Iff.mpr a b h) (@Iff.mp a b h)
theorem or_iff_right_of_imp : {a : Prop} -> {b : Prop} -> (a -> b) -> @Iff (@Or a b) b :=
  fun {a : Prop} => fun {b : Prop} => fun (ha : a -> b) => @Iff.intro (@Or a b) b (fun (t : @Or a b) => @Or.rec a b (fun (_ : @Or a b) => b) ha (@id b) t) (@Or.inr a b)
theorem Decidable.imp_or' : {b : Prop} -> {a : Sort u_1} -> {c : Prop} -> @Decidable b -> @Iff (a -> @Or b c) (@Or (a -> b) (a -> c)) :=
  fun {b : Prop} => fun {a : Sort u_1} => fun {c : Prop} => fun (inst : @Decidable b) => @dite (@Iff (a -> @Or b c) (@Or (a -> b) (a -> c))) b inst (fun (h : b) => @of_eq_true (@Iff (a -> @Or b c) (@Or (a -> b) (a -> c))) (@Eq.trans Prop (@Iff (a -> @Or b c) (@Or (a -> b) (a -> c))) (@Iff True True) True (@congr Prop Prop (@Iff (a -> @Or b c)) (@Iff True) (@Or (a -> b) (a -> c)) True (@congrArg Prop (Prop -> Prop) (a -> @Or b c) True Iff (@Eq.trans Prop (a -> @Or b c) (a -> True) True (@implies_congr a a (@Or b c) True (@Eq.refl (Sort u_1) a) (@Eq.trans Prop (@Or b c) (@Or True c) True (@congrArg Prop Prop b True (fun (x : Prop) => @Or x c) (@eq_true b h)) (@true_or c))) (@implies_true a))) (@Eq.trans Prop (@Or (a -> b) (a -> c)) (@Or True (a -> c)) True (@congrArg Prop Prop (a -> b) True (fun (x : Prop) => @Or x (a -> c)) (@Eq.trans Prop (a -> b) (a -> True) True (@implies_congr a a b True (@Eq.refl (Sort u_1) a) (@eq_true b h)) (@implies_true a))) (@true_or (a -> c)))) (@iff_self True))) (fun (h : @Not b) => @Eq.mpr (@Iff (a -> @Or b c) (@Or (a -> b) (a -> c))) (@Iff (a -> @Or False c) (@Or (a -> False) (a -> c))) (@id (@Eq Prop (@Iff (a -> @Or b c) (@Or (a -> b) (a -> c))) (@Iff (a -> @Or False c) (@Or (a -> False) (a -> c)))) (@congrArg Prop Prop b False (fun (_a : Prop) => @Iff (a -> @Or _a c) (@Or (a -> _a) (a -> c))) (@eq_false b h))) (@Eq.mpr (@Iff (a -> @Or False c) (@Or (a -> False) (a -> c))) (@Iff (a -> c) (@Or (a -> False) (a -> c))) (@id (@Eq Prop (@Iff (a -> @Or False c) (@Or (a -> False) (a -> c))) (@Iff (a -> c) (@Or (a -> False) (a -> c)))) (@congrArg Prop Prop (@Or False c) c (fun (_a : Prop) => @Iff (a -> _a) (@Or (a -> False) (a -> c))) (@false_or c))) (@Iff.symm (@Or (a -> False) (a -> c)) (a -> c) (@or_iff_right_of_imp (a -> False) (a -> c) (fun (hx : a -> False) => fun (x : a) => @False.elim c (hx x))))))
theorem not_of_not_imp : {b : Prop} -> {a : Prop} -> @Not (a -> b) -> @Not b :=
  fun {b : Prop} => fun {a : Prop} => @mt b (a -> b) (fun (h : b) => fun (_ : a) => h)
theorem Decidable.not_imp_iff_and_not : {a : Prop} -> {b : Prop} -> @Decidable a -> @Iff (@Not (a -> b)) (@And a (@Not b)) :=
  fun {a : Prop} => fun {b : Prop} => fun (inst : @Decidable a) => @Iff.intro (@Not (a -> b)) (@And a (@Not b)) (fun (h : @Not (a -> b)) => @And.intro a (@Not b) (@Decidable.of_not_imp a b inst h) (@not_of_not_imp b a h)) (@not_imp_of_and_not a b)
theorem Decidable.peirce : (a : Prop) -> (b : Prop) -> @Decidable a -> ((a -> b) -> a) -> a :=
  fun (a : Prop) => fun (b : Prop) => fun (inst : @Decidable a) => @dite (((a -> b) -> a) -> a) a inst (fun (ha : a) => fun (_ : (a -> b) -> a) => ha) (fun (ha : @Not a) => fun (h : (a -> b) -> a) => h (@Not.elim a b ha))
theorem peirce' : {a : Prop} -> ((b : Prop) -> (a -> b) -> a) -> a :=
  fun {a : Prop} => fun (H : (b : Prop) -> (a -> b) -> a) => H a (@id a)
theorem iff_iff_implies_and_implies : {a : Prop} -> {b : Prop} -> @Iff (@Iff a b) (@And (a -> b) (b -> a)) :=
  fun {a : Prop} => fun {b : Prop} => @Iff.intro (@Iff a b) (@And (a -> b) (b -> a)) (fun (h : @Iff a b) => @And.intro (a -> b) (b -> a) (@Iff.mp a b h) (@Iff.mpr a b h)) (fun (h : @And (a -> b) (b -> a)) => @Iff.intro a b (@And.left (a -> b) (b -> a) h) (@And.right (a -> b) (b -> a) h))
theorem iff_def : {a : Prop} -> {b : Prop} -> @Iff (@Iff a b) (@And (a -> b) (b -> a)) :=
  fun {a : Prop} => fun {b : Prop} => @iff_iff_implies_and_implies a b
theorem iff_def' : {a : Prop} -> {b : Prop} -> @Iff (@Iff a b) (@And (b -> a) (a -> b)) :=
  fun {a : Prop} => fun {b : Prop} => @Iff.trans (@Iff a b) (@And (a -> b) (b -> a)) (@And (b -> a) (a -> b)) (@iff_def a b) (@And.comm (a -> b) (b -> a))
theorem Decidable.not_iff_not : {a : Prop} -> {b : Prop} -> @Decidable a -> @Decidable b -> @Iff (@Iff (@Not a) (@Not b)) (@Iff a b) :=
  fun {a : Prop} => fun {b : Prop} => fun (inst : @Decidable a) => fun (inst1 : @Decidable b) => @Eq.mpr (@Iff (@Iff (@Not a) (@Not b)) (@Iff a b)) (@Iff (@And (@Not a -> @Not b) (@Not b -> @Not a)) (@Iff a b)) (@id (@Eq Prop (@Iff (@Iff (@Not a) (@Not b)) (@Iff a b)) (@Iff (@And (@Not a -> @Not b) (@Not b -> @Not a)) (@Iff a b))) (@congrArg Prop Prop (@Iff (@Not a) (@Not b)) (@And (@Not a -> @Not b) (@Not b -> @Not a)) (fun (_a : Prop) => @Iff _a (@Iff a b)) (@propext (@Iff (@Not a) (@Not b)) (@And (@Not a -> @Not b) (@Not b -> @Not a)) (@iff_def (@Not a) (@Not b))))) (@Eq.mpr (@Iff (@And (@Not a -> @Not b) (@Not b -> @Not a)) (@Iff a b)) (@Iff (@And (@Not a -> @Not b) (@Not b -> @Not a)) (@And (b -> a) (a -> b))) (@id (@Eq Prop (@Iff (@And (@Not a -> @Not b) (@Not b -> @Not a)) (@Iff a b)) (@Iff (@And (@Not a -> @Not b) (@Not b -> @Not a)) (@And (b -> a) (a -> b)))) (@congrArg Prop Prop (@Iff a b) (@And (b -> a) (a -> b)) (fun (_a : Prop) => @Iff (@And (@Not a -> @Not b) (@Not b -> @Not a)) _a) (@propext (@Iff a b) (@And (b -> a) (a -> b)) (@iff_def' a b)))) (@and_congr (@Not a -> @Not b) (b -> a) (@Not b -> @Not a) (a -> b) (@Decidable.not_imp_not a b inst) (@Decidable.not_imp_not b a inst1)))
theorem Decidable.not_iff_comm : {a : Prop} -> {b : Prop} -> @Decidable a -> @Decidable b -> @Iff (@Iff (@Not a) b) (@Iff (@Not b) a) :=
  fun {a : Prop} => fun {b : Prop} => fun (inst : @Decidable a) => fun (inst1 : @Decidable b) => @Eq.mpr (@Iff (@Iff (@Not a) b) (@Iff (@Not b) a)) (@Iff (@And (@Not a -> b) (b -> @Not a)) (@Iff (@Not b) a)) (@id (@Eq Prop (@Iff (@Iff (@Not a) b) (@Iff (@Not b) a)) (@Iff (@And (@Not a -> b) (b -> @Not a)) (@Iff (@Not b) a))) (@congrArg Prop Prop (@Iff (@Not a) b) (@And (@Not a -> b) (b -> @Not a)) (fun (_a : Prop) => @Iff _a (@Iff (@Not b) a)) (@propext (@Iff (@Not a) b) (@And (@Not a -> b) (b -> @Not a)) (@iff_def (@Not a) b)))) (@Eq.mpr (@Iff (@And (@Not a -> b) (b -> @Not a)) (@Iff (@Not b) a)) (@Iff (@And (@Not a -> b) (b -> @Not a)) (@And (@Not b -> a) (a -> @Not b))) (@id (@Eq Prop (@Iff (@And (@Not a -> b) (b -> @Not a)) (@Iff (@Not b) a)) (@Iff (@And (@Not a -> b) (b -> @Not a)) (@And (@Not b -> a) (a -> @Not b)))) (@congrArg Prop Prop (@Iff (@Not b) a) (@And (@Not b -> a) (a -> @Not b)) (fun (_a : Prop) => @Iff (@And (@Not a -> b) (b -> @Not a)) _a) (@propext (@Iff (@Not b) a) (@And (@Not b -> a) (a -> @Not b)) (@iff_def (@Not b) a)))) (@and_congr (@Not a -> b) (@Not b -> a) (b -> @Not a) (a -> @Not b) (@Decidable.not_imp_comm a b inst inst1) (@imp_not_comm b a)))
theorem Iff.comm : {a : Prop} -> {b : Prop} -> @Iff (@Iff a b) (@Iff b a) :=
  fun {a : Prop} => fun {b : Prop} => @Iff.intro (@Iff a b) (@Iff b a) (@Iff.symm a b) (@Iff.symm b a)
theorem iff_true_left : {a : Prop} -> {b : Prop} -> a -> @Iff (@Iff a b) b :=
  fun {a : Prop} => fun {b : Prop} => fun (ha : a) => @Iff.intro (@Iff a b) b (fun (x : @Iff a b) => @Iff.mp a b x ha) (@iff_of_true a b ha)
theorem iff_true_right : {a : Prop} -> {b : Prop} -> a -> @Iff (@Iff b a) b :=
  fun {a : Prop} => fun {b : Prop} => fun (ha : a) => @Iff.trans (@Iff b a) (@Iff a b) b (@Iff.comm b a) (@iff_true_left a b ha)
theorem iff_false_left : {a : Prop} -> {b : Prop} -> @Not a -> @Iff (@Iff a b) (@Not b) :=
  fun {a : Prop} => fun {b : Prop} => fun (ha : @Not a) => @Iff.intro (@Iff a b) (@Not b) (fun (x : @Iff a b) => @mt b a (@Iff.mpr a b x) ha) (@iff_of_false a b ha)
theorem iff_false_right : {a : Prop} -> {b : Prop} -> @Not a -> @Iff (@Iff b a) (@Not b) :=
  fun {a : Prop} => fun {b : Prop} => fun (ha : @Not a) => @Iff.trans (@Iff b a) (@Iff a b) (@Not b) (@Iff.comm b a) (@iff_false_left a b ha)
theorem Decidable.not_iff : {b : Prop} -> {a : Prop} -> @Decidable b -> @Iff (@Not (@Iff a b)) (@Iff (@Not a) b) :=
  fun {b : Prop} => fun {a : Prop} => fun (inst : @Decidable b) => @dite (@Iff (@Not (@Iff a b)) (@Iff (@Not a) b)) b inst (fun (h : b) => @Eq.mpr (@Iff (@Not (@Iff a b)) (@Iff (@Not a) b)) (@Iff (@Not a) (@Iff (@Not a) b)) (@id (@Eq Prop (@Iff (@Not (@Iff a b)) (@Iff (@Not a) b)) (@Iff (@Not a) (@Iff (@Not a) b))) (@congrArg Prop Prop (@Iff a b) a (fun (_a : Prop) => @Iff (@Not _a) (@Iff (@Not a) b)) (@propext (@Iff a b) a (@iff_true_right b a h)))) (@Eq.mpr (@Iff (@Not a) (@Iff (@Not a) b)) (@Iff (@Not a) (@Not a)) (@id (@Eq Prop (@Iff (@Not a) (@Iff (@Not a) b)) (@Iff (@Not a) (@Not a))) (@congrArg Prop Prop (@Iff (@Not a) b) (@Not a) (fun (_a : Prop) => @Iff (@Not a) _a) (@propext (@Iff (@Not a) b) (@Not a) (@iff_true_right b (@Not a) h)))) (@Iff.rfl (@Not a)))) (fun (h : @Not b) => @Eq.mpr (@Iff (@Not (@Iff a b)) (@Iff (@Not a) b)) (@Iff (@Not (@Not a)) (@Iff (@Not a) b)) (@id (@Eq Prop (@Iff (@Not (@Iff a b)) (@Iff (@Not a) b)) (@Iff (@Not (@Not a)) (@Iff (@Not a) b))) (@congrArg Prop Prop (@Iff a b) (@Not a) (fun (_a : Prop) => @Iff (@Not _a) (@Iff (@Not a) b)) (@propext (@Iff a b) (@Not a) (@iff_false_right b a h)))) (@Eq.mpr (@Iff (@Not (@Not a)) (@Iff (@Not a) b)) (@Iff (@Not (@Not a)) (@Not (@Not a))) (@id (@Eq Prop (@Iff (@Not (@Not a)) (@Iff (@Not a) b)) (@Iff (@Not (@Not a)) (@Not (@Not a)))) (@congrArg Prop Prop (@Iff (@Not a) b) (@Not (@Not a)) (fun (_a : Prop) => @Iff (@Not (@Not a)) _a) (@propext (@Iff (@Not a) b) (@Not (@Not a)) (@iff_false_right b (@Not a) h)))) (@Iff.rfl (@Not (@Not a)))))
theorem Decidable.iff_not_comm : {a : Prop} -> {b : Prop} -> @Decidable a -> @Decidable b -> @Iff (@Iff a (@Not b)) (@Iff b (@Not a)) :=
  fun {a : Prop} => fun {b : Prop} => fun (inst : @Decidable a) => fun (inst1 : @Decidable b) => @Eq.mpr (@Iff (@Iff a (@Not b)) (@Iff b (@Not a))) (@Iff (@And (a -> @Not b) (@Not b -> a)) (@Iff b (@Not a))) (@id (@Eq Prop (@Iff (@Iff a (@Not b)) (@Iff b (@Not a))) (@Iff (@And (a -> @Not b) (@Not b -> a)) (@Iff b (@Not a)))) (@congrArg Prop Prop (@Iff a (@Not b)) (@And (a -> @Not b) (@Not b -> a)) (fun (_a : Prop) => @Iff _a (@Iff b (@Not a))) (@propext (@Iff a (@Not b)) (@And (a -> @Not b) (@Not b -> a)) (@iff_def a (@Not b))))) (@Eq.mpr (@Iff (@And (a -> @Not b) (@Not b -> a)) (@Iff b (@Not a))) (@Iff (@And (a -> @Not b) (@Not b -> a)) (@And (b -> @Not a) (@Not a -> b))) (@id (@Eq Prop (@Iff (@And (a -> @Not b) (@Not b -> a)) (@Iff b (@Not a))) (@Iff (@And (a -> @Not b) (@Not b -> a)) (@And (b -> @Not a) (@Not a -> b)))) (@congrArg Prop Prop (@Iff b (@Not a)) (@And (b -> @Not a) (@Not a -> b)) (fun (_a : Prop) => @Iff (@And (a -> @Not b) (@Not b -> a)) _a) (@propext (@Iff b (@Not a)) (@And (b -> @Not a) (@Not a -> b)) (@iff_def b (@Not a))))) (@and_congr (a -> @Not b) (b -> @Not a) (@Not b -> a) (@Not a -> b) (@imp_not_comm a b) (@Decidable.not_imp_comm b a inst1 inst)))
theorem Decidable.iff_iff_and_or_not_and_not : {a : Prop} -> {b : Prop} -> @Decidable b -> @Iff (@Iff a b) (@Or (@And a b) (@And (@Not a) (@Not b))) :=
  fun {a : Prop} => fun {b : Prop} => fun (inst : @Decidable b) => @Iff.intro (@Iff a b) (@Or (@And a b) (@And (@Not a) (@Not b))) (fun (e : @Iff a b) => @dite (@Or (@And a b) (@And (@Not a) (@Not b))) b inst (fun (h : b) => @Or.inl (@And a b) (@And (@Not a) (@Not b)) (@And.intro a b (@Iff.mpr a b e h) h)) (fun (h : @Not b) => @Or.inr (@And a b) (@And (@Not a) (@Not b)) (@And.intro (@Not a) (@Not b) (@mt a b (@Iff.mp a b e) h) h))) (fun (t : @Or (@And a b) (@And (@Not a) (@Not b))) => @Or.rec (@And a b) (@And (@Not a) (@Not b)) (fun (_ : @Or (@And a b) (@And (@Not a) (@Not b))) => @Iff a b) (fun (t1 : @And a b) => @And.rec a b (fun (_ : @And a b) => @Iff a b) (@iff_of_true a b) t1) (fun (t1 : @And (@Not a) (@Not b)) => @And.rec (@Not a) (@Not b) (fun (_ : @And (@Not a) (@Not b)) => @Iff a b) (@iff_of_false a b) t1) t)
theorem Init.PropLemmas._auxLemma_54 : {a : Prop} -> {b : Prop} -> @Decidable a -> @Eq Prop (a -> b) (@Or (@Not a) b) :=
  fun {a : Prop} => fun {b : Prop} => fun (inst : @Decidable a) => @propext (a -> b) (@Or (@Not a) b) (@Decidable.imp_iff_not_or a b inst)
theorem Decidable.iff_iff_not_or_and_or_not : {a : Prop} -> {b : Prop} -> @Decidable a -> @Decidable b -> @Iff (@Iff a b) (@And (@Or (@Not a) b) (@Or a (@Not b))) :=
  fun {a : Prop} => fun {b : Prop} => fun (inst : @Decidable a) => fun (inst1 : @Decidable b) => @Eq.mpr (@Iff (@Iff a b) (@And (@Or (@Not a) b) (@Or a (@Not b)))) (@Iff (@And (a -> b) (b -> a)) (@And (@Or (@Not a) b) (@Or a (@Not b)))) (@id (@Eq Prop (@Iff (@Iff a b) (@And (@Or (@Not a) b) (@Or a (@Not b)))) (@Iff (@And (a -> b) (b -> a)) (@And (@Or (@Not a) b) (@Or a (@Not b))))) (@congrArg Prop Prop (@Iff a b) (@And (a -> b) (b -> a)) (fun (_a : Prop) => @Iff _a (@And (@Or (@Not a) b) (@Or a (@Not b)))) (@propext (@Iff a b) (@And (a -> b) (b -> a)) (@iff_iff_implies_and_implies a b)))) (@of_eq_true (@Iff (@And (a -> b) (b -> a)) (@And (@Or (@Not a) b) (@Or a (@Not b)))) (@Eq.trans Prop (@Iff (@And (a -> b) (b -> a)) (@And (@Or (@Not a) b) (@Or a (@Not b)))) (@Iff (@And (@Or b (@Not a)) (@Or a (@Not b))) (@And (@Or b (@Not a)) (@Or a (@Not b)))) True (@congr Prop Prop (@Iff (@And (a -> b) (b -> a))) (@Iff (@And (@Or b (@Not a)) (@Or a (@Not b)))) (@And (@Or (@Not a) b) (@Or a (@Not b))) (@And (@Or b (@Not a)) (@Or a (@Not b))) (@congrArg Prop (Prop -> Prop) (@And (a -> b) (b -> a)) (@And (@Or b (@Not a)) (@Or a (@Not b))) Iff (@congr Prop Prop (@And (a -> b)) (@And (@Or b (@Not a))) (b -> a) (@Or a (@Not b)) (@congrArg Prop (Prop -> Prop) (a -> b) (@Or b (@Not a)) And (@Eq.trans Prop (a -> b) (@Or (@Not a) b) (@Or b (@Not a)) (@Init.PropLemmas._auxLemma_54 a b inst) (@Init.PropLemmas._auxLemma_3 (@Not a) b))) (@Eq.trans Prop (b -> a) (@Or (@Not b) a) (@Or a (@Not b)) (@Init.PropLemmas._auxLemma_54 b a inst1) (@Init.PropLemmas._auxLemma_3 (@Not b) a)))) (@congrArg Prop Prop (@Or (@Not a) b) (@Or b (@Not a)) (fun (x : Prop) => @And x (@Or a (@Not b))) (@Init.PropLemmas._auxLemma_3 (@Not a) b))) (@iff_self (@And (@Or b (@Not a)) (@Or a (@Not b))))))
def Decidable.not_and_not_right.match_1 : {b : Prop} -> {a : Prop} -> (motive : @And a (@Not b) -> Prop) -> (x : @And a (@Not b)) -> ((ha : a) -> (hb : @Not b) -> motive (@And.intro a (@Not b) ha hb)) -> motive x :=
  fun {b : Prop} => fun {a : Prop} => fun (motive : @And a (@Not b) -> Prop) => fun (x : @And a (@Not b)) => fun (h_1 : (ha : a) -> (hb : @Not b) -> motive (@And.intro a (@Not b) ha hb)) => @And.casesOn a (@Not b) (fun (x1 : @And a (@Not b)) => motive x1) x (fun (left : a) => fun (right : @Not b) => h_1 left right)
theorem Decidable.not_and_not_right : {b : Prop} -> {a : Prop} -> @Decidable b -> @Iff (@Not (@And a (@Not b))) (a -> b) :=
  fun {b : Prop} => fun {a : Prop} => fun (inst : @Decidable b) => @Iff.intro (@Not (@And a (@Not b))) (a -> b) (fun (h : @Not (@And a (@Not b))) => fun (ha : a) => @Decidable.not_imp_symm b (@And a (@Not b)) inst (@And.intro a (@Not b) ha) h) (fun (h : a -> b) => fun (x : @And a (@Not b)) => @Decidable.not_and_not_right.match_1 b a (fun (_ : @And a (@Not b)) => False) x (fun (ha : a) => fun (hb : @Not b) => hb (h ha)))
theorem Decidable.not_and_iff_or_not_not : {a : Prop} -> {b : Prop} -> @Decidable a -> @Iff (@Not (@And a b)) (@Or (@Not a) (@Not b)) :=
  fun {a : Prop} => fun {b : Prop} => fun (inst : @Decidable a) => @Iff.intro (@Not (@And a b)) (@Or (@Not a) (@Not b)) (fun (h : @Not (@And a b)) => @dite (@Or (@Not a) (@Not b)) a inst (fun (ha : a) => @Or.inr (@Not a) (@Not b) (fun (x : b) => h (@And.intro a b ha x))) (fun (ha : @Not a) => @Or.inl (@Not a) (@Not b) ha)) (@not_and_of_not_or_not a b)
theorem Decidable.not_and_iff_or_not_not' : {b : Prop} -> {a : Prop} -> @Decidable b -> @Iff (@Not (@And a b)) (@Or (@Not a) (@Not b)) :=
  fun {b : Prop} => fun {a : Prop} => fun (inst : @Decidable b) => @Iff.intro (@Not (@And a b)) (@Or (@Not a) (@Not b)) (fun (h : @Not (@And a b)) => @dite (@Or (@Not a) (@Not b)) b inst (fun (hb : b) => @Or.inl (@Not a) (@Not b) (fun (x : a) => h (@And.intro a b x hb))) (fun (hb : @Not b) => @Or.inr (@Not a) (@Not b) hb)) (@not_and_of_not_or_not a b)
theorem not_or : {p : Prop} -> {q : Prop} -> @Iff (@Not (@Or p q)) (@And (@Not p) (@Not q)) :=
  fun {p : Prop} => fun {q : Prop} => @or_imp p q False
theorem instDecidableOr.proof_1 : {p : Prop} -> {q : Prop} -> @Not p -> @Not q -> @Or p q -> False :=
  fun {p : Prop} => fun {q : Prop} => fun (hp : @Not p) => fun (hq : @Not q) => fun (h : @Or p q) => @Or.elim.match_1 p q (fun (_ : @Or p q) => False) h (fun (h1 : p) => hp h1) (fun (h1 : q) => hq h1)
def instDecidableOr : {p : Prop} -> {q : Prop} -> @Decidable p -> @Decidable q -> @Decidable (@Or p q) :=
  fun {p : Prop} => fun {q : Prop} => fun (dp : @Decidable p) => fun (dq : @Decidable q) => @instDecidableAnd.match_1 p (fun (_ : @Decidable p) => @Decidable (@Or p q)) dp (fun (hp : p) => @Decidable.isTrue (@Or p q) (@Or.inl p q hp)) (fun (hp : @Not p) => @instDecidableAnd.match_1 q (fun (_ : @Decidable q) => @Decidable (@Or p q)) dq (fun (hq : q) => @Decidable.isTrue (@Or p q) (@Or.inr p q hq)) (fun (hq : @Not q) => @Decidable.isFalse (@Or p q) (@instDecidableOr.proof_1 p q hp hq)))
theorem Decidable.or_iff_not_and_not : {a : Prop} -> {b : Prop} -> @Decidable a -> @Decidable b -> @Iff (@Or a b) (@Not (@And (@Not a) (@Not b))) :=
  fun {a : Prop} => fun {b : Prop} => fun (inst : @Decidable a) => fun (inst1 : @Decidable b) => @Eq.mpr (@Iff (@Or a b) (@Not (@And (@Not a) (@Not b)))) (@Iff (@Or a b) (@Not (@Not (@Or a b)))) (@id (@Eq Prop (@Iff (@Or a b) (@Not (@And (@Not a) (@Not b)))) (@Iff (@Or a b) (@Not (@Not (@Or a b))))) (@congrArg Prop Prop (@And (@Not a) (@Not b)) (@Not (@Or a b)) (fun (_a : Prop) => @Iff (@Or a b) (@Not _a)) (@Eq.symm Prop (@Not (@Or a b)) (@And (@Not a) (@Not b)) (@propext (@Not (@Or a b)) (@And (@Not a) (@Not b)) (@not_or a b))))) (@Eq.mpr (@Iff (@Or a b) (@Not (@Not (@Or a b)))) (@Iff (@Or a b) (@Or a b)) (@id (@Eq Prop (@Iff (@Or a b) (@Not (@Not (@Or a b)))) (@Iff (@Or a b) (@Or a b))) (@congrArg Prop Prop (@Not (@Not (@Or a b))) (@Or a b) (fun (_a : Prop) => @Iff (@Or a b) _a) (@propext (@Not (@Not (@Or a b))) (@Or a b) (@Decidable.not_not (@Or a b) (@instDecidableOr a b inst inst1))))) (@Iff.rfl (@Or a b)))
theorem instDecidableAnd.proof_1 : {p : Prop} -> {q : Prop} -> @Not q -> @And p q -> False :=
  fun {p : Prop} => fun {q : Prop} => fun (hq : @Not q) => fun (h : @And p q) => hq (@And.right p q h)
theorem instDecidableAnd.proof_2 : {p : Prop} -> {q : Prop} -> @Not p -> @And p q -> False :=
  fun {p : Prop} => fun {q : Prop} => fun (hp : @Not p) => fun (h : @And p q) => hp (@And.left p q h)
def instDecidableAnd : {p : Prop} -> {q : Prop} -> @Decidable p -> @Decidable q -> @Decidable (@And p q) :=
  fun {p : Prop} => fun {q : Prop} => fun (dp : @Decidable p) => fun (dq : @Decidable q) => @instDecidableAnd.match_1 p (fun (_ : @Decidable p) => @Decidable (@And p q)) dp (fun (hp : p) => @instDecidableAnd.match_1 q (fun (_ : @Decidable q) => @Decidable (@And p q)) dq (fun (hq : q) => @Decidable.isTrue (@And p q) (@And.intro p q hp hq)) (fun (hq : @Not q) => @Decidable.isFalse (@And p q) (@instDecidableAnd.proof_1 p q hq))) (fun (hp : @Not p) => @Decidable.isFalse (@And p q) (@instDecidableAnd.proof_2 p q hp))
theorem Decidable.and_iff_not_or_not : {a : Prop} -> {b : Prop} -> @Decidable a -> @Decidable b -> @Iff (@And a b) (@Not (@Or (@Not a) (@Not b))) :=
  fun {a : Prop} => fun {b : Prop} => fun (inst : @Decidable a) => fun (inst1 : @Decidable b) => @Eq.mpr (@Iff (@And a b) (@Not (@Or (@Not a) (@Not b)))) (@Iff (@And a b) (@Not (@Not (@And a b)))) (@id (@Eq Prop (@Iff (@And a b) (@Not (@Or (@Not a) (@Not b)))) (@Iff (@And a b) (@Not (@Not (@And a b))))) (@congrArg Prop Prop (@Or (@Not a) (@Not b)) (@Not (@And a b)) (fun (_a : Prop) => @Iff (@And a b) (@Not _a)) (@Eq.symm Prop (@Not (@And a b)) (@Or (@Not a) (@Not b)) (@propext (@Not (@And a b)) (@Or (@Not a) (@Not b)) (@Decidable.not_and_iff_or_not_not a b inst))))) (@Eq.mpr (@Iff (@And a b) (@Not (@Not (@And a b)))) (@Iff (@And a b) (@And a b)) (@id (@Eq Prop (@Iff (@And a b) (@Not (@Not (@And a b)))) (@Iff (@And a b) (@And a b))) (@congrArg Prop Prop (@Not (@Not (@And a b))) (@And a b) (fun (_a : Prop) => @Iff (@And a b) _a) (@propext (@Not (@Not (@And a b))) (@And a b) (@Decidable.not_not (@And a b) (@instDecidableAnd a b inst inst1))))) (@Iff.rfl (@And a b)))
theorem Decidable.imp_iff_right_iff : {a : Prop} -> {b : Prop} -> @Decidable a -> @Iff (@Iff (a -> b) b) (@Or a b) :=
  fun {a : Prop} => fun {b : Prop} => fun (inst : @Decidable a) => @Iff.intro (@Iff (a -> b) b) (@Or a b) (fun (h : @Iff (a -> b) b) => @Or.imp_right (@Not a) b a (fun (ha' : @Not a) => @Iff.mp (a -> b) b h (fun (ha : a) => @False.elim b (ha' ha))) (@Decidable.em a inst)) (fun (ab : @Or a b) => @Or.elim a b (@Iff (a -> b) b) ab (@imp_iff_right b a) (fun (hb : b) => @iff_of_true (a -> b) b (fun (_ : a) => hb) hb))
theorem Decidable.imp_iff_left_iff : {a : Prop} -> {b : Prop} -> @Decidable a -> @Iff (@Iff b (a -> b)) (@Or a b) :=
  fun {a : Prop} => fun {b : Prop} => fun (inst : @Decidable a) => @Eq.rec Prop (@Iff (a -> b) b) (fun (x : Prop) => fun (_ : @Eq Prop (@Iff (a -> b) b) x) => @Iff x (@Or a b)) (@Decidable.imp_iff_right_iff a b inst) (@Iff b (a -> b)) (@propext (@Iff (a -> b) b) (@Iff b (a -> b)) (@Iff.comm (a -> b) b))
theorem true_imp_iff : {α : Prop} -> @Iff (True -> α) α :=
  fun {α : Prop} => @imp_iff_right α True True.intro
theorem Init.PropLemmas._auxLemma_55 : {α : Prop} -> @Eq Prop (True -> α) α :=
  fun {α : Prop} => @propext (True -> α) α (@true_imp_iff α)
theorem Init.PropLemmas._auxLemma_56 : (a : Prop) -> @Eq Prop (False -> a) True :=
  fun (a : Prop) => @propext (False -> a) True (@false_imp_iff a)
theorem Decidable.and_or_imp : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Decidable a -> @Iff (@Or (@And a b) (a -> c)) (a -> @Or b c) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (inst : @Decidable a) => @dite (@Iff (@Or (@And a b) (a -> c)) (a -> @Or b c)) a inst (fun (ha : a) => @of_eq_true (@Iff (@Or (@And a b) (a -> c)) (a -> @Or b c)) (@Eq.trans Prop (@Iff (@Or (@And a b) (a -> c)) (a -> @Or b c)) (@Iff (@Or b c) (@Or b c)) True (@congr Prop Prop (@Iff (@Or (@And a b) (a -> c))) (@Iff (@Or b c)) (a -> @Or b c) (@Or b c) (@congrArg Prop (Prop -> Prop) (@Or (@And a b) (a -> c)) (@Or b c) Iff (@congr Prop Prop (@Or (@And a b)) (@Or b) (a -> c) c (@congrArg Prop (Prop -> Prop) (@And a b) b Or (@Eq.trans Prop (@And a b) (@And True b) b (@congrArg Prop Prop a True (fun (x : Prop) => @And x b) (@eq_true a ha)) (@true_and b))) (@Eq.trans Prop (a -> c) (True -> c) c (@implies_congr a True c c (@eq_true a ha) (@Eq.refl Prop c)) (@Init.PropLemmas._auxLemma_55 c)))) (@Eq.trans Prop (a -> @Or b c) (True -> @Or b c) (@Or b c) (@implies_congr a True (@Or b c) (@Or b c) (@eq_true a ha) (@Eq.refl Prop (@Or b c))) (@Init.PropLemmas._auxLemma_55 (@Or b c)))) (@iff_self (@Or b c)))) (fun (ha : @Not a) => @of_eq_true (@Iff (@Or (@And a b) (a -> c)) (a -> @Or b c)) (@Eq.trans Prop (@Iff (@Or (@And a b) (a -> c)) (a -> @Or b c)) (@Iff True True) True (@congr Prop Prop (@Iff (@Or (@And a b) (a -> c))) (@Iff True) (a -> @Or b c) True (@congrArg Prop (Prop -> Prop) (@Or (@And a b) (a -> c)) True Iff (@Eq.trans Prop (@Or (@And a b) (a -> c)) (@Or False True) True (@congr Prop Prop (@Or (@And a b)) (@Or False) (a -> c) True (@congrArg Prop (Prop -> Prop) (@And a b) False Or (@Eq.trans Prop (@And a b) (@And False b) False (@congrArg Prop Prop a False (fun (x : Prop) => @And x b) (@eq_false a ha)) (@false_and b))) (@Eq.trans Prop (a -> c) (False -> c) True (@implies_congr a False c c (@eq_false a ha) (@Eq.refl Prop c)) (@Init.PropLemmas._auxLemma_56 c))) (@false_or True))) (@Eq.trans Prop (a -> @Or b c) (False -> @Or b c) True (@implies_congr a False (@Or b c) (@Or b c) (@eq_false a ha) (@Eq.refl Prop (@Or b c))) (@Init.PropLemmas._auxLemma_56 (@Or b c)))) (@iff_self True)))
theorem imp_congr_right : {a : Prop} -> {b : Prop} -> {c : Prop} -> (a -> @Iff b c) -> @Iff (a -> b) (a -> c) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (h : a -> @Iff b c) => @Iff.intro (a -> b) (a -> c) (fun (hab : a -> b) => fun (ha : a) => @Iff.mp b c (h ha) (hab ha)) (fun (hcd : a -> c) => fun (ha : a) => @Iff.mpr b c (h ha) (hcd ha))
theorem Decidable.or_congr_left' : {c : Prop} -> {a : Prop} -> {b : Prop} -> @Decidable c -> (@Not c -> @Iff a b) -> @Iff (@Or a c) (@Or b c) :=
  fun {c : Prop} => fun {a : Prop} => fun {b : Prop} => fun (inst : @Decidable c) => fun (h : @Not c -> @Iff a b) => @Eq.mpr (@Iff (@Or a c) (@Or b c)) (@Iff (@Not c -> a) (@Or b c)) (@id (@Eq Prop (@Iff (@Or a c) (@Or b c)) (@Iff (@Not c -> a) (@Or b c))) (@congrArg Prop Prop (@Or a c) (@Not c -> a) (fun (_a : Prop) => @Iff _a (@Or b c)) (@propext (@Or a c) (@Not c -> a) (@Decidable.or_iff_not_imp_right c a inst)))) (@Eq.mpr (@Iff (@Not c -> a) (@Or b c)) (@Iff (@Not c -> a) (@Not c -> b)) (@id (@Eq Prop (@Iff (@Not c -> a) (@Or b c)) (@Iff (@Not c -> a) (@Not c -> b))) (@congrArg Prop Prop (@Or b c) (@Not c -> b) (fun (_a : Prop) => @Iff (@Not c -> a) _a) (@propext (@Or b c) (@Not c -> b) (@Decidable.or_iff_not_imp_right c b inst)))) (@imp_congr_right (@Not c) a b h))
theorem Decidable.or_congr_right' : {a : Prop} -> {b : Prop} -> {c : Prop} -> @Decidable a -> (@Not a -> @Iff b c) -> @Iff (@Or a b) (@Or a c) :=
  fun {a : Prop} => fun {b : Prop} => fun {c : Prop} => fun (inst : @Decidable a) => fun (h : @Not a -> @Iff b c) => @Eq.mpr (@Iff (@Or a b) (@Or a c)) (@Iff (@Not a -> b) (@Or a c)) (@id (@Eq Prop (@Iff (@Or a b) (@Or a c)) (@Iff (@Not a -> b) (@Or a c))) (@congrArg Prop Prop (@Or a b) (@Not a -> b) (fun (_a : Prop) => @Iff _a (@Or a c)) (@propext (@Or a b) (@Not a -> b) (@Decidable.or_iff_not_imp_left a b inst)))) (@Eq.mpr (@Iff (@Not a -> b) (@Or a c)) (@Iff (@Not a -> b) (@Not a -> c)) (@id (@Eq Prop (@Iff (@Not a -> b) (@Or a c)) (@Iff (@Not a -> b) (@Not a -> c))) (@congrArg Prop Prop (@Or a c) (@Not a -> c) (fun (_a : Prop) => @Iff (@Not a -> b) _a) (@propext (@Or a c) (@Not a -> c) (@Decidable.or_iff_not_imp_left a c inst)))) (@imp_congr_right (@Not a) b c h))
def decidable_of_bool.match_1 : {a : Prop} -> (motive : (x : Bool) -> @Iff (@Eq Bool x Bool.true) a -> Sort u_1) -> (x : Bool) -> (x1 : @Iff (@Eq Bool x Bool.true) a) -> ((h : @Iff (@Eq Bool Bool.true Bool.true) a) -> motive Bool.true h) -> ((h : @Iff (@Eq Bool Bool.false Bool.true) a) -> motive Bool.false h) -> motive x x1 :=
  fun {a : Prop} => fun (motive : (x : Bool) -> @Iff (@Eq Bool x Bool.true) a -> Sort u_1) => fun (x : Bool) => fun (x1 : @Iff (@Eq Bool x Bool.true) a) => fun (h_1 : (h : @Iff (@Eq Bool Bool.true Bool.true) a) -> motive Bool.true h) => fun (h_2 : (h : @Iff (@Eq Bool Bool.false Bool.true) a) -> motive Bool.false h) => @Bool.casesOn (fun (x2 : Bool) => (x3 : @Iff (@Eq Bool x2 Bool.true) a) -> motive x2 x3) x (fun (x2 : @Iff (@Eq Bool Bool.false Bool.true) a) => h_2 x2) (fun (x2 : @Iff (@Eq Bool Bool.true Bool.true) a) => h_1 x2) x1
theorem decidable_of_bool.proof_1 : {a : Prop} -> @Iff (@Eq Bool Bool.true Bool.true) a -> a :=
  fun {a : Prop} => fun (h : @Iff (@Eq Bool Bool.true Bool.true) a) => @Iff.mp (@Eq Bool Bool.true Bool.true) a h (@rfl Bool Bool.true)
theorem decidable_of_bool.proof_2 : {a : Prop} -> @Iff (@Eq Bool Bool.false Bool.true) a -> @Not a :=
  fun {a : Prop} => fun (h : @Iff (@Eq Bool Bool.false Bool.true) a) => @mt a (@Eq Bool Bool.false Bool.true) (@Iff.mpr (@Eq Bool Bool.false Bool.true) a h) (@Bool.noConfusion False Bool.false Bool.true)
def decidable_of_bool : {a : Prop} -> (b : Bool) -> @Iff (@Eq Bool b Bool.true) a -> @Decidable a :=
  fun {a : Prop} => fun (x : Bool) => fun (x1 : @Iff (@Eq Bool x Bool.true) a) => @decidable_of_bool.match_1 a (fun (x2 : Bool) => fun (_ : @Iff (@Eq Bool x2 Bool.true) a) => @Decidable a) x x1 (fun (h : @Iff (@Eq Bool Bool.true Bool.true) a) => @Decidable.isTrue a (@decidable_of_bool.proof_1 a h)) (fun (h : @Iff (@Eq Bool Bool.false Bool.true) a) => @Decidable.isFalse a (@decidable_of_bool.proof_2 a h))
theorem Eq.mpr_prop : {p : Prop} -> {q : Prop} -> @Eq Prop p q -> q -> p :=
  fun {p : Prop} => fun {q : Prop} => fun (h₁ : @Eq Prop p q) => fun (h₂ : q) => @Eq.rec Prop q (fun (x : Prop) => fun (_ : @Eq Prop q x) => x) h₂ p (@Eq.symm Prop p q h₁)
theorem Eq.mpr_not : {p : Prop} -> {q : Prop} -> @Eq Prop p q -> @Not q -> @Not p :=
  fun {p : Prop} => fun {q : Prop} => fun (h₁ : @Eq Prop p q) => fun (h₂ : @Not q) => @Eq.rec Prop q (fun (x : Prop) => fun (_ : @Eq Prop q x) => @Not x) h₂ p (@Eq.symm Prop p q h₁)
theorem dif_pos : {c : Prop} -> {h : @Decidable c} -> (hc : c) -> {α : Sort u} -> {t : c -> α} -> {e : @Not c -> α} -> @Eq α (@dite α c h t e) (t hc) :=
  fun {c : Prop} => fun {h : @Decidable c} => fun (hc : c) => fun {α : Sort u} => fun {t : c -> α} => fun {e : @Not c -> α} => @if_pos.match_1 c (fun (h1 : @Decidable c) => @Eq α (@dite α c h1 t e) (t hc)) h (fun (h1 : c) => @rfl α (@dite α c (@Decidable.isTrue c h1) t e)) (fun (hnc : @Not c) => @absurd c (@Eq α (@dite α c (@Decidable.isFalse c hnc) t e) (t hc)) hc hnc)
theorem dif_neg : {c : Prop} -> {h : @Decidable c} -> (hnc : @Not c) -> {α : Sort u} -> {t : c -> α} -> {e : @Not c -> α} -> @Eq α (@dite α c h t e) (e hnc) :=
  fun {c : Prop} => fun {h : @Decidable c} => fun (hnc : @Not c) => fun {α : Sort u} => fun {t : c -> α} => fun {e : @Not c -> α} => @if_pos.match_1 c (fun (h1 : @Decidable c) => @Eq α (@dite α c h1 t e) (e hnc)) h (fun (hc : c) => @absurd c (@Eq α (@dite α c (@Decidable.isTrue c hc) t e) (e hnc)) hc hnc) (fun (h1 : @Not c) => @rfl α (@dite α c (@Decidable.isFalse c h1) t e))
theorem dite_congr : {b : Prop} -> {c : Prop} -> {α : Sort u_1} -> {x : @Decidable b} -> (inst : @Decidable c) -> {x1 : b -> α} -> {u : c -> α} -> {y : @Not b -> α} -> {v : @Not c -> α} -> (h₁ : @Eq Prop b c) -> ((h : c) -> @Eq α (x1 (@Eq.mpr_prop b c h₁ h)) (u h)) -> ((h : @Not c) -> @Eq α (y (@Eq.mpr_not b c h₁ h)) (v h)) -> @Eq α (@dite α b x x1 y) (@dite α c inst u v) :=
  fun {b : Prop} => fun {c : Prop} => fun {α : Sort u_1} => fun {x : @Decidable b} => fun (inst : @Decidable c) => fun {x1 : b -> α} => fun {u : c -> α} => fun {y : @Not b -> α} => fun {v : @Not c -> α} => fun (h₁ : @Eq Prop b c) => fun (h₂ : (h : c) -> @Eq α (x1 (@Eq.mpr_prop b c h₁ h)) (u h)) => fun (h₃ : (h : @Not c) -> @Eq α (y (@Eq.mpr_not b c h₁ h)) (v h)) => @Or.casesOn c (@Not c) (fun (t : @Or c (@Not c)) => @Eq (@Or c (@Not c)) (@Decidable.em c inst) t -> @Eq α (@dite α b x x1 y) (@dite α c inst u v)) (@Decidable.em c inst) (fun (h : c) => fun (_ : @Eq (@Or c (@Not c)) (@Decidable.em c inst) (@Or.inl c (@Not c) h)) => @Eq.mpr (@Eq α (@dite α b x x1 y) (@dite α c inst u v)) (@Eq α (@dite α b x x1 y) (u h)) (@id (@Eq Prop (@Eq α (@dite α b x x1 y) (@dite α c inst u v)) (@Eq α (@dite α b x x1 y) (u h))) (@congrArg α Prop (@dite α c inst u v) (u h) (fun (_a : α) => @Eq α (@dite α b x x1 y) _a) (@dif_pos c inst h α u v))) (@Eq.rec Prop c (fun {b1 : Prop} => fun (_h : @Eq Prop c b1) => {x2 : @Decidable b1} -> {x3 : b1 -> α} -> {y1 : @Not b1 -> α} -> ((h2 : c) -> @Eq α (x3 (@Eq.mpr_prop b1 c (@Eq.symm Prop c b1 _h) h2)) (u h2)) -> ((h2 : @Not c) -> @Eq α (y1 (@Eq.mpr_not b1 c (@Eq.symm Prop c b1 _h) h2)) (v h2)) -> @Eq α (@dite α b1 x2 x3 y1) (u h)) (fun {x2 : @Decidable c} => fun {x3 : c -> α} => fun {y1 : @Not c -> α} => fun (h₂1 : (h2 : c) -> @Eq α (x3 (@Eq.mpr_prop c c (@Eq.refl Prop c) h2)) (u h2)) => fun (_ : (h2 : @Not c) -> @Eq α (y1 (@Eq.mpr_not c c (@Eq.refl Prop c) h2)) (v h2)) => @Eq.mpr (@Eq α (@dite α c x2 x3 y1) (u h)) (@Eq α (x3 h) (u h)) (@id (@Eq Prop (@Eq α (@dite α c x2 x3 y1) (u h)) (@Eq α (x3 h) (u h))) (@congrArg α Prop (@dite α c x2 x3 y1) (x3 h) (fun (_a : α) => @Eq α _a (u h)) (@dif_pos c x2 h α x3 y1))) (h₂1 h)) b (@Eq.symm Prop b c h₁) x x1 y h₂ h₃)) (fun (h : @Not c) => fun (_ : @Eq (@Or c (@Not c)) (@Decidable.em c inst) (@Or.inr c (@Not c) h)) => @Eq.mpr (@Eq α (@dite α b x x1 y) (@dite α c inst u v)) (@Eq α (@dite α b x x1 y) (v h)) (@id (@Eq Prop (@Eq α (@dite α b x x1 y) (@dite α c inst u v)) (@Eq α (@dite α b x x1 y) (v h))) (@congrArg α Prop (@dite α c inst u v) (v h) (fun (_a : α) => @Eq α (@dite α b x x1 y) _a) (@dif_neg c inst h α u v))) (@Eq.rec Prop c (fun {b1 : Prop} => fun (_h : @Eq Prop c b1) => {x2 : @Decidable b1} -> {x3 : b1 -> α} -> {y1 : @Not b1 -> α} -> ((h2 : c) -> @Eq α (x3 (@Eq.mpr_prop b1 c (@Eq.symm Prop c b1 _h) h2)) (u h2)) -> ((h2 : @Not c) -> @Eq α (y1 (@Eq.mpr_not b1 c (@Eq.symm Prop c b1 _h) h2)) (v h2)) -> @Eq α (@dite α b1 x2 x3 y1) (v h)) (fun {x2 : @Decidable c} => fun {x3 : c -> α} => fun {y1 : @Not c -> α} => fun (_ : (h2 : c) -> @Eq α (x3 (@Eq.mpr_prop c c (@Eq.refl Prop c) h2)) (u h2)) => fun (h₃1 : (h2 : @Not c) -> @Eq α (y1 (@Eq.mpr_not c c (@Eq.refl Prop c) h2)) (v h2)) => @Eq.mpr (@Eq α (@dite α c x2 x3 y1) (v h)) (@Eq α (y1 h) (v h)) (@id (@Eq Prop (@Eq α (@dite α c x2 x3 y1) (v h)) (@Eq α (y1 h) (v h))) (@congrArg α Prop (@dite α c x2 x3 y1) (y1 h) (fun (_a : α) => @Eq α _a (v h)) (@dif_neg c x2 h α x3 y1))) (h₃1 h)) b (@Eq.symm Prop b c h₁) x x1 y h₂ h₃)) (@Eq.refl (@Or c (@Not c)) (@Decidable.em c inst))
theorem dite_cond_eq_true : {α : Sort u} -> {c : Prop} -> {x : @Decidable c} -> {t : c -> α} -> {e : @Not c -> α} -> (h : @Eq Prop c True) -> @Eq α (@dite α c x t e) (t (@of_eq_true c h)) :=
  fun {α : Sort u} => fun {c : Prop} => fun {x : @Decidable c} => fun {t : c -> α} => fun {e : @Not c -> α} => fun (h : @Eq Prop c True) => @of_eq_true (@Eq α (@dite α c x t e) (t (@of_eq_true c h))) (@Eq.trans Prop (@Eq α (@dite α c x t e) (t (@of_eq_true c h))) (@Eq α (@dite α True instDecidableTrue (fun (h1 : True) => t (@Eq.mpr_prop c True h h1)) (fun (h1 : @Not True) => e (@Eq.mpr_not c True h h1))) (t (@of_eq_true c h))) True (@congrArg α Prop (@dite α c x t e) (@dite α True instDecidableTrue (fun (h1 : True) => t (@Eq.mpr_prop c True h h1)) (fun (h1 : @Not True) => e (@Eq.mpr_not c True h h1))) (fun (x1 : α) => @Eq α x1 (t (@of_eq_true c h))) (@dite_congr c True α x instDecidableTrue t (fun (h1 : True) => t (@Eq.mpr_prop c True h h1)) e (fun (h1 : @Not True) => e (@Eq.mpr_not c True h h1)) h (fun (h1 : True) => @Eq.refl α (t (@Eq.mpr_prop c True h h1))) (fun (h1 : @Not True) => @Eq.refl α (e (@Eq.mpr_not c True h h1))))) (@eq_self α (t (@Eq.mpr_prop c True h True.intro))))
inductive Subsingleton : Sort u -> Prop where
  | intro : {α : Sort u} -> ((a : α) -> (b : α) -> @Eq α a b) -> @Subsingleton α
axiom Subsingleton.allEq : {α : Sort u} -> @Subsingleton α -> (a : α) -> (b : α) -> @Eq α a b
theorem Subsingleton.elim : {α : Sort u} -> @Subsingleton α -> (a : α) -> (b : α) -> @Eq α a b :=
  fun {α : Sort u} => fun (h : @Subsingleton α) => @Subsingleton.allEq α h
-- ctor Subsingleton.intro : {α : Sort u} -> ((a : α) -> (b : α) -> @Eq α a b) -> @Subsingleton α
theorem instSubsingletonDecidable : (p : Prop) -> @Subsingleton (@Decidable p) :=
  fun (p : Prop) => @Subsingleton.intro (@Decidable p) (fun (x : @Decidable p) => @if_pos.match_1 p (fun (x1 : @Decidable p) => (b : @Decidable p) -> @Eq (@Decidable p) x1 b) x (fun (t₁ : p) => fun (x1 : @Decidable p) => @if_pos.match_1 p (fun (x2 : @Decidable p) => @Eq (@Decidable p) (@Decidable.isTrue p t₁) x2) x1 (fun (_ : p) => @rfl (@Decidable p) (@Decidable.isTrue p t₁)) (fun (f₂ : @Not p) => @absurd p (@Eq (@Decidable p) (@Decidable.isTrue p t₁) (@Decidable.isFalse p f₂)) t₁ f₂)) (fun (f₁ : @Not p) => fun (x1 : @Decidable p) => @if_pos.match_1 p (fun (x2 : @Decidable p) => @Eq (@Decidable p) (@Decidable.isFalse p f₁) x2) x1 (fun (t₂ : p) => @absurd p (@Eq (@Decidable p) (@Decidable.isFalse p f₁) (@Decidable.isTrue p t₂)) t₂ f₁) (fun (_ : @Not p) => @rfl (@Decidable p) (@Decidable.isFalse p f₁))))
theorem decide_eq_decide : {p : Prop} -> {q : Prop} -> {x : @Decidable p} -> {x1 : @Decidable q} -> @Iff (@Eq Bool (@Decidable.decide p x) (@Decidable.decide q x1)) (@Iff p q) :=
  fun {p : Prop} => fun {q : Prop} => fun {x : @Decidable p} => fun {x1 : @Decidable q} => @Iff.intro (@Eq Bool (@Decidable.decide p x) (@Decidable.decide q x1)) (@Iff p q) (fun (h : @Eq Bool (@Decidable.decide p x) (@Decidable.decide q x1)) => @Eq.mpr (@Iff p q) (@Iff (@Eq Bool (@Decidable.decide p x) Bool.true) q) (@id (@Eq Prop (@Iff p q) (@Iff (@Eq Bool (@Decidable.decide p x) Bool.true) q)) (@congrArg Prop Prop p (@Eq Bool (@Decidable.decide p x) Bool.true) (fun (_a : Prop) => @Iff _a q) (@Eq.symm Prop (@Eq Bool (@Decidable.decide p x) Bool.true) p (@propext (@Eq Bool (@Decidable.decide p x) Bool.true) p (@decide_eq_true_iff p x))))) (@Eq.mpr (@Iff (@Eq Bool (@Decidable.decide p x) Bool.true) q) (@Iff (@Eq Bool (@Decidable.decide q x1) Bool.true) q) (@id (@Eq Prop (@Iff (@Eq Bool (@Decidable.decide p x) Bool.true) q) (@Iff (@Eq Bool (@Decidable.decide q x1) Bool.true) q)) (@congrArg Bool Prop (@Decidable.decide p x) (@Decidable.decide q x1) (fun (_a : Bool) => @Iff (@Eq Bool _a Bool.true) q) h)) (@Eq.mpr (@Iff (@Eq Bool (@Decidable.decide q x1) Bool.true) q) (@Iff q q) (@id (@Eq Prop (@Iff (@Eq Bool (@Decidable.decide q x1) Bool.true) q) (@Iff q q)) (@congrArg Prop Prop (@Eq Bool (@Decidable.decide q x1) Bool.true) q (fun (_a : Prop) => @Iff _a q) (@propext (@Eq Bool (@Decidable.decide q x1) Bool.true) q (@decide_eq_true_iff q x1)))) (@Iff.rfl q)))) (fun (h : @Iff p q) => @of_eq_true (@Eq Bool (@Decidable.decide p x) (@Decidable.decide q x1)) (@Eq.trans Prop (@Eq Bool (@Decidable.decide p x) (@Decidable.decide q x1)) (@Eq Bool (@Decidable.decide q x1) (@Decidable.decide q x1)) True (@congrArg Bool Prop (@Decidable.decide p x) (@Decidable.decide q x1) (fun (x2 : Bool) => @Eq Bool x2 (@Decidable.decide q x1)) ((fun (p1 : Prop) => fun (p2 : Prop) => fun (e_p : @Eq Prop p1 p2) => @Eq.rec Prop p1 (fun (p3 : Prop) => fun (_ : @Eq Prop p1 p3) => {h1 : @Decidable p1} -> (h2 : @Decidable p3) -> @Eq Bool (@Decidable.decide p1 h1) (@Decidable.decide p3 h2)) (fun {h1 : @Decidable p1} => fun (h2 : @Decidable p1) => @Eq.ndrec (@Decidable p1) h1 (fun (h3 : @Decidable p1) => @Eq Bool (@Decidable.decide p1 h1) (@Decidable.decide p1 h3)) (@Eq.refl Bool (@Decidable.decide p1 h1)) h2 (@Subsingleton.elim (@Decidable p1) (@instSubsingletonDecidable p1) h1 h2)) p2 e_p) p q (@propext p q h) x x1)) (@eq_self Bool (@Decidable.decide q x1))))
theorem Init.PropLemmas._auxLemma_53 : {p : Prop} -> {q : Prop} -> {x : @Decidable p} -> {x1 : @Decidable q} -> @Eq Prop (@Eq Bool (@Decidable.decide p x) (@Decidable.decide q x1)) (@Iff p q) :=
  fun {p : Prop} => fun {q : Prop} => fun {x : @Decidable p} => fun {x1 : @Decidable q} => @propext (@Eq Bool (@Decidable.decide p x) (@Decidable.decide q x1)) (@Iff p q) (@decide_eq_decide p q x x1)
theorem Init.PropLemmas._auxLemma_20 : {b : Prop} -> (α : Sort u_1) -> @Nonempty α -> @Eq Prop (α -> b) b :=
  fun {b : Prop} => fun (α : Sort u_1) => fun (i : @Nonempty α) => @propext (α -> b) b (@forall_const b α i)
inductive Inhabited : Sort u -> Sort (max (0 + 1) u) where
  | mk : {α : Sort u} -> α -> @Inhabited α
def Inhabited.default : {α : Sort u} -> @Inhabited α -> α :=
  fun (α : Sort u) => fun (self : @Inhabited α) => self.0
theorem instNonemptyOfInhabited : {α : Sort u} -> @Inhabited α -> @Nonempty α :=
  fun {α : Sort u} => fun (inst : @Inhabited α) => @Nonempty.intro α (@Inhabited.default α inst)
-- ctor Inhabited.mk : {α : Sort u} -> α -> @Inhabited α
def instInhabitedTrue : @Inhabited True :=
  @Inhabited.mk True True.intro
def decide_true.match_1 : (motive : @Decidable True -> Prop) -> (h : @Decidable True) -> ((h1 : True) -> motive (@Decidable.isTrue True h1)) -> ((h1 : @Not True) -> motive (@Decidable.isFalse True h1)) -> motive h :=
  fun (motive : @Decidable True -> Prop) => fun (h : @Decidable True) => fun (h_1 : (h1 : True) -> motive (@Decidable.isTrue True h1)) => fun (h_2 : (h1 : @Not True) -> motive (@Decidable.isFalse True h1)) => @Decidable.casesOn True (fun (x : @Decidable True) => motive x) h (fun (h1 : @Not True) => h_2 h1) (fun (h1 : True) => h_1 h1)
theorem decide_true : (h : @Decidable True) -> @Eq Bool (@Decidable.decide True h) Bool.true :=
  fun (h : @Decidable True) => @decide_true.match_1 (fun (h1 : @Decidable True) => @Eq Bool (@Decidable.decide True h1) Bool.true) h (fun (h1 : True) => @rfl Bool (@Decidable.decide True (@Decidable.isTrue True h1))) (fun (h1 : @Not True) => @False.elim (@Eq Bool (@Decidable.decide True (@Decidable.isFalse True h1)) Bool.true) (h1 True.intro))
theorem of_eq_false : {p : Prop} -> @Eq Prop p False -> @Not p :=
  fun {p : Prop} => fun (h : @Eq Prop p False) => fun (hp : p) => @False.elim False (@Eq.mp p False h hp)
theorem dite_cond_eq_false : {α : Sort u} -> {c : Prop} -> {x : @Decidable c} -> {t : c -> α} -> {e : @Not c -> α} -> (h : @Eq Prop c False) -> @Eq α (@dite α c x t e) (e (@of_eq_false c h)) :=
  fun {α : Sort u} => fun {c : Prop} => fun {x : @Decidable c} => fun {t : c -> α} => fun {e : @Not c -> α} => fun (h : @Eq Prop c False) => @of_eq_true (@Eq α (@dite α c x t e) (e (@of_eq_false c h))) (@Eq.trans Prop (@Eq α (@dite α c x t e) (e (@of_eq_false c h))) (@Eq α (@dite α False instDecidableFalse (fun (h1 : False) => t (@Eq.mpr_prop c False h h1)) (fun (h1 : @Not False) => e (@Eq.mpr_not c False h h1))) (e (@of_eq_false c h))) True (@congrArg α Prop (@dite α c x t e) (@dite α False instDecidableFalse (fun (h1 : False) => t (@Eq.mpr_prop c False h h1)) (fun (h1 : @Not False) => e (@Eq.mpr_not c False h h1))) (fun (x1 : α) => @Eq α x1 (e (@of_eq_false c h))) (@dite_congr c False α x instDecidableFalse t (fun (h1 : False) => t (@Eq.mpr_prop c False h h1)) e (fun (h1 : @Not False) => e (@Eq.mpr_not c False h h1)) h (fun (h1 : False) => @Eq.refl α (t (@Eq.mpr_prop c False h h1))) (fun (h1 : @Not False) => @Eq.refl α (e (@Eq.mpr_not c False h h1))))) (@eq_self α (e (@Eq.mpr_not c False h not_false))))
theorem decide_implies : (u : Prop) -> (v : Prop) -> (duv : @Decidable (u -> v)) -> (du : @Decidable u) -> {dv : u -> @Decidable v} -> @Eq Bool (@Decidable.decide (u -> v) duv) (@dite Bool u du (fun (h : u) => @Decidable.decide v (dv h)) (fun (_ : @Not u) => Bool.true)) :=
  fun (u : Prop) => fun (v : Prop) => fun (duv : @Decidable (u -> v)) => fun (du : @Decidable u) => fun {dv : u -> @Decidable v} => @dite (@Eq Bool (@Decidable.decide (u -> v) duv) (@dite Bool u du (fun (h : u) => @Decidable.decide v (dv h)) (fun (_ : @Not u) => Bool.true))) u du (fun (h : u) => @of_eq_true (@Eq Bool (@Decidable.decide (u -> v) duv) (@dite Bool u du (fun (h1 : u) => @Decidable.decide v (dv h1)) (fun (_ : @Not u) => Bool.true))) (@Eq.trans Prop (@Eq Bool (@Decidable.decide (u -> v) duv) (@dite Bool u du (fun (h1 : u) => @Decidable.decide v (dv h1)) (fun (_ : @Not u) => Bool.true))) (@Iff (u -> v) v) True (@Eq.trans Prop (@Eq Bool (@Decidable.decide (u -> v) duv) (@dite Bool u du (fun (h1 : u) => @Decidable.decide v (dv h1)) (fun (_ : @Not u) => Bool.true))) (@Eq Bool (@Decidable.decide (u -> v) duv) (@Decidable.decide v (dv (@of_eq_true u (@eq_true u h))))) (@Iff (u -> v) v) (@congrArg Bool Prop (@dite Bool u du (fun (h1 : u) => @Decidable.decide v (dv h1)) (fun (_ : @Not u) => Bool.true)) (@Decidable.decide v (dv (@of_eq_true u (@eq_true u h)))) (@Eq Bool (@Decidable.decide (u -> v) duv)) (@dite_cond_eq_true Bool u du (fun (h1 : u) => @Decidable.decide v (dv h1)) (fun (_ : @Not u) => Bool.true) (@eq_true u h))) (@Init.PropLemmas._auxLemma_53 (u -> v) v duv (dv (@of_eq_true u (@eq_true u h))))) (@Eq.trans Prop (@Iff (u -> v) v) (@Iff v v) True (@congrArg Prop Prop (u -> v) v (fun (x : Prop) => @Iff x v) (@Eq.trans Prop (u -> v) (True -> v) v (@implies_congr u True v v (@eq_true u h) (@Eq.refl Prop v)) (@Init.PropLemmas._auxLemma_20 v True (@instNonemptyOfInhabited True instInhabitedTrue)))) (@iff_self v)))) (fun (h : @Not u) => @of_eq_true (@Eq Bool (@Decidable.decide (u -> v) duv) (@dite Bool u du (fun (h1 : u) => @Decidable.decide v (dv h1)) (fun (_ : @Not u) => Bool.true))) (@Eq.trans Prop (@Eq Bool (@Decidable.decide (u -> v) duv) (@dite Bool u du (fun (h1 : u) => @Decidable.decide v (dv h1)) (fun (_ : @Not u) => Bool.true))) (@Eq Bool Bool.true Bool.true) True (@congr Bool Prop (@Eq Bool (@Decidable.decide (u -> v) duv)) (@Eq Bool Bool.true) (@dite Bool u du (fun (h1 : u) => @Decidable.decide v (dv h1)) (fun (_ : @Not u) => Bool.true)) Bool.true (@congrArg Bool (Bool -> Prop) (@Decidable.decide (u -> v) duv) Bool.true (@Eq Bool) (@Eq.trans Bool (@Decidable.decide (u -> v) duv) (@Decidable.decide True instDecidableTrue) Bool.true ((fun (p : Prop) => fun (p1 : Prop) => fun (e_p : @Eq Prop p p1) => @Eq.rec Prop p (fun (p2 : Prop) => fun (_ : @Eq Prop p p2) => {h1 : @Decidable p} -> (h2 : @Decidable p2) -> @Eq Bool (@Decidable.decide p h1) (@Decidable.decide p2 h2)) (fun {h1 : @Decidable p} => fun (h2 : @Decidable p) => @Eq.ndrec (@Decidable p) h1 (fun (h3 : @Decidable p) => @Eq Bool (@Decidable.decide p h1) (@Decidable.decide p h3)) (@Eq.refl Bool (@Decidable.decide p h1)) h2 (@Subsingleton.elim (@Decidable p) (@instSubsingletonDecidable p) h1 h2)) p1 e_p) (u -> v) True (@Eq.trans Prop (u -> v) (False -> v) True (@implies_congr u False v v (@eq_false u h) (@Eq.refl Prop v)) (@false_implies v)) duv instDecidableTrue) (@decide_true instDecidableTrue))) (@dite_cond_eq_false Bool u du (fun (h1 : u) => @Decidable.decide v (dv h1)) (fun (_ : @Not u) => Bool.true) (@eq_false u h))) (@eq_self Bool Bool.true)))
theorem decide_ite : (u : Prop) -> (du : @Decidable u) -> (p : Prop) -> (q : Prop) -> (dpq : @Decidable (@ite Prop u du p q)) -> (dp : @Decidable p) -> (dq : @Decidable q) -> @Eq Bool (@Decidable.decide (@ite Prop u du p q) dpq) (@ite Bool u du (@Decidable.decide p dp) (@Decidable.decide q dq)) :=
  fun (u : Prop) => fun (du : @Decidable u) => fun (p : Prop) => fun (q : Prop) => fun (dpq : @Decidable (@ite Prop u du p q)) => fun (dp : @Decidable p) => fun (dq : @Decidable q) => @Decidable.casesOn u (fun (t : @Decidable u) => @Eq (@Decidable u) du t -> @Eq Bool (@Decidable.decide (@ite Prop u du p q) dpq) (@ite Bool u du (@Decidable.decide p dp) (@Decidable.decide q dq))) du (fun (h : @Not u) => fun (h1 : @Eq (@Decidable u) du (@Decidable.isFalse u h)) => @Eq.ndrec (@Decidable u) (@Decidable.isFalse u h) (fun (du1 : @Decidable u) => (dpq1 : @Decidable (@ite Prop u du1 p q)) -> @Eq Bool (@Decidable.decide (@ite Prop u du1 p q) dpq1) (@ite Bool u du1 (@Decidable.decide p dp) (@Decidable.decide q dq))) (fun (dpq1 : @Decidable (@ite Prop u (@Decidable.isFalse u h) p q)) => @of_eq_true (@Eq Bool (@Decidable.decide (@ite Prop u (@Decidable.isFalse u h) p q) dpq1) (@ite Bool u (@Decidable.isFalse u h) (@Decidable.decide p dp) (@Decidable.decide q dq))) (@Eq.trans Prop (@Eq Bool (@Decidable.decide (@ite Prop u (@Decidable.isFalse u h) p q) dpq1) (@ite Bool u (@Decidable.isFalse u h) (@Decidable.decide p dp) (@Decidable.decide q dq))) (@Eq Bool (@Decidable.decide q dq) (@Decidable.decide q dq)) True (@congr Bool Prop (@Eq Bool (@Decidable.decide (@ite Prop u (@Decidable.isFalse u h) p q) dpq1)) (@Eq Bool (@Decidable.decide q dq)) (@ite Bool u (@Decidable.isFalse u h) (@Decidable.decide p dp) (@Decidable.decide q dq)) (@Decidable.decide q dq) (@congrArg Bool (Bool -> Prop) (@Decidable.decide (@ite Prop u (@Decidable.isFalse u h) p q) dpq1) (@Decidable.decide q dq) (@Eq Bool) ((fun (p1 : Prop) => fun (p2 : Prop) => fun (e_p : @Eq Prop p1 p2) => @Eq.rec Prop p1 (fun (p3 : Prop) => fun (_ : @Eq Prop p1 p3) => {h2 : @Decidable p1} -> (h3 : @Decidable p3) -> @Eq Bool (@Decidable.decide p1 h2) (@Decidable.decide p3 h3)) (fun {h2 : @Decidable p1} => fun (h3 : @Decidable p1) => @Eq.ndrec (@Decidable p1) h2 (fun (h4 : @Decidable p1) => @Eq Bool (@Decidable.decide p1 h2) (@Decidable.decide p1 h4)) (@Eq.refl Bool (@Decidable.decide p1 h2)) h3 (@Subsingleton.elim (@Decidable p1) (@instSubsingletonDecidable p1) h2 h3)) p2 e_p) (@ite Prop u (@Decidable.isFalse u h) p q) q (@ite_cond_eq_false Prop u (@Decidable.isFalse u h) p q (@eq_false u h)) dpq1 dq)) (@ite_cond_eq_false Bool u (@Decidable.isFalse u h) (@Decidable.decide p dp) (@Decidable.decide q dq) (@eq_false u h))) (@eq_self Bool (@Decidable.decide q dq)))) du (@Eq.symm (@Decidable u) du (@Decidable.isFalse u h) h1) dpq) (fun (h : u) => fun (h1 : @Eq (@Decidable u) du (@Decidable.isTrue u h)) => @Eq.ndrec (@Decidable u) (@Decidable.isTrue u h) (fun (du1 : @Decidable u) => (dpq1 : @Decidable (@ite Prop u du1 p q)) -> @Eq Bool (@Decidable.decide (@ite Prop u du1 p q) dpq1) (@ite Bool u du1 (@Decidable.decide p dp) (@Decidable.decide q dq))) (fun (dpq1 : @Decidable (@ite Prop u (@Decidable.isTrue u h) p q)) => @of_eq_true (@Eq Bool (@Decidable.decide (@ite Prop u (@Decidable.isTrue u h) p q) dpq1) (@ite Bool u (@Decidable.isTrue u h) (@Decidable.decide p dp) (@Decidable.decide q dq))) (@Eq.trans Prop (@Eq Bool (@Decidable.decide (@ite Prop u (@Decidable.isTrue u h) p q) dpq1) (@ite Bool u (@Decidable.isTrue u h) (@Decidable.decide p dp) (@Decidable.decide q dq))) (@Eq Bool (@Decidable.decide p dp) (@Decidable.decide p dp)) True (@congr Bool Prop (@Eq Bool (@Decidable.decide (@ite Prop u (@Decidable.isTrue u h) p q) dpq1)) (@Eq Bool (@Decidable.decide p dp)) (@ite Bool u (@Decidable.isTrue u h) (@Decidable.decide p dp) (@Decidable.decide q dq)) (@Decidable.decide p dp) (@congrArg Bool (Bool -> Prop) (@Decidable.decide (@ite Prop u (@Decidable.isTrue u h) p q) dpq1) (@Decidable.decide p dp) (@Eq Bool) ((fun (p1 : Prop) => fun (p2 : Prop) => fun (e_p : @Eq Prop p1 p2) => @Eq.rec Prop p1 (fun (p3 : Prop) => fun (_ : @Eq Prop p1 p3) => {h2 : @Decidable p1} -> (h3 : @Decidable p3) -> @Eq Bool (@Decidable.decide p1 h2) (@Decidable.decide p3 h3)) (fun {h2 : @Decidable p1} => fun (h3 : @Decidable p1) => @Eq.ndrec (@Decidable p1) h2 (fun (h4 : @Decidable p1) => @Eq Bool (@Decidable.decide p1 h2) (@Decidable.decide p1 h4)) (@Eq.refl Bool (@Decidable.decide p1 h2)) h3 (@Subsingleton.elim (@Decidable p1) (@instSubsingletonDecidable p1) h2 h3)) p2 e_p) (@ite Prop u (@Decidable.isTrue u h) p q) p (@ite_cond_eq_true Prop u (@Decidable.isTrue u h) p q (@eq_true u h)) dpq1 dp)) (@ite_cond_eq_true Bool u (@Decidable.isTrue u h) (@Decidable.decide p dp) (@Decidable.decide q dq) (@eq_true u h))) (@eq_self Bool (@Decidable.decide p dp)))) du (@Eq.symm (@Decidable u) du (@Decidable.isTrue u h) h1) dpq) (@Eq.refl (@Decidable u) du)
inductive PUnit : Sort u where
  | unit : PUnit
def Unit : Type :=
  PUnit
-- ctor PUnit.unit : PUnit
def Unit.unit : Unit :=
  PUnit.unit
def cond.match_1 : (motive : Bool -> Sort u_1) -> (c : Bool) -> (Unit -> motive Bool.true) -> (Unit -> motive Bool.false) -> motive c :=
  fun (motive : Bool -> Sort u_1) => fun (c : Bool) => fun (h_1 : Unit -> motive Bool.true) => fun (h_2 : Unit -> motive Bool.false) => @Bool.casesOn (fun (x : Bool) => motive x) c (h_2 Unit.unit) (h_1 Unit.unit)
def Bool.or : Bool -> Bool -> Bool :=
  fun (x : Bool) => fun (y : Bool) => @cond.match_1 (fun (_ : Bool) => Bool) x (fun (_ : Unit) => Bool.true) (fun (_ : Unit) => y)
def decide_false.match_1 : (motive : @Decidable False -> Prop) -> (h : @Decidable False) -> ((h1 : @Not False) -> motive (@Decidable.isFalse False h1)) -> ((h1 : False) -> motive (@Decidable.isTrue False h1)) -> motive h :=
  fun (motive : @Decidable False -> Prop) => fun (h : @Decidable False) => fun (h_1 : (h1 : @Not False) -> motive (@Decidable.isFalse False h1)) => fun (h_2 : (h1 : False) -> motive (@Decidable.isTrue False h1)) => @Decidable.casesOn False (fun (x : @Decidable False) => motive x) h (fun (h1 : @Not False) => h_1 h1) (fun (h1 : False) => h_2 h1)
theorem decide_false : (h : @Decidable False) -> @Eq Bool (@Decidable.decide False h) Bool.false :=
  fun (h : @Decidable False) => @decide_false.match_1 (fun (h1 : @Decidable False) => @Eq Bool (@Decidable.decide False h1) Bool.false) h (fun (h1 : @Not False) => @rfl Bool (@Decidable.decide False (@Decidable.isFalse False h1))) (fun (h1 : False) => @False.elim (@Eq Bool (@Decidable.decide False (@Decidable.isTrue False h1)) Bool.false) h1)
theorem Bool.false_or : (b : Bool) -> @Eq Bool (@Bool.or Bool.false b) b :=
  fun (b : Bool) => @Bool.casesOn (fun (t : Bool) => @Eq Bool b t -> @Eq Bool (@Bool.or Bool.false b) b) b (fun (h : @Eq Bool b Bool.false) => @Eq.ndrec Bool Bool.false (fun (b1 : Bool) => @Eq Bool (@Bool.or Bool.false b1) b1) (@Eq.refl Bool (@Bool.or Bool.false Bool.false)) b (@Eq.symm Bool b Bool.false h)) (fun (h : @Eq Bool b Bool.true) => @Eq.ndrec Bool Bool.true (fun (b1 : Bool) => @Eq Bool (@Bool.or Bool.false b1) b1) (@Eq.refl Bool (@Bool.or Bool.false Bool.true)) b (@Eq.symm Bool b Bool.true h)) (@Eq.refl Bool b)
theorem Bool.true_or : (b : Bool) -> @Eq Bool (@Bool.or Bool.true b) Bool.true :=
  fun (b : Bool) => @Bool.casesOn (fun (t : Bool) => @Eq Bool b t -> @Eq Bool (@Bool.or Bool.true b) Bool.true) b (fun (h : @Eq Bool b Bool.false) => @Eq.ndrec Bool Bool.false (fun (b1 : Bool) => @Eq Bool (@Bool.or Bool.true b1) Bool.true) (@Eq.refl Bool (@Bool.or Bool.true Bool.false)) b (@Eq.symm Bool b Bool.false h)) (fun (h : @Eq Bool b Bool.true) => @Eq.ndrec Bool Bool.true (fun (b1 : Bool) => @Eq Bool (@Bool.or Bool.true b1) Bool.true) (@Eq.refl Bool (@Bool.or Bool.true Bool.true)) b (@Eq.symm Bool b Bool.true h)) (@Eq.refl Bool b)
theorem ite_then_decide_self : (p : Prop) -> (h : @Decidable p) -> {w : @Decidable p} -> (q : Bool) -> @Eq Bool (@ite Bool p h (@Decidable.decide p w) q) (@Bool.or (@Decidable.decide p w) q) :=
  fun (p : Prop) => fun (h : @Decidable p) => fun {w : @Decidable p} => fun (q : Bool) => @Decidable.casesOn p (fun (_ : @Decidable p) => @Eq Bool (@ite Bool p h (@Decidable.decide p w) q) (@Bool.or (@Decidable.decide p w) q)) h (fun (h1 : @Not p) => @Eq.mpr (@Eq Bool (@ite Bool p h (@Decidable.decide p w) q) (@Bool.or (@Decidable.decide p w) q)) (@Eq Bool q (@Bool.or (@Decidable.decide p w) q)) (@id (@Eq Prop (@Eq Bool (@ite Bool p h (@Decidable.decide p w) q) (@Bool.or (@Decidable.decide p w) q)) (@Eq Bool q (@Bool.or (@Decidable.decide p w) q))) (@congrArg Bool Prop (@ite Bool p h (@Decidable.decide p w) q) q (fun (x : Bool) => @Eq Bool x (@Bool.or (@Decidable.decide p w) q)) (@if_neg p h h1 Bool (@Decidable.decide p w) q))) (@of_eq_true (@Eq Bool q (@Bool.or (@Decidable.decide p w) q)) (@Eq.trans Prop (@Eq Bool q (@Bool.or (@Decidable.decide p w) q)) (@Eq Bool q q) True (@congrArg Bool Prop (@Bool.or (@Decidable.decide p w) q) q (@Eq Bool q) (@Eq.trans Bool (@Bool.or (@Decidable.decide p w) q) (@Bool.or Bool.false q) q (@congrArg Bool Bool (@Decidable.decide p w) Bool.false (fun (x : Bool) => @Bool.or x q) (@Eq.trans Bool (@Decidable.decide p w) (@Decidable.decide False instDecidableFalse) Bool.false ((fun (p1 : Prop) => fun (p2 : Prop) => fun (e_p : @Eq Prop p1 p2) => @Eq.rec Prop p1 (fun (p3 : Prop) => fun (_ : @Eq Prop p1 p3) => {h2 : @Decidable p1} -> (h3 : @Decidable p3) -> @Eq Bool (@Decidable.decide p1 h2) (@Decidable.decide p3 h3)) (fun {h2 : @Decidable p1} => fun (h3 : @Decidable p1) => @Eq.ndrec (@Decidable p1) h2 (fun (h4 : @Decidable p1) => @Eq Bool (@Decidable.decide p1 h2) (@Decidable.decide p1 h4)) (@Eq.refl Bool (@Decidable.decide p1 h2)) h3 (@Subsingleton.elim (@Decidable p1) (@instSubsingletonDecidable p1) h2 h3)) p2 e_p) p False (@eq_false p h1) w instDecidableFalse) (@decide_false instDecidableFalse))) (@Bool.false_or q))) (@eq_self Bool q)))) (fun (h1 : p) => @Eq.mpr (@Eq Bool (@ite Bool p h (@Decidable.decide p w) q) (@Bool.or (@Decidable.decide p w) q)) (@Eq Bool (@Decidable.decide p w) (@Bool.or (@Decidable.decide p w) q)) (@id (@Eq Prop (@Eq Bool (@ite Bool p h (@Decidable.decide p w) q) (@Bool.or (@Decidable.decide p w) q)) (@Eq Bool (@Decidable.decide p w) (@Bool.or (@Decidable.decide p w) q))) (@congrArg Bool Prop (@ite Bool p h (@Decidable.decide p w) q) (@Decidable.decide p w) (fun (x : Bool) => @Eq Bool x (@Bool.or (@Decidable.decide p w) q)) (@if_pos p h h1 Bool (@Decidable.decide p w) q))) (@of_eq_true (@Eq Bool (@Decidable.decide p w) (@Bool.or (@Decidable.decide p w) q)) (@Eq.trans Prop (@Eq Bool (@Decidable.decide p w) (@Bool.or (@Decidable.decide p w) q)) (@Eq Bool Bool.true Bool.true) True (@congr Bool Prop (@Eq Bool (@Decidable.decide p w)) (@Eq Bool Bool.true) (@Bool.or (@Decidable.decide p w) q) Bool.true (@congrArg Bool (Bool -> Prop) (@Decidable.decide p w) Bool.true (@Eq Bool) (@Eq.trans Bool (@Decidable.decide p w) (@Decidable.decide True instDecidableTrue) Bool.true ((fun (p1 : Prop) => fun (p2 : Prop) => fun (e_p : @Eq Prop p1 p2) => @Eq.rec Prop p1 (fun (p3 : Prop) => fun (_ : @Eq Prop p1 p3) => {h2 : @Decidable p1} -> (h3 : @Decidable p3) -> @Eq Bool (@Decidable.decide p1 h2) (@Decidable.decide p3 h3)) (fun {h2 : @Decidable p1} => fun (h3 : @Decidable p1) => @Eq.ndrec (@Decidable p1) h2 (fun (h4 : @Decidable p1) => @Eq Bool (@Decidable.decide p1 h2) (@Decidable.decide p1 h4)) (@Eq.refl Bool (@Decidable.decide p1 h2)) h3 (@Subsingleton.elim (@Decidable p1) (@instSubsingletonDecidable p1) h2 h3)) p2 e_p) p True (@eq_true p h1) w instDecidableTrue) (@decide_true instDecidableTrue))) (@Eq.trans Bool (@Bool.or (@Decidable.decide p w) q) (@Bool.or Bool.true q) Bool.true (@congrArg Bool Bool (@Decidable.decide p w) Bool.true (fun (x : Bool) => @Bool.or x q) (@Eq.trans Bool (@Decidable.decide p w) (@Decidable.decide True instDecidableTrue) Bool.true ((fun (p1 : Prop) => fun (p2 : Prop) => fun (e_p : @Eq Prop p1 p2) => @Eq.rec Prop p1 (fun (p3 : Prop) => fun (_ : @Eq Prop p1 p3) => {h2 : @Decidable p1} -> (h3 : @Decidable p3) -> @Eq Bool (@Decidable.decide p1 h2) (@Decidable.decide p3 h3)) (fun {h2 : @Decidable p1} => fun (h3 : @Decidable p1) => @Eq.ndrec (@Decidable p1) h2 (fun (h4 : @Decidable p1) => @Eq Bool (@Decidable.decide p1 h2) (@Decidable.decide p1 h4)) (@Eq.refl Bool (@Decidable.decide p1 h2)) h3 (@Subsingleton.elim (@Decidable p1) (@instSubsingletonDecidable p1) h2 h3)) p2 e_p) p True (@eq_true p h1) w instDecidableTrue) (@decide_true instDecidableTrue))) (@Bool.true_or q))) (@eq_self Bool Bool.true))))
theorem ite_true_decide_same : (p : Prop) -> (inst : @Decidable p) -> (b : Bool) -> @Eq Bool (@ite Bool p inst (@Decidable.decide p inst) b) (@Bool.or (@Decidable.decide p inst) b) :=
  fun (p : Prop) => fun (inst : @Decidable p) => fun (b : Bool) => @ite_then_decide_self p inst inst b
def Bool.and.match_1 : (motive : Bool -> Sort u_1) -> (x : Bool) -> (Unit -> motive Bool.false) -> (Unit -> motive Bool.true) -> motive x :=
  fun (motive : Bool -> Sort u_1) => fun (x : Bool) => fun (h_1 : Unit -> motive Bool.false) => fun (h_2 : Unit -> motive Bool.true) => @Bool.casesOn (fun (x1 : Bool) => motive x1) x (h_1 Unit.unit) (h_2 Unit.unit)
def Bool.and : Bool -> Bool -> Bool :=
  fun (x : Bool) => fun (y : Bool) => @Bool.and.match_1 (fun (_ : Bool) => Bool) x (fun (_ : Unit) => Bool.false) (fun (_ : Unit) => y)
theorem Bool.false_and : (b : Bool) -> @Eq Bool (@Bool.and Bool.false b) Bool.false :=
  fun (b : Bool) => @Bool.casesOn (fun (t : Bool) => @Eq Bool b t -> @Eq Bool (@Bool.and Bool.false b) Bool.false) b (fun (h : @Eq Bool b Bool.false) => @Eq.ndrec Bool Bool.false (fun (b1 : Bool) => @Eq Bool (@Bool.and Bool.false b1) Bool.false) (@Eq.refl Bool (@Bool.and Bool.false Bool.false)) b (@Eq.symm Bool b Bool.false h)) (fun (h : @Eq Bool b Bool.true) => @Eq.ndrec Bool Bool.true (fun (b1 : Bool) => @Eq Bool (@Bool.and Bool.false b1) Bool.false) (@Eq.refl Bool (@Bool.and Bool.false Bool.true)) b (@Eq.symm Bool b Bool.true h)) (@Eq.refl Bool b)
theorem Bool.true_and : (b : Bool) -> @Eq Bool (@Bool.and Bool.true b) b :=
  fun (b : Bool) => @Bool.casesOn (fun (t : Bool) => @Eq Bool b t -> @Eq Bool (@Bool.and Bool.true b) b) b (fun (h : @Eq Bool b Bool.false) => @Eq.ndrec Bool Bool.false (fun (b1 : Bool) => @Eq Bool (@Bool.and Bool.true b1) b1) (@Eq.refl Bool (@Bool.and Bool.true Bool.false)) b (@Eq.symm Bool b Bool.false h)) (fun (h : @Eq Bool b Bool.true) => @Eq.ndrec Bool Bool.true (fun (b1 : Bool) => @Eq Bool (@Bool.and Bool.true b1) b1) (@Eq.refl Bool (@Bool.and Bool.true Bool.true)) b (@Eq.symm Bool b Bool.true h)) (@Eq.refl Bool b)
theorem ite_else_decide_self : (p : Prop) -> (h : @Decidable p) -> {w : @Decidable p} -> (q : Bool) -> @Eq Bool (@ite Bool p h q (@Decidable.decide p w)) (@Bool.and (@Decidable.decide p w) q) :=
  fun (p : Prop) => fun (h : @Decidable p) => fun {w : @Decidable p} => fun (q : Bool) => @Decidable.casesOn p (fun (_ : @Decidable p) => @Eq Bool (@ite Bool p h q (@Decidable.decide p w)) (@Bool.and (@Decidable.decide p w) q)) h (fun (h1 : @Not p) => @Eq.mpr (@Eq Bool (@ite Bool p h q (@Decidable.decide p w)) (@Bool.and (@Decidable.decide p w) q)) (@Eq Bool (@Decidable.decide p w) (@Bool.and (@Decidable.decide p w) q)) (@id (@Eq Prop (@Eq Bool (@ite Bool p h q (@Decidable.decide p w)) (@Bool.and (@Decidable.decide p w) q)) (@Eq Bool (@Decidable.decide p w) (@Bool.and (@Decidable.decide p w) q))) (@congrArg Bool Prop (@ite Bool p h q (@Decidable.decide p w)) (@Decidable.decide p w) (fun (x : Bool) => @Eq Bool x (@Bool.and (@Decidable.decide p w) q)) (@if_neg p h h1 Bool q (@Decidable.decide p w)))) (@of_eq_true (@Eq Bool (@Decidable.decide p w) (@Bool.and (@Decidable.decide p w) q)) (@Eq.trans Prop (@Eq Bool (@Decidable.decide p w) (@Bool.and (@Decidable.decide p w) q)) (@Eq Bool Bool.false Bool.false) True (@congr Bool Prop (@Eq Bool (@Decidable.decide p w)) (@Eq Bool Bool.false) (@Bool.and (@Decidable.decide p w) q) Bool.false (@congrArg Bool (Bool -> Prop) (@Decidable.decide p w) Bool.false (@Eq Bool) (@Eq.trans Bool (@Decidable.decide p w) (@Decidable.decide False instDecidableFalse) Bool.false ((fun (p1 : Prop) => fun (p2 : Prop) => fun (e_p : @Eq Prop p1 p2) => @Eq.rec Prop p1 (fun (p3 : Prop) => fun (_ : @Eq Prop p1 p3) => {h2 : @Decidable p1} -> (h3 : @Decidable p3) -> @Eq Bool (@Decidable.decide p1 h2) (@Decidable.decide p3 h3)) (fun {h2 : @Decidable p1} => fun (h3 : @Decidable p1) => @Eq.ndrec (@Decidable p1) h2 (fun (h4 : @Decidable p1) => @Eq Bool (@Decidable.decide p1 h2) (@Decidable.decide p1 h4)) (@Eq.refl Bool (@Decidable.decide p1 h2)) h3 (@Subsingleton.elim (@Decidable p1) (@instSubsingletonDecidable p1) h2 h3)) p2 e_p) p False (@eq_false p h1) w instDecidableFalse) (@decide_false instDecidableFalse))) (@Eq.trans Bool (@Bool.and (@Decidable.decide p w) q) (@Bool.and Bool.false q) Bool.false (@congrArg Bool Bool (@Decidable.decide p w) Bool.false (fun (x : Bool) => @Bool.and x q) (@Eq.trans Bool (@Decidable.decide p w) (@Decidable.decide False instDecidableFalse) Bool.false ((fun (p1 : Prop) => fun (p2 : Prop) => fun (e_p : @Eq Prop p1 p2) => @Eq.rec Prop p1 (fun (p3 : Prop) => fun (_ : @Eq Prop p1 p3) => {h2 : @Decidable p1} -> (h3 : @Decidable p3) -> @Eq Bool (@Decidable.decide p1 h2) (@Decidable.decide p3 h3)) (fun {h2 : @Decidable p1} => fun (h3 : @Decidable p1) => @Eq.ndrec (@Decidable p1) h2 (fun (h4 : @Decidable p1) => @Eq Bool (@Decidable.decide p1 h2) (@Decidable.decide p1 h4)) (@Eq.refl Bool (@Decidable.decide p1 h2)) h3 (@Subsingleton.elim (@Decidable p1) (@instSubsingletonDecidable p1) h2 h3)) p2 e_p) p False (@eq_false p h1) w instDecidableFalse) (@decide_false instDecidableFalse))) (@Bool.false_and q))) (@eq_self Bool Bool.false)))) (fun (h1 : p) => @Eq.mpr (@Eq Bool (@ite Bool p h q (@Decidable.decide p w)) (@Bool.and (@Decidable.decide p w) q)) (@Eq Bool q (@Bool.and (@Decidable.decide p w) q)) (@id (@Eq Prop (@Eq Bool (@ite Bool p h q (@Decidable.decide p w)) (@Bool.and (@Decidable.decide p w) q)) (@Eq Bool q (@Bool.and (@Decidable.decide p w) q))) (@congrArg Bool Prop (@ite Bool p h q (@Decidable.decide p w)) q (fun (x : Bool) => @Eq Bool x (@Bool.and (@Decidable.decide p w) q)) (@if_pos p h h1 Bool q (@Decidable.decide p w)))) (@of_eq_true (@Eq Bool q (@Bool.and (@Decidable.decide p w) q)) (@Eq.trans Prop (@Eq Bool q (@Bool.and (@Decidable.decide p w) q)) (@Eq Bool q q) True (@congrArg Bool Prop (@Bool.and (@Decidable.decide p w) q) q (@Eq Bool q) (@Eq.trans Bool (@Bool.and (@Decidable.decide p w) q) (@Bool.and Bool.true q) q (@congrArg Bool Bool (@Decidable.decide p w) Bool.true (fun (x : Bool) => @Bool.and x q) (@Eq.trans Bool (@Decidable.decide p w) (@Decidable.decide True instDecidableTrue) Bool.true ((fun (p1 : Prop) => fun (p2 : Prop) => fun (e_p : @Eq Prop p1 p2) => @Eq.rec Prop p1 (fun (p3 : Prop) => fun (_ : @Eq Prop p1 p3) => {h2 : @Decidable p1} -> (h3 : @Decidable p3) -> @Eq Bool (@Decidable.decide p1 h2) (@Decidable.decide p3 h3)) (fun {h2 : @Decidable p1} => fun (h3 : @Decidable p1) => @Eq.ndrec (@Decidable p1) h2 (fun (h4 : @Decidable p1) => @Eq Bool (@Decidable.decide p1 h2) (@Decidable.decide p1 h4)) (@Eq.refl Bool (@Decidable.decide p1 h2)) h3 (@Subsingleton.elim (@Decidable p1) (@instSubsingletonDecidable p1) h2 h3)) p2 e_p) p True (@eq_true p h1) w instDecidableTrue) (@decide_true instDecidableTrue))) (@Bool.true_and q))) (@eq_self Bool q))))
theorem ite_false_decide_same : (p : Prop) -> (inst : @Decidable p) -> (b : Bool) -> @Eq Bool (@ite Bool p inst b (@Decidable.decide p inst)) (@Bool.and (@Decidable.decide p inst) b) :=
  fun (p : Prop) => fun (inst : @Decidable p) => fun (b : Bool) => @ite_else_decide_self p inst inst b
